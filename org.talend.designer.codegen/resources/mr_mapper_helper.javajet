	<%
	//need to define MapperHelper before MapperGenerator, so use this trick
	class MapperHelperBase{
		public void map(){
		}
		
		public void prepare(){
		}
		
		public void configure(){
		}
		
		public void close(){
		}
	}
	
	class MapperGenerator{
		MapperHelperBase mapper;
		
		org.talend.core.model.process.AbstractNode node = null;
		String cid = null;
		String mapperClass = null;

		Object inKey = null;
		Object inKeyClass = null;

		Object inValue = null;
		Object inValueClass = null;

		Object outKey = null;
		Object outKeyClass = null;

		Object outValue = null;
		Object outValueClass = null;
		
		public MapperGenerator(MapperHelperBase mapper){
			this.mapper = mapper; 
		}
		
		public void init(INode node, String cid, Object inKey, Object inValue, Object outKey, Object outValue){
			this.node = (org.talend.core.model.process.AbstractNode)node;
			this.cid = cid;
			this.inKey = (inKey == null ? "key_"+cid : inKey);
			this.inValue = (inValue == null ? "value_"+cid : inValue);
			this.outKey = (outKey == null ? "outputKey_"+cid : outKey);
			this.outValue = (outValue == null ? "outputValue_"+cid : outValue);
			this.mapperClass = buildClassName(cid, "m");
			this.inKeyClass = buildClassName(inKey, "row");
			this.inValueClass = buildClassName(inValue, "row");
			this.outKeyClass = buildClassName(outKey, "row");
			this.outValueClass = buildClassName(outValue, "row");
		}
		
		private String buildClassName(String name, String type){
			if(type.equals("m")){
				return name + "Mapper";
			}else if(type.equals("r")){
				return name + "Reducer";
			}else if(type.equals("row")){
				return name + "Struct";
			}else{
				return null;
			}
		}
		
		private Object buildClassName(Object name, String type){
			if(type.equals("row")){
				if(name instanceof java.util.Map){
					java.util.Map<String, String> classes = new java.util.HashMap<String, String>();
					java.util.Map<String, String> names = (java.util.Map<String, String>)name;
					for(String key : names.keySet()){
						classes.put(key, buildClassName(names.get(key), "row"));
					}
					return classes;
				}else if(name instanceof String){
					return buildClassName(name.toString(), "row");
				}else if(name == null){
					return "NullWritable";
				}
			}
			return null;
		}
		
		public String getInKeyClass(String name){
			if(inKeyClass instanceof java.util.Map){
				return ((java.util.Map<String, String>)inKeyClass).get(name);
			}
			return getInKeyClass();
		}
		
		public String getInKeyClass(){
			if(inKeyClass instanceof String){
				return inKeyClass.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getInKey(String name){
			if(inKey instanceof java.util.Map){
				return ((java.util.Map<String, String>)inKey).get(name);
			}
			return getInKey();
		}
		
		public String getInKey(){
			if(inKey instanceof String){
				return inKey.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getOutKeyClass(String name){
			if(outKeyClass instanceof java.util.Map){
				return ((java.util.Map<String, String>)outKeyClass).get(name);
			}
			return getOutKeyClass();
		}
		
		public String getOutKeyClass(){
			if(outKeyClass instanceof String){
				return outKeyClass.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getOutKey(String name){
			if(outKey instanceof java.util.Map){
				return ((java.util.Map<String, String>)outKey).get(name);
			}
			return getOutKey();
		}
		
		public String getOutKey(){
			if(outKey instanceof String){
				return outKey.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getInValueClass(String name){
			if(inValueClass instanceof java.util.Map){
				return ((java.util.Map<String, String>)inValueClass).get(name);
			}
			return getInValueClass();
		}
		
		public String getInValueClass(){
			if(inValueClass instanceof String){
				return inValueClass.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getInValue(String name){
			if(inValue instanceof java.util.Map){
				return ((java.util.Map<String, String>)inValue).get(name);
			}
			return getInValue();
		}
		
		public String getInValue(){
			if(inValue instanceof String){
				return inValue.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getOutValueClass(String name){
			if(outValueClass instanceof java.util.Map){
				return ((java.util.Map<String, String>)outValueClass).get(name);
			}
			return getOutValueClass();
		}
		
		public String getOutValueClass(){
			if(outValueClass instanceof String){
				return outValueClass.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public String getOutValue(String name){
			if(outValue instanceof java.util.Map){
				return ((java.util.Map<String, String>)outValue).get(name);
			}
			return getOutValue();
		}
		
		public String getOutValue(){
			if(outValue instanceof String){
				return outValue.toString();
			}else{
				System.err.println("not single, wrong call");
				return null;
			}
		}
		
		public void output(String outKey, String outValue){
			outKey = (outKey == null ? "outputKey_"+cid : outKey);
			%>
			output_<%=cid%>.collect(<%=outKey%>, <%=outValue%>);
		<%
		}
		public void generate(){
		%>
			public static class <%=mapperClass%> extends MapReduceBase 
				implements Mapper<<%=inKeyClass%>, <%=inValueClass%>, <%=outKeyClass%>, <%=outValueClass%>>{
				
				ContextProperties context;
				<%=outKeyClass%> <%=outKey%> = null;
				<%if(!outKey.equals(outValue)){//for tFindQuantiles, if outKey same as outValue, assume the write want to reuse same object%>
					<%=outValueClass%> <%=outValue%> = null;
				<%}%>
				<%mapper.prepare();%>
				
				public void configure(JobConf job_<%=cid%>){
					context = new ContextProperties(job_<%=cid%>);
					<%if("NullWritable".equals(outKeyClass)){%>
						<%=outKey%> = NullWritable.get();
					<%}else{%>
						<%=outKey%> = new <%=outKeyClass%>(); 
					<%}%>
					<%if(!outKey.equals(outValue)){%>
						<%=outValue%> = new <%=outValueClass%>();
					<%}%>
					<%mapper.configure();%>
  				}
				
				public void map(<%=inKeyClass%> key_<%=cid%>, <%=inValueClass%> value_<%=cid%>, 
					OutputCollector<<%=outKeyClass%>, <%=outValueClass%>> output_<%=cid%>, Reporter reporter_<%=cid%>) throws IOException{
					<%mapper.map();%>
				}
					
				public void close() throws IOException{
					<%mapper.close();%>
  				}
    		}
    	<%
		}
		public void generateConf(){
			if(node.isMapOnlyAfterReduce()){
			%>
				ChainReducer.addMapper(job, <%=mapperClass%>.class, <%=inKeyClass%>.class,
	        		<%=inValueClass%>.class, <%=outKeyClass%>.class, <%=outValueClass%>.class, true, new JobConf(false));
			<%
			}else{
			%>
				chainMapper.addMapper(job, <%=mapperClass%>.class, <%=inKeyClass%>.class,
	        		<%=inValueClass%>.class, <%=outKeyClass%>.class, <%=outValueClass%>.class, true, new JobConf(false));
			<%
			}
		}
		
		public void generateConf(org.talend.core.model.process.IConnection inConn){
			String startNodeCid = inConn.getSource().getSubProcessStartNode(false).getUniqueName();
			%>
				chainMapper.setCid("<%=startNodeCid%>");
			<%
			generateConf();
		}
	} 
	
	class MOMapperGenerator extends MapperGenerator{
		public MOMapperGenerator(MapperHelperBase mapper){
			super(mapper); 
		}
		
		public void output(String outKey, String outValue){
			outKey = (outKey == null ? "outputKey_"+cid : outKey);
			%>
			mos_<%=cid%>.getCollector("<%=outValue%>", reporter_<%=cid%>).collect(<%=outKey%>, <%=outValue%>);
		<%
		}
		public void generate(){
		%>
			public static class <%=mapperClass%> extends MapReduceBase 
				implements Mapper<<%=inKeyClass%>, <%=inValueClass%>, <%=outKeyClass%>, WritableComparable>{
				ContextProperties context;
				public MultipleOutputs mos_<%=cid%>;
				<%=outKeyClass%> <%=outKey%> = null;
				<%
				if(outValueClass instanceof java.util.Map){
					for(String key : ((java.util.Map<String, String>)outValueClass).keySet()){
					%>
						<%=((java.util.Map)outValueClass).get(key)%> <%=((java.util.Map)outValue).get(key)%> = null;	
					<%	
					}
				}
				%>
				<%mapper.prepare();%>
				
				public void configure(JobConf job_<%=cid%>){
					context = new ContextProperties(job_<%=cid%>);
					mos_<%=cid%> = new MultipleOutputs(job_<%=cid%>);
					<%if("NullWritable".equals(outKeyClass)){%>
						<%=outKey%> = NullWritable.get();
					<%}else{%>
						<%=outKey%> = new <%=outKeyClass%>(); 
					<%}%>
					<%
					if(outValueClass instanceof java.util.Map){
						for(String key : ((java.util.Map<String, String>)outValueClass).keySet()){
						%>
							<%=((java.util.Map)outValue).get(key)%> = new <%=((java.util.Map)outValueClass).get(key)%>();	
						<%	
						}
					}
					%>
					<%mapper.configure();%>
  				}
				
				public void map(<%=inKeyClass%> key_<%=cid%>, <%=inValueClass%> value_<%=cid%>, 
					OutputCollector<<%=outKeyClass%>, WritableComparable> output_<%=cid%>, Reporter reporter_<%=cid%>) throws IOException{
					<%mapper.map();%>
				}
					
				public void close() throws IOException{
					mos_<%=cid%>.close();
					<%mapper.close();%>
  				}
    		}
    	<%
		}
		public void generateConf(){
			if(node.isMapOnlyAfterReduce()){
			%>
				ChainReducer.addMapper(job, <%=mapperClass%>.class, <%=inKeyClass%>.class,
	        		<%=inValueClass%>.class, <%=outKeyClass%>.class, WritableComparable.class, true, new JobConf(false));
			<%
			}else{
			%>
				chainMapper.addMapper(job, <%=mapperClass%>.class, <%=inKeyClass%>.class,
	        		<%=inValueClass%>.class, <%=outKeyClass%>.class, WritableComparable.class, true, new JobConf(false));
			<%
			}	
			%>       
        	MultipleOutputs.setWorkDir(job, genTempFolderForComponent("MultipleOutputs_<%=cid%>"));
        	<%
        	java.util.Map<String, String> values = (java.util.Map<String, String>)outValue;
        	for(String key : values.keySet()){
        	%>
				MultipleOutputs.setKeyValue(job, "<%=values.get(key)%>", <%=outKeyClass%>.class, <%=getOutValueClass(key)%>.class);
        	<%
        	}
		}
	}
	
	final String M_TYPE_BASE = "base";
	final String M_TYPE_MO = "mo";
	
	class MapperHelper extends MapperHelperBase{
		
		MapperGenerator mapperGen;
		
		String cid = null;

		public void setType(String type){
			if(type.equals(M_TYPE_BASE)){
				mapperGen = new MapperGenerator(this);
			}else if(type.equals(M_TYPE_MO)){
				mapperGen = new MOMapperGenerator(this);
			}
		}

		public void init(INode node, String cid, String inKey, String inValue, String outKey, Object outValue){
			if(mapperGen == null){
				mapperGen = new MapperGenerator(this);
			}
			mapperGen.init(node, cid, inKey, inValue, outKey, outValue);
			this.cid = mapperGen.cid;
		}
		
		public String getInKeyClass(String name){
			return mapperGen.getInKeyClass(name);
		}
		
		public String getInKeyClass(){
			return mapperGen.getInKeyClass();
		}
		
		public String getInKey(String name){
			return mapperGen.getInKey(name);
		}
		
		public String getInKey(){
			return mapperGen.getInKey();
		}
		
		public String getOutKeyClass(String name){
			return mapperGen.getOutKeyClass(name);
		}
		
		public String getOutKeyClass(){
			return mapperGen.getOutKeyClass();
		}
		
		public String getOutKey(String name){
			return mapperGen.getOutKey(name);
		}
		
		public String getOutKey(){
			return mapperGen.getOutKey();
		}
		
		public String getInValueClass(String name){
			return mapperGen.getInValueClass(name);
		}
		
		public String getInValueClass(){
			return mapperGen.getInValueClass();
		}
		
		public String getInValue(String name){
			return mapperGen.getInValue(name);
		}
		
		public String getInValue(){
			return mapperGen.getInValue();
		}
		
		public String getOutValueClass(String name){
			return mapperGen.getOutValueClass(name);
		}
		
		public String getOutValueClass(){
			return mapperGen.getOutValueClass();
		}
		
		public String getOutValue(String name){
			return mapperGen.getOutValue(name);
		}
		
		public String getOutValue(){
			return mapperGen.getOutValue();
		}
		
		public void output(String outKey, String outValue){
			mapperGen.output(outKey, outValue);
		}
		
		public void generate(){
			mapperGen.generate();
		}
		
		public void generateConf(){
			mapperGen.generateConf();
		}

		public void generateConf(org.talend.core.model.process.IConnection inConn){
			mapperGen.generateConf(inConn);
		}
		
		public void map(){
		}
		
		public void prepare(){
		}
		
		public void configure(){
		}
		
		public void close(){
		}
	}
	%>