<%@ jet 
	package="org.talend.designer.codegen.translators" 
	imports="
		org.talend.designer.codegen.config.NodesSubTree
		org.talend.designer.codegen.config.CodeGeneratorArgument
		org.talend.core.model.metadata.IMetadataTable
		org.talend.core.model.process.INode
		org.talend.core.model.process.IConnection
		org.talend.core.model.process.EConnectionType
		org.talend.core.model.process.ElementParameterParser
		java.util.List
		java.util.Iterator
	" 
	class="SubProcessFooter" 
%>
<%
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	NodesSubTree subTree = (NodesSubTree) codeGenArgument.getArgument();
	boolean isRunInMultiThread = codeGenArgument.getIsRunInMultiThread();
	
	for (INode node : subTree.getNodes()) {
		List<IMetadataTable> metadatas = node.getMetadataList();
		List< ? extends IConnection> conns = node.getOutgoingConnections();
	}

	boolean isParallelize = false;
	INode asyncIn = subTree.getRootNode();
	if(asyncIn!=null && asyncIn.getComponent().getName().equals("tAsyncIn")){
		String parallelize = ElementParameterParser.getValue(asyncIn, "__PARALLELIZE__");
		isParallelize = (parallelize!=null&&!parallelize.equals(""))?parallelize.equals("true"):false;
		// temporary modification : if tAsyncIn is available, this is always a parallelized process
		isParallelize = true;
	}
	if(isParallelize){
%>

					} catch (Exception e) {
						this.status = "failure";
						Integer localErrorCode = (Integer) (((java.util.Map) threadLocal.get()).get("errorCode"));
						if (localErrorCode != null) {
							if (this.errorCode == null || localErrorCode.compareTo(this.errorCode) > 0) {
								this.errorCode = localErrorCode;
							}
						}					
			            pool.setErrorThread(this);
			            pool.stopAllThreads();
			            e.printStackTrace();					
					}
					this.isRunning = false;
					
					Integer localErrorCode = (Integer) (((java.util.Map) threadLocal.get()).get("errorCode"));
					String localStatus = (String) (((java.util.Map) threadLocal.get()).get("status"));
					if (localErrorCode != null) {
						if (this.errorCode == null || localErrorCode.compareTo(this.errorCode) > 0) {
							this.errorCode = localErrorCode;
						}
					} else if (!this.status.equals("failure")) {
						this.status = localStatus;
					}
			
					pool.getTalendThreadResult().setErrorCode(this.errorCode);
					pool.getTalendThreadResult().setStatus(this.status);	
				}//Run method
			}//ParallelThread class

			List<String[]> buffer = (List<String[]>) globalMap
					.get("PARALLEL_FLOW_BUFFER");

			if (pool.isFull()) {
				ParallelThread pt = pool.getFreeThread();// wait for Free Thread
				pt.putBuffer(buffer);// notify the ParallelThread
			} else {
				// Start a new thread
				<%=subTree.getName() %>_ParallelThread pt = new <%=subTree.getName()%>_ParallelThread(
						globalMap, (Object[]) globalMap
								.get("PARALLEL_FLOW_LOCK"));
				pt.putBuffer(buffer);
				pool.execThread(pt);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
<%
	}else{
%>

<%
	// Calls for RUN BEFORE links
	for (String before : subTree.getBeforeSubProcesses()) {
%>
		<%=before %>Process(globalMap);
<%
	}
	
	if (subTree.getRootNode().getProcess().getNodesOfType("tFlowMeterCatcher").size() > 0 
		&& subTree.getRootNode().getProcess().getNodesOfType("tFlowMeter").size() >0 ) {
		List<INode> metterCatchers = (List<INode>)subTree.getRootNode().getProcess().getNodesOfType("tFlowMeterCatcher");
		List<INode> metters = (List<INode>)subTree.getRootNode().getProcess().getNodesOfType("tFlowMeter");
		List<INode> nodes = (List<INode>)subTree.getNodes();
		
		boolean hasMetterProcess = false;
		for(INode tmp : nodes)
		{
			for(INode metter : metters)
			{
				if(tmp.getUniqueName().equals(metter.getUniqueName()))
				{
					hasMetterProcess = true;
					break;
				}
			}
			if(hasMetterProcess)
			{
				break;
			}
		}
		if(hasMetterProcess)
		{
			for (INode metterCatcher : metterCatchers) {
				
%>
	<%=metterCatcher.getDesignSubjobStartNode().getUniqueName() %>Process(globalMap);
<%      

			}
		}
	}
%>

	
	} catch(Exception e) {
	
<%
	if(isRunInMultiThread){
%>
	throw new TalendException(this, e, currentComponent, globalMap);
<%
	}else{
%>	
		throw new TalendException(this, e, globalMap);
<%
	}
%>		
	}
	
<%
	//generate the code to free memory for lookup link and virtual component buffered datas 
	boolean firstIn = true;
	boolean needGc = false;
	List<INode> nodes = subTree.getNodes();
	for(INode node:nodes){
	
	boolean isVirtualGenerateNode = node.isVirtualGenerateNode();
	
	//check the virtual component generate node
	if(isVirtualGenerateNode){
		String origin  = ElementParameterParser.getValue(node, "__ORIGIN__");
		if(origin != null && !"".equals(origin)){
			if(!needGc) needGc = true;
	%>
				<%if(firstIn){%> finally{ <% firstIn = false;}%>
				//free memory for "<%=node.getUniqueName() %>"
				globalMap.put("<%=origin %>", null);
	<%
		}
	}else{
	//check the Lookup link
		List<? extends IConnection> lookupInput = node.getIncomingConnections(EConnectionType.FLOW_REF);
		if(lookupInput!=null && lookupInput.size()>0){
			if(!needGc) needGc = true;
			//check the tMap like this, instanceof can't work			
			if(node.getClass().getName().equals("org.talend.designer.mapper.MapperComponent")){
				for(IConnection connection:lookupInput){						
     %>
     			<%if(firstIn){%> finally{ <% firstIn = false;}%>
     			//free memory for "<%=node.getUniqueName() %>"
     			globalMap.put("tHash_Lookup_<%=connection.getName() %>", null); 
     <%
            	}
            }else{
            	for(IConnection connection:lookupInput){
      %>      	
      			<%if(firstIn){%> finally{ <% firstIn = false;}%>
      			//free memory for "<%=node.getUniqueName() %>"
				globalMap.put("tHash_<%=connection.getName() %>", null);
      <%      		 
				} 
			} 
		}
	}
}

	if(needGc) {
	%>		
				System.gc();
		}		
	<%
	}
}//isParallelize
	%>
	
	globalMap.put("<%=subTree.getName() %>_SUBPROCESS_STATE", 1);
}
<% if (subTree.isMethodSizeNeeded()){ %>
/**
 * End of Function: <%=subTree.getName() %>Process 
 */
 <% } %>