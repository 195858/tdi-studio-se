<%@ jet 
	package="org.talend.designer.codegen.translators" 
	imports="
		org.talend.core.model.process.IProcess
		org.talend.core.model.process.INode 
		org.talend.core.model.process.IConnection 
		org.talend.core.model.process.EConnectionType
		org.talend.core.model.process.ElementParameterParser
		org.talend.designer.codegen.config.CodeGeneratorArgument
		org.talend.designer.codegen.temp.CodeGeneratorRoutine
		java.util.List
		java.util.Vector
	"
	class="Header" 
%>
<%
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
    Vector v = (Vector) codeGenArgument.getArgument();
	IProcess process = (IProcess)v.get(0);
    String version = (String)v.get(1);
	
	List< ? extends INode> processNodes = (List< ? extends INode>)process.getGeneratingNodes();
	boolean stats = codeGenArgument.isStatistics();
	boolean trace = codeGenArgument.isTrace();
%>
// ============================================================================
//
// Copyright (c) 2005-2006, Talend SA
// 
// This source code has been automatically generated by talend
// OpenStudio / ProcessDesigner (CodeGenerator version <%=version %>).
// You can find more information about talend products at www.talend.com.
// You may distribute this code under the terms of either the GNU General
// Public License or under the Artistic License just like Perl itself.
//
// ============================================================================
<%
  String packageName = codeGenArgument.getCurrentProjectName().toLowerCase() + "." + codeGenArgument.getJobName().toLowerCase();
%> 
package <%= packageName %>;

<%
    if (stats) {
%>
// PTODO MHIRT stats
//use talend::runstat;
<%
    }
%>
<%
    if (trace) {
%>
// PTODO MHIRT trace
// use talend::trace;
<%
    }
%>
<%for (String routine : CodeGeneratorRoutine.getRoutineName()) {%>
//PTODO MHIRT Routines
//use <%=routine%>;
<%}%>

import java.util.Date;

/**
 * <%=process.getName() %> <%=ElementParameterParser.getValue(process, "__PURPOSE__") %>
 * <%=ElementParameterParser.getValue(process, "__DESCRIPTION__") %> 
 * @author <%=ElementParameterParser.getValue(process, "__AUTHOR__") %>
 * @version <%=ElementParameterParser.getValue(process, "__VERSION__") %>
 * @status <%=ElementParameterParser.getValue(process, "__STATUS__") %> 
 */
 public class <%=process.getName() %> {

	// WHILE WAITING FOR ROUTINES
    private static class StringUtils {
        public static String[] split(String str, String separator) {
            return str.split(separator);
        }
        public static char convertchar(String s) {
            return (s != null) ? s.charAt(0) : null;
        }
        public static Character convertCharacter(String s) {
            return (s != null) ? s.charAt(0) : null;
        }
        public static boolean convertboolean(String s) {
            return Boolean.parseBoolean(s);
        }
        public static Boolean convertBoolean(String s) {
            return Boolean.parseBoolean(s);
        }
        public static java.util.Date convertDate(String s) {
            // PTODO MHIRT Convert Date
            return java.util.Calendar.getInstance().getTime();
        }
        public static Double convertDouble(String s) {
            return Double.parseDouble(s);
        }
        public static double convertdouble(String s) {
            return Double.parseDouble(s);
        }
        public static float convertfloat(String s) {
            return Float.parseFloat(s);
        }
        public static Float convertFloat(String s) {
            return Float.parseFloat(s);
        }
        public static int convertint(String s) {
            return Integer.parseInt(s);
        }
        public static Integer convertInteger(String s) {
            return Integer.parseInt(s);
        }
        public static long convertlong(String s) {
            return Long.parseLong(s);
        }
        public static Long convertLong(String s) {
            return Long.parseLong(s);
        }
        public static String convertString(String s) {
            return s;
        }
    }
    
    
    // create and load default properties
	private static java.util.Properties defaultProps = new java.util.Properties();
	// create application properties with default
	private static java.util.Properties context = null;
	
	

	private static final String jobName = "<%=codeGenArgument.getJobName() %>";
	private static String currentComponent = "";
	private static final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>(); 
private static final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
private static final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
private static final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();

<%
    if (stats) {
%>
private static RunStat runStat = new RunStat();
<%
    }
%>
<%
    if (trace) {
%>
private static RunTrace runTrace = new RunTrace();
<%
    }
%>

private class TalendException extends Exception {
	private Exception e = null;
	private <%=process.getName() %> c = null;
	
	private TalendException(<%=process.getName() %> c, Exception e) {
		this.e = e;
		this.c = c;
	}
	
	@Override
	public void printStackTrace() {
		System.err.println("Exception in component " + currentComponent);
		e.printStackTrace();
		try {
			for (java.lang.reflect.Method m : this.getClass().getEnclosingClass().getMethods()) {
				if (m.getName().compareTo(currentComponent + "_error") == 0) {
					m.invoke(c, (Object[])null);
				}
			}
		} catch (java.lang.SecurityException e) {
			this.e.printStackTrace();
		} catch (java.lang.IllegalArgumentException e) {
			this.e.printStackTrace();
		} catch (java.lang.IllegalAccessException e) {
			this.e.printStackTrace();
		} catch (java.lang.reflect.InvocationTargetException e) {
			this.e.printStackTrace();
		}
	}
}

<% // Methods for RUN IF Error links %>
<%
	for (INode node : processNodes) {
		if (node.isActivate()) {
%>
public void <%=node.getUniqueName() %>_error() {
<%
		List< ? extends IConnection> conns = node.getOutgoingConnections();
    	for (IConnection conn : conns) {
       		if (conn.getLineStyle().equals(EConnectionType.RUN_IF_ERROR)) {
%>
	try {
    	<%=conn.getTarget().getUniqueName() %>Process();
    } catch (Exception e) {
    	e.printStackTrace();
    }
<%
                }
	}
%>
}
<%
		}
	}
%>
