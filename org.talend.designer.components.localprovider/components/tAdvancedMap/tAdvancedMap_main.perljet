<%@ jet 
    imports="
    java.util.ArrayList
    java.util.Collections
    java.util.Comparator
    java.util.List
    java.util.HashMap
    java.util.Map
    java.util.HashSet
    java.util.Set
    org.talend.designer.codegen.config.CodeGeneratorArgument

    org.talend.designer.mapper.MapperMain
    org.talend.designer.mapper.MapperComponent
    org.talend.designer.mapper.external.data.ExternalMapperData
    org.talend.designer.mapper.external.data.ExternalMapperTable
    org.talend.designer.mapper.external.data.ExternalMapperTableEntry
    org.talend.designer.mapper.language.ILanguage
    org.talend.designer.mapper.language.generation.PerlGenerationManager
    org.talend.designer.mapper.language.LanguageProvider
    org.talend.designer.mapper.model.tableentry.TableEntryLocation
    org.talend.designer.mapper.utils.DataMapExpressionParser
    org.talend.core.model.process.IConnection
    org.talend.core.model.process.EConnectionType
    org.talend.designer.mapper.language.generation.TableType
    org.talend.core.model.metadata.IMetadataTable
    org.talend.core.model.metadata.IMetadataColumn
    org.talend.core.model.process.BlockCode
    org.talend.core.model.process.IHashableInputConnections
    org.talend.core.model.process.IHashConfiguration
    org.talend.core.model.process.IHashableColumn
    org.talend.core.model.process.IMatchingMode
    " 
%>
<%


    CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
    MapperComponent node = (MapperComponent) codeGenArgument.getArgument();

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        ILanguage currentLanguage = LanguageProvider.getPerlLanguage();
        List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();
        List<IConnection> outputConnections = (List<IConnection>) node.getOutgoingConnections();
        ExternalMapperData data = (ExternalMapperData) node.getExternalData();
        String uniqueNameComponent = node.getUniqueName();

        String cr = "\n";
        String rejected = "rejected_" + uniqueNameComponent;
        String rejectedInnerJoin = "rejectedInnerJoin_" + uniqueNameComponent;

        List<ExternalMapperTable> inputTables = data.getInputTables();
        List<ExternalMapperTable> varsTables = data.getVarsTables();
        List<ExternalMapperTable> outputTables = data.getOutputTables();

        int indent = 1;

        DataMapExpressionParser expressionParser = new DataMapExpressionParser(currentLanguage);

        PerlGenerationManager gm = (PerlGenerationManager) node.getGenerationManager();

        StringBuilder sb = new StringBuilder();

        gm.setInputTables(inputTables);
        gm.setVarsTables(varsTables);

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // INPUTS : initialization of input arrays from expressions keys and hashes
        // 
        sb.append(cr + gm.indent(indent));
        sb.append(cr + gm.indent(indent) + "###############################");
        sb.append(cr + gm.indent(indent) + "# Input tables (lookups)");

        HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
        for (IConnection connection : inputConnections) {
            hNameToConnection.put(connection.getName(), connection);
        }

        ArrayList<ExternalMapperTable> inputTablesWithInnerJoin = new ArrayList<ExternalMapperTable>();
        ArrayList<ExternalMapperTable> lookupTables = new ArrayList<ExternalMapperTable>();
        Set<ExternalMapperTable> validLookupTables = new HashSet<ExternalMapperTable>();

          int closeBracketCounter = 0;
        %>
    $<%= rejectedInnerJoin %> = false;
                                                                  
        <%

        HashMap<String, ExternalMapperTableEntry> hExternalInputTableEntries = new HashMap<String, ExternalMapperTableEntry>();
        boolean isFirst = true ;
        for (ExternalMapperTable externalTable : inputTables) {
            String tableName = externalTable.getName();
            IConnection connection = hNameToConnection.get(tableName);
            if (connection == null) {
                continue;
            }
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
            
                           if(externalTable.isActivateExpressionFilter() && externalTable.getExpressionFilter() != null && !externalTable.getExpressionFilter().trim().equals("")) { 
                                   String expressionFilter = externalTable.getExpressionFilter();
					               String expressionFilterWithPrefixs = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, expressionFilter, expressionParser,
		           			          new TableType[] { TableType.INPUT });
                           
                             %>
                               if(
                                         !(<%= expressionFilterWithPrefixs%>)
                                      ) {
                                        next;
                                   }
                              
                              <%
                          }
                  continue;
                  
            } else if (connectionType == EConnectionType.FLOW_REF) {

                IMetadataTable metadataTable = connection.getMetadataTable();
                if (externalTable != null) {
                    if (externalTable.isInnerJoin()) {
                        inputTablesWithInnerJoin.add(externalTable);
                    }
                    hExternalInputTableEntries.clear();
                    List<ExternalMapperTableEntry> metadataTableEntries = externalTable.getMetadataTableEntries();
                    if (metadataTableEntries == null) {
                        continue;
                    }
                    for (ExternalMapperTableEntry externalTableEntry : metadataTableEntries) {
                        hExternalInputTableEntries.put(externalTableEntry.getName(), externalTableEntry);
                    }
                    List<IMetadataColumn> listColumns = metadataTable.getListColumns();
                    ArrayList<String> keysValues = new ArrayList<String>();
                    for (IMetadataColumn column : listColumns) {
                        String columnName = column.getLabel();
                        ExternalMapperTableEntry externalInputTableEntry = hExternalInputTableEntries.get(columnName);
                        if (externalInputTableEntry != null) {
                            String expressionKey = externalInputTableEntry.getExpression();
                            if (expressionKey != null && !"".equals(expressionKey.trim())) {
                                String outputExpressionKeyToWrite = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, expressionKey,
                                        expressionParser, new TableType[] { TableType.INPUT });

                                keysValues.add(outputExpressionKeyToWrite);
                            }
                        }
                    }
                    String[] aKeysValues = keysValues.toArray(new String[0]);

                    validLookupTables.add(externalTable);

                       %><%= sb.toString()%><%

                    IHashConfiguration hashConfiguration = node.getHashConfiguration(tableName);
                    List<IHashableColumn> hashableColumns = null;
                    IMatchingMode matchingMode = null;
                    if(hashConfiguration == null) {
                        hashableColumns = new ArrayList<IHashableColumn>(0);
                    } else {
                        hashableColumns = hashConfiguration.getHashableColumns();
                        matchingMode = hashConfiguration.getMatchingMode();
                    }
                    String matchingModeStr = null;
                    if(matchingMode == null) {
                        if(hashableColumns.size() > 0) {
                            matchingModeStr = "UNIQUE_MATCH";
                        } else {
                            matchingModeStr = "ALL_ROWS";
                        }
                    } else {
                        matchingModeStr = matchingMode.toString();
                    }
                       
                    StringBuffer keys = new StringBuffer();
                    
                    keys.append("join( $;, ");
                    for(int i = 0; i < aKeysValues.length ; i++) {
                       keys.append(aKeysValues[i]);
                       keys.append(", ");
                    }
                    keys.append(" ) ");

                    sb = new StringBuilder();
                    %>
    $ref_<%= tableName %>_ArrayFromLookup = $tHash_Lookup_<%= tableName %>->{ <%= keys %> };
    $forceLoop<%= tableName %> = false;

                    <%
                    if(matchingModeStr.equals("ALL_ROWS") ||matchingModeStr.equals("ALL_MATCHES")){
                    %>                                             
    $size<%= tableName %>ArrayFromLookup = scalar( @$ref_<%= tableName %>_ArrayFromLookup );
                    <%
                    }
                    else {
                    %>
    $size<%= tableName %>ArrayFromLookup = exists $tHash_Lookup_<%= tableName %>->{ <%= keys %> } ;
                    <%
                    }
                    if( !matchingModeStr.equals("ALL_ROWS")) { // UNIQUE_MATCH, ALL_MATCHES, FIRST_MATCH, LAST_MATCH
                    %>
    # <%= matchingModeStr %>
    if(!$<%= rejectedInnerJoin %>)
    { # 20
        unless(exists $tHash_Lookup_<%= tableName %>->{ <%= keys %> }) {
        <%
        if(externalTable.isInnerJoin()) {
        %>
        $<%= rejectedInnerJoin %> = true;
        <%
        }
        %>
            $forceLoop<%= tableName %> = true;
        }
    } # 20
    else { # 21
        $forceLoop<%= tableName %> = true;
    } # 21 
                    <%
                    } // 1 
                    else { // ALL_ROWS
                              %>
    # <%= matchingModeStr %>
    $hasAtLeastOneValidLookup_<%= tableName %> = false;
                                       
    if(!$<%= rejectedInnerJoin %>)
    { # 35
                                           
        if(@$ref_<%= tableName %>_ArrayFromLookup == 0) {
                                   <%
                                   if(externalTable.isInnerJoin()) {
                                   %>
        $<%= rejectedInnerJoin %> = true;
                                   <%
                                   }
                                   %>
        $forceLoop<%= tableName %> = true;
        }
    } # 35
    else { # 36
        $forceLoop<%= tableName %> = true;
        if("<%= matchingModeStr %>" eq "ALL_ROWS"){
            $ref_<%= tableName %>_ArrayFromLookup = $tHash_Lookup_<%= tableName %>->{ <%= keys %> };
        }
    } # 36
                    <%
                    } // 2
                    %>
    for(
        $i<%= tableName %> = 0 ;
        <%if (!isFirst) {%> 
        !$<%= rejectedInnerJoin %> &&
        <%} else { isFirst = false ; } %> 
        $i<%= tableName %> < $size<%= tableName %>ArrayFromLookup 
        || $forceLoop<%= tableName %> ;
        $i<%= tableName %>++) {
                    <%
                    gm.addBlocksCodeToClose(new BlockCode("close loop of lookup '" + tableName +"'"));
                    %>
        my @<%= tableName %> = ();
                                             
        if( (!$forceLoop<%= tableName %> ) or ( "<%= matchingModeStr %>" eq "ALL_ROWS" ) ) { # 46

                    <%
                    if(matchingModeStr.equals("ALL_ROWS") ||matchingModeStr.equals("ALL_MATCHES")){
                    %>                                             
            $ref_<%= tableName %>FromLookup = $ref_<%= tableName %>_ArrayFromLookup->[$i<%= tableName %>];
                    <%
                    }
                    else {
                    %>                                             
            $ref_<%= tableName %>FromLookup = $ref_<%= tableName %>_ArrayFromLookup ;
                    <%
                    }
                    %>                                             
            @<%= tableName %> = @$ref_<%= tableName %>FromLookup;
                                               <%
                                                   String expressionFilter = externalTable.getExpressionFilter();
                                               if(
                                                       externalTable.isActivateExpressionFilter() 
                                                       && expressionFilter != null 
                                                       && !expressionFilter.trim().equals("")
                                               ) { // 12 

								               String expressionFilterWithPrefixs = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, expressionFilter, expressionParser,
		    			       			          new TableType[] { TableType.INPUT});

                                               %>
            if( !$<%= rejectedInnerJoin %> && !(<%= expressionFilterWithPrefixs%>)) { # 16
                                                          <%
                                                          if(externalTable.isInnerJoin() && aKeysValues.length > 0) {
                                                          %>
                $<%= rejectedInnerJoin %> = true;
                                                        <%
                                                          } else if(!externalTable.isInnerJoin() && aKeysValues.length > 0){
                                                        %>                                                      
                @<%= tableName %> = ();    
                                                          <%
                                                          } else if(externalTable.isInnerJoin() && aKeysValues.length == 0){
                                                          %>
                if( $i<%= tableName %> == size<%= tableName %>ArrayFromLookup - 1 
                && !$hasAtLeastOneValidLookup_<%= tableName %>) 
                { # 15
                    $<%= rejectedInnerJoin %> = true;
                } # 15
                                                            <%
                                                          }
                                                          %>
        } # 16
                                                  <%
                                                 if(aKeysValues.length == 0){
                                                  %>
                if(@$ref_<%= tableName %>FromLookup == 0 && !$<%= rejectedInnerJoin %>) 
                { # 17
                    next;
                } # 17
                                                 <%
                                                       if(externalTable.isInnerJoin()) {
                                                 %>
                # 17
                else if(!$<%= rejectedInnerJoin %>)
                { # 18
                    $hasAtLeastOneValidLookup_<%= tableName %> = true;
                } # 18
                                                 <%
                                                 }
                                                 %>    
                                                  <%
                                                  }
                                                  %>
                                             <%
                                             } // 12
                                          %>    
        } # 46
    
        $forceLoop<%= tableName %> = false;
                                      
                                          <%

                } // if(externalTable != null) {
            } // else if(connectionType == EConnectionType.FLOW_REF) {
        } // for (ExternalMapperTable externalTable : inputTables) {
        boolean atLeastOneInputTableWithInnerJoin = !inputTablesWithInnerJoin.isEmpty();

        sb.append(cr + gm.indent(indent) + "###############################");
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // VARIABLES
        // 
        sb.append(cr + gm.indent(indent));
        sb.append(cr + gm.indent(indent) + "###############################");
        sb.append(cr + gm.indent(indent) + "# Vars tables");
        for (ExternalMapperTable varsTable : varsTables) {
            List<ExternalMapperTableEntry> varsTableEntries = varsTable.getMetadataTableEntries();
            if (varsTableEntries == null) {
                continue;
            }
            if (varsTableEntries.size() > 0) {
                sb.append(cr + gm.indent(indent) + gm.buildNewArrayDeclaration(uniqueNameComponent, varsTable.getName(), indent));
            }
            String varsTableName = varsTable.getName();
            for (ExternalMapperTableEntry varsTableEntry : varsTableEntries) {
                String varsColumnName = varsTableEntry.getName();
                String varExpression = varsTableEntry.getExpression();
                if (varExpression == null || varExpression.trim().length() == 0) {
                    continue;
                }
                
                String varExpressionWithPrefixs = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, varExpression, expressionParser,
                      new TableType[] { TableType.INPUT, TableType.VARS });
                
                sb.append(cr + gm.indent(indent) + gm.getGeneratedCodeTableColumnVariable(uniqueNameComponent, varsTableName, varsColumnName, true) + " = "
                        + varExpressionWithPrefixs + ";");

            }
        }
        sb.append(cr + gm.indent(indent) + "###############################");
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // OUTPUTS
        // 
        sb.append(cr + gm.indent(indent));
        sb.append(cr + gm.indent(indent) + "###############################");
        sb.append(cr + gm.indent(indent) + "# Output tables");

        ArrayList<ExternalMapperTable> outputTablesSortedByReject = new ArrayList<ExternalMapperTable>(outputTables);
        // sorting outputs : rejects tables after not rejects table
        Collections.sort(outputTablesSortedByReject, new Comparator<ExternalMapperTable>() {

            public int compare(ExternalMapperTable o1, ExternalMapperTable o2) {
                if (o1.isReject() != o2.isReject()) {
                    if (o1.isReject()) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                if (o1.isRejectInnerJoin() != o2.isRejectInnerJoin()) {
                    if (o1.isRejectInnerJoin()) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                return 0;
            }

        });

        boolean lastValueReject = false;
        boolean oneFilterForNotRejectTable = false;
        boolean allNotRejectTablesHaveFilter = true;
        boolean atLeastOneReject = false;
        boolean atLeastOneRejectInnerJoin = false;
        boolean closeTestInnerJoinConditionsBracket = false;

        Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
        for (IConnection outputConnection : outputConnections) {
            nameToOutputConnection.put(outputConnection.getName(), outputConnection);
        }

        int lstSizeOutputs = outputTablesSortedByReject.size();
        // ///////////////////////////////////////////////////////////////////
        // init of allNotRejectTablesHaveFilter and atLeastOneReject
        for (int i = 0; i < lstSizeOutputs; i++) {
            ExternalMapperTable outputTable = (ExternalMapperTable) outputTablesSortedByReject.get(i);
            
            String outputTableName = outputTable.getName();

            sb.append(cr + gm.indent(indent) + "$branch_" + outputTableName + "_is_active = false;");
            
            if (outputTable.isRejectInnerJoin()) {
                atLeastOneRejectInnerJoin = true;
            }
            List<ExternalMapperTableEntry> columnsEntries = outputTable.getMetadataTableEntries();
            List<ExternalMapperTableEntry> filters = outputTable.getConstraintTableEntries();
            boolean hasFilter = filters != null && filters.size() > 0 && !gm.checkFiltersAreEmpty(outputTable) 
                || outputTable.isActivateExpressionFilter() && outputTable.getExpressionFilter() != null && !outputTable.getExpressionFilter().trim().equals("");
            if (columnsEntries != null && columnsEntries.size() > 0) {
                if (!hasFilter && !(outputTable.isReject() || outputTable.isRejectInnerJoin())) {
                    allNotRejectTablesHaveFilter = false;
                }
                if (outputTable.isReject()) {
                    atLeastOneReject = true;
                }
            }

            if (nameToOutputConnection.get(outputTableName) != null) {
                sb.append(cr + gm.indent(indent) + "@" +  outputTableName + " = ();");
            }
        }
        // ///////////////////////////////////////////////////////////////////

        if (allNotRejectTablesHaveFilter && atLeastOneReject) {
            // write $oneNotRejectFilterValidated = false;
            sb.append(cr + gm.indent(indent) + "my $" + rejected + " = true;");
        }
        if (atLeastOneInputTableWithInnerJoin && atLeastOneRejectInnerJoin) {
            // write $oneNotRejectFilterValidated = false;
            //sb.append(cr + gm.indent(indent) + "$" + rejectedInnerJoin + " = true;");
        }

        // write outputs arrays initialization with empty list for NOT reject tables
        for (int indexReject = 0; indexReject < lstSizeOutputs; indexReject++) {
            ExternalMapperTable outputNormalTable = (ExternalMapperTable) outputTablesSortedByReject.get(indexReject);
            if (outputNormalTable.isReject() || outputNormalTable.isRejectInnerJoin()) {
                break;
            }
            List<ExternalMapperTableEntry> metadataTableEntries = outputNormalTable.getMetadataTableEntries();
            if (metadataTableEntries != null && metadataTableEntries.size() > 0) {
                sb.append(cr + gm.indent(indent) + "# Output table: '" + outputNormalTable.getName() + "'");
                sb.append(cr + gm.indent(indent) + gm.buildNewArrayDeclaration(outputNormalTable.getName(), indent));
            }
        }

        // write conditions for inner join reject
        if (inputTablesWithInnerJoin.size() > 0 && lstSizeOutputs > 0) {
            sb.append(cr + gm.indent(indent) + "if( !$");
            sb.append(rejectedInnerJoin);
            sb.append(" ) {");
            closeTestInnerJoinConditionsBracket = true;
            indent++;
            if (atLeastOneInputTableWithInnerJoin && atLeastOneRejectInnerJoin) {
                sb.append(cr + gm.indent(indent) + "$" + rejectedInnerJoin + " = false;");
            }
        }

        // ///////////////////////////////////////////////////////////////////
        // run through output tables list for generating intilization of outputs arrays
        for (int indexCurrentTable = 0; indexCurrentTable < lstSizeOutputs; indexCurrentTable++) {
            ExternalMapperTable outputTable = (ExternalMapperTable) outputTablesSortedByReject.get(indexCurrentTable);
            List<ExternalMapperTableEntry> outputTableEntries = outputTable.getMetadataTableEntries();
            String outputTableName = outputTable.getName();
            boolean connectionExists = true;
            if (outputTableEntries == null || nameToOutputConnection.get(outputTableName) == null) {
                connectionExists = false;
            }

            List<ExternalMapperTableEntry> filters = outputTable.getConstraintTableEntries();

            boolean currentIsReject = outputTable.isReject();
            boolean currentIsRejectInnerJoin = outputTable.isRejectInnerJoin();

            boolean hasFilters = filters != null && filters.size() > 0 && !gm.checkFiltersAreEmpty(outputTable);
            boolean hasExpressionFilter = outputTable.isActivateExpressionFilter() && outputTable.getExpressionFilter() != null && !outputTable.getExpressionFilter().trim().equals("");

            boolean rejectValueHasJustChanged = lastValueReject != (currentIsReject || currentIsRejectInnerJoin);

            oneFilterForNotRejectTable = !(currentIsReject || currentIsRejectInnerJoin) && (hasFilters || hasExpressionFilter);

            if (rejectValueHasJustChanged) {

                if (closeTestInnerJoinConditionsBracket) {
                    indent--;
                    sb.append(cr + gm.indent(indent) + "}");
                    if (atLeastOneReject && allNotRejectTablesHaveFilter) {
                        sb.append(" else {");
                        indent++;
                        sb.append(cr + gm.indent(indent) + "$" + rejected + " = false;");
                        indent--;
                        sb.append(cr + gm.indent(indent) + "}");
                    }
                    closeTestInnerJoinConditionsBracket = false;
                }

                // No connection matching and no checking errors
                if (!connectionExists) {
                    continue;
                }
                if (rejectValueHasJustChanged) {
                    sb.append(cr + gm.indent(indent) + "###### START REJECTS ##### ");
                }
                // write outputs arrays initialization with empty list for reject tables
                for (int indexReject = indexCurrentTable; indexReject < lstSizeOutputs; indexReject++) {
                    ExternalMapperTable outputRejectTable = (ExternalMapperTable) outputTablesSortedByReject.get(indexReject);
                    if (outputRejectTable.isReject() || outputRejectTable.isRejectInnerJoin()) {
                        sb.append(cr + gm.indent(indent) + gm.buildNewArrayDeclaration(outputRejectTable.getName(), indent));
                    }
                }
            }

            // write filters conditions and code to execute
            if (!currentIsReject && !currentIsRejectInnerJoin || rejectValueHasJustChanged
                    && oneFilterForNotRejectTable || currentIsReject && allNotRejectTablesHaveFilter 
                    || currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin) {

                boolean closeFilterOrRejectBracket = false;
                if (currentIsReject || currentIsRejectInnerJoin) {
                    sb.append(cr + cr + gm.indent(indent) + "# Output reject table: '" + outputTableName + "'");
                } else {
                    sb.append(cr + cr + gm.indent(indent) + "# Output table: '" + outputTableName + "'");
                }
                if (hasFilters || hasExpressionFilter || currentIsReject || currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin) {
                    sb.append(cr + gm.indent(indent) + "# Filter condition ");
                    sb.append(cr + gm.indent(indent) + "if( ");

                    String rejectedTests = null;
                    if (allNotRejectTablesHaveFilter && atLeastOneReject && currentIsReject && currentIsRejectInnerJoin
                            && atLeastOneInputTableWithInnerJoin) {
                        rejectedTests = "$" + rejected + " || $" + rejectedInnerJoin;
                        if (hasFilters || hasExpressionFilter) {
                            rejectedTests = "(" + rejectedTests + ")";
                        }
                    } else if (allNotRejectTablesHaveFilter && atLeastOneReject && currentIsReject) {
                        rejectedTests = "$" + rejected;
                    } else if (currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin) {
                        rejectedTests = "$" + rejectedInnerJoin;
                    }
                    if (hasFilters && !hasExpressionFilter || hasExpressionFilter) {
                        String filtersConditions = null;
                        if(hasExpressionFilter) {
                               String expressionFilter = outputTable.getExpressionFilter();
				               filtersConditions = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, expressionFilter, expressionParser,
   			       			          new TableType[] { TableType.INPUT, TableType.VARS });
                         } else {
                            filtersConditions = gm.buildConditions(uniqueNameComponent, filters, expressionParser);
                         }
                        if (rejectedTests == null) {
                            sb.append(filtersConditions);
                        } else {
                            sb.append(rejectedTests + " && (" + filtersConditions + ")");
                        }
                    } else {
                        sb.append(rejectedTests);
                    }
                    sb.append(" ) {");
                    indent++;
                    closeFilterOrRejectBracket = true;
                    if (allNotRejectTablesHaveFilter && !(currentIsReject || currentIsRejectInnerJoin) && atLeastOneReject) {
                        sb.append(cr + gm.indent(indent) + "$" + rejected + " = false;");
                    }
                }

                sb.append(cr + gm.indent(indent)  + "$branch_" + outputTableName + "_is_active = true;");

                if (!currentIsReject && !currentIsRejectInnerJoin || currentIsReject || currentIsRejectInnerJoin
                        && atLeastOneInputTableWithInnerJoin) {
                    for (ExternalMapperTableEntry outputTableEntry : outputTableEntries) {
                        String outputColumnName = outputTableEntry.getName();
                        String outputExpression = outputTableEntry.getExpression();
                        if (outputExpression != null && outputExpression.trim().length() != 0) {

                            String outputExpressionToWrite = gm.prefixEntryLocationsForOutputExpression(uniqueNameComponent, outputExpression, expressionParser,
                                    new TableType[] { TableType.INPUT, TableType.VARS });

                            sb.append(cr + gm.indent(indent) + gm.getGeneratedCodeTableColumnVariable(uniqueNameComponent, outputTableName, outputColumnName, false)
                                    + " = " + outputExpressionToWrite + ";");

                        }

                    } // for entries
                }
                if (closeFilterOrRejectBracket) {
                    indent--;
                    sb.append(cr + gm.indent(indent) + "}");
                }

            }
            lastValueReject = currentIsReject || currentIsRejectInnerJoin;

            boolean isLastTable = indexCurrentTable == lstSizeOutputs - 1;
            if (closeTestInnerJoinConditionsBracket && isLastTable) {
                indent--;
                sb.append(cr + gm.indent(indent) + "}");
                closeTestInnerJoinConditionsBracket = false;
            }

        } // for output tables

        sb.append(cr + gm.indent(indent) + "###############################");

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


%>
<%= sb.toString()%>
    
