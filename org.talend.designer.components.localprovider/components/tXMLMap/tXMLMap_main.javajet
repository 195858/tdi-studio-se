<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.eclipse.emf.common.util.EList
			
			org.talend.designer.xmlmap.generation.GenerationManagerFactory
			org.talend.designer.xmlmap.generation.GenerationManager
			org.talend.core.model.process.BlockCode
			
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.utils.NodeUtil
			org.talend.core.model.metadata.IMetadataColumn
            java.util.Map
            java.util.HashMap
            java.util.List
			java.util.HashSet
			java.util.Set
			java.util.Comparator
			java.util.Collections
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
"
skeleton="tXMLMap_java.skeleton"
%>

<%
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	XmlMapComponent node = (XmlMapComponent) codeGenArgument.getArgument();
	GenerationManager gm =  (GenerationManager)node.initGenerationManager();
	String cid = node.getUniqueName();
	XmlMapData xmlMapData=(XmlMapData)ElementParameterParser.getObjectValueXMLTree(node);
	
	EList<InputXmlTree> inputTables = xmlMapData.getInputTrees();
	EList<OutputXmlTree> outputTables = xmlMapData.getOutputTrees();
	EList<VarTable> varTables = xmlMapData.getVarTables();

	String rejectedInnerJoin = "rejectedInnerJoin_" + cid;
	String rejectedDocInnerJoin = "rejectedDocInnerJoin_" + cid;
	String rejected = "rejected_" + cid;
	String mainRowRejected = "mainRowRejected_" + cid;
	boolean isLookup = false;
	boolean isXpathFromLookup = true;
	boolean isExpressionEmpty = true;
	boolean hasOutgoingConnection = false;
	boolean containDocType = false;
	boolean isPlainNode = true;
	boolean isPlainNodeInLookup = false;
	int lookupTableCount = 0;
	boolean hasDocumentGlobal = false;
	
	List<IConnection> outputConnections = (List<IConnection>) node.getOutgoingConnections();
	Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
    for (IConnection connection : outputConnections) {
	  		nameToOutputConnection.put(connection.getName(), connection);
	}
    
	List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();
	HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
	for(IConnection connection : inputConnections){
		 hNameToConnection.put(connection.getName(), connection);
	}
	
	
	HashMap<String, TreeNode> hInputTableNodes = new HashMap<String, TreeNode>();
	int sizeInputTables = inputTables.size();
	InputXmlTree mainInputTable = null;  // the main input table
	
	String mainInputTableName = null;
	IConnection realMainConnection = null;
	java.util.Map<String, String> xpathTypeMap = null;
	String str  = "";
	TreeNode currentMainNode = null;
	boolean findNext = false;

	 String nextLookupName = null;
	 List<IMetadataColumn> nextLookupColumnsKeys = new ArrayList<IMetadataColumn>();
 
	 boolean hasPersistentLookup = false;
	 int indexLastPersistentSortedTable = -1;
	 
	 ArrayList<InputXmlTree> inputTablesWithInnerJoin = new ArrayList<InputXmlTree>();
	if(inputConnections==null || inputConnections.size() < 1) {
		return "";
	}
%>
	  boolean <%= rejectedInnerJoin %> = false;
	  boolean <%= rejectedDocInnerJoin %> = false;
	  boolean <%= mainRowRejected %> = false;
	  
<%
	if(inputTables==null || inputTables.size()==0) return "";
	for(IConnection conn : inputConnections) { // find the input main table
		InputXmlTree inputTable = inputTables.get(0);
		EConnectionType connectionType = conn.getLineStyle();
		if (connectionType == EConnectionType.FLOW_MAIN) {
			if(!inputTable.isLookup()) { // lookup is used to sign it is lookup table
    			mainInputTable = inputTable;
    			break;
			}
		}
	}
	if(mainInputTable != null) {
		MatchXmlTreeExpr matchXmlTreeExpr = null;
		for(OutputXmlTree outputTable : outputTables) {
			String outputTableName = outputTable.getName();
			for(OutputTreeNode outputNode: outputTable.getNodes()) {
				if(("id_Document").equals(outputNode.getType())){
				
%>
		    GenerateDocument_<%=outputTableName %> gen_Doc_<%=outputTableName %>_<%=cid %> = new GenerateDocument_<%=outputTableName %>();
			<%=outputTableName %>_tmp.<%=outputNode.getName()%> = null;
<%
					break;
				} // if(docuemnt)
			}// for(outputNode)
		} // for (outputXMLTree)
%>
<%
	String mainInputName = mainInputTable.getName();
	for(TreeNode tmpNode : mainInputTable.getNodes()){
			boolean isInnerJoin = true;
			currentMainNode = tmpNode;

			if(tmpNode.getType().equals("id_Document")){
				isPlainNode = false;
			}
			
			matchXmlTreeExpr = new MatchXmlTreeExpr(tmpNode, cid);
			if(("id_Document").equals(tmpNode.getType())) { // find the type:document node.
				containDocType = true;
				//find the loop path
				FindNodeUtil findUtil = new FindNodeUtil();
				TreeNode loopNode = findUtil.findLoopPathNode(tmpNode);
				if(loopNode==null){
					stringBuffer.delete(0,stringBuffer.length());
					stringBuffer.append("if(true){throw new Exception(\"Loop element is missing in the input Table:" + mainInputTable.getName() +"!\");}");
					return stringBuffer.toString();
				} else {
					String loopPath = loopNode.getXpath();
					loopPath = loopPath.substring(loopPath.indexOf(":") + 1);
%>
					String xPathLoop_<%=cid %> = "<%=loopPath %>";
<%
				//}
%>
	org.dom4j.Document doc_<%=cid%> = <%=mainInputName %>.<%=tmpNode.getName() %>.getDocument(); 
	nsTool_<%=cid%>.countNSMap(doc_<%=cid%>.getRootElement());
	java.util.HashMap<String,String> xmlNameSpaceMap_<%=cid%> = nsTool_<%=cid%>.xmlNameSpaceMap;
	org.dom4j.XPath x_<%=cid%> = doc_<%=cid%>.createXPath(nsTool_<%=cid%>.addDefaultNSPrefix(xPathLoop_<%=cid %>,xPathLoop_<%=cid %>));  
	x_<%=cid%>.setNamespaceURIs(xmlNameSpaceMap_<%=cid%>);
	
    java.util.List<org.dom4j.tree.AbstractNode> nodeList_<%=cid%> = (java.util.List<org.dom4j.tree.AbstractNode>)x_<%=cid%>.selectNodes(doc_<%=cid%>);	
    String str_<%=cid %> = null;
    org.dom4j.Node node_<%=cid%> = null;
	
	for (org.dom4j.tree.AbstractNode temp_<%=cid%>: nodeList_<%=cid%>) { // G_TXM_M_001
    	nb_line_<%=cid%>++;
    	<%= rejectedDocInnerJoin %> = false;
		<%=mainRowRejected%>=false;
		
    	treeNodeAPI_<%=cid %>.clear();
<%
		// find all these leaf nodes with output connectors in order to get the xpath array
		List<String> resultList = new java.util.ArrayList<String>();
		xpathTypeMap = new java.util.HashMap<String, String>();
		findUtil.findXpathArray(tmpNode, loopNode.getXpath(), resultList, xpathTypeMap);
		for(int i = 0; i< resultList.size(); i++) {
		
			str = resultList.get(i);
		
%>
			org.dom4j.XPath xTmp<%=i%>_<%=cid%> = temp_<%=cid%>.createXPath(nsTool_<%=cid%>.addDefaultNSPrefix("<%=str %>",xPathLoop_<%=cid %>));
		    xTmp<%=i%>_<%=cid%>.setNamespaceURIs(xmlNameSpaceMap_<%=cid%>);
		    Object obj<%=i%>_<%=cid%> = xTmp<%=i%>_<%=cid%>.evaluate(temp_<%=cid%>);
		    if(obj<%=i%>_<%=cid%> instanceof String || obj<%=i%>_<%=cid%> instanceof Number){
		    	str_<%=cid %> = String.valueOf(obj<%=i%>_<%=cid%>);
		    }else{
		    	node_<%=cid%> = xTmp<%=i%>_<%=cid%>.selectSingleNode(temp_<%=cid%>);
		    	str_<%=cid %> = xTmp<%=i%>_<%=cid%>.valueOf(temp_<%=cid%>);
		    }
		    treeNodeAPI_<%=cid %>.put("<%=xpathTypeMap.get(str) %>", str_<%=cid %>);
<%
		}
		}
		
	   }// if(document)
	}// for()
%>

<%
	//	System.out.println("size of vartable begin:" + varTables.size());
	for (int iInputTable = 0; iInputTable < sizeInputTables; iInputTable++) { 
		InputXmlTree nextInputTable = inputTables.get(iInputTable);
%>

		<%@ include file="tXMLMap_lookup.inc.javajet" %>
<%
	
	if(hasOutgoingConnection)
			lookupTableCount++;
	
	} // end for lookup tables
%>


<%	
 for (OutputXmlTree table : outputTables) {
        EList<OutputTreeNode> tableEntries = table.getNodes();
        if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
            continue;
        }
        String tableName1 = table.getName();
        
        String instanceVarName = tableName1 + "__" + node.getUniqueName();
        String className = tableName1 + "Struct";
%>

<%
for(OutputTreeNode tableEntry : tableEntries) {
%>
<%
	if(("id_Document").equals(tableEntry.getType())){
		String typeToGenerate = JavaTypesManager.getTypeToGenerate(tableEntry.getType(), tableEntry.isNullable());
%>
		////////////////////////////////////////////////////////
<%
	}
}
 }
%>

<%
	if(varTables.size() > 0 ){
%>
	{
<%
	for(VarTable var : varTables) {
		String varsTableName = var.getName();
		String instanceVarName = varsTableName + "__" + cid;
		String className = instanceVarName + "__Struct";
%>			
		<%=className + " " + varsTableName + " = " + instanceVarName + ";" %>
<%
		for(VarNode varNode : var.getNodes()){
			String javaType = varNode.getType();
			String expression = varNode.getExpression();
			String resultExpression = "";
			if(matchXmlTreeExpr != null)
				resultExpression = matchXmlTreeExpr.generateExprCode(expression);
			if(resultExpression!=null && !("").equals(resultExpression)){
%>	
				<%=varsTableName %>.<%=varNode.getName() %> = <%=resultExpression %>;
<%
			}
		}
	}
%>
<%
	}
%>

//###############################
//# Outputs initialization
<%
		boolean isInnerJoinReject = false;
		boolean isOutputReject = false;

//      EList<OutputXmlTree> outputTablesList = new ArrayList<OutputXmlTree>(outputTables);
    // constants
%>
	boolean rejected_<%=cid%> = true;
	boolean alreadyMapped_<%=cid%> = false;
<%

	ArrayList<OutputXmlTree> outputTablesSortedByReject = new ArrayList<OutputXmlTree>(outputTables);
	// sorting outputs : rejects tables after not rejects table
	Collections.sort(outputTablesSortedByReject, new Comparator<OutputXmlTree>() {

		public int compare(OutputXmlTree o1, OutputXmlTree o2) {
			if (o1.isReject() != o2.isReject()) {
				if (o1.isReject()) {
					return 1;
				} else {
					return -1;
				}
			}
			if (o1.isRejectInnerJoin() != o2.isRejectInnerJoin()) {
				if (o1.isRejectInnerJoin()) {
					return 1;
				} else {
					return -1;
				}
			}
			return 0;
		}

	});

    for (OutputXmlTree table : outputTablesSortedByReject) {
        EList<OutputTreeNode> tableEntries = table.getNodes();

        if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
            continue;
        }
        String tableName1 = table.getName();
        isInnerJoinReject = table.isRejectInnerJoin();
		isOutputReject = table.isReject();
        String instanceVarName = tableName1 + "__" + node.getUniqueName();
        String className = tableName1 + "Struct";
%>
	<%= tableName1 %> = null;
	//output table :'<%=tableName1%>'
<%	if(!isXpathFromLookup){%>
<%
		if(!isInnerJoinReject && !isOutputReject) {
%>
				if(!<%=rejectedInnerJoin %>){
<%
		} else if(isInnerJoinReject && !isOutputReject) {
%>
				if(<%=rejectedInnerJoin %> && !alreadyMapped_<%=cid%>){
					rejected_<%=cid%> = false;
<%
		} else if(!isInnerJoinReject && isOutputReject) {
%>
				if(!<%=rejectedInnerJoin%> && rejected_<%=cid%> && !alreadyMapped_<%=cid%>){
<%
		} else if(isInnerJoinReject && isOutputReject) {
%>
				if((<%=rejectedInnerJoin %> || rejected_<%=cid%>) && !alreadyMapped_<%=cid%>){
<%
		}
%>

<%	} else if(isXpathFromLookup && containDocType ){ %>
<%
		if(!isInnerJoinReject && !isOutputReject) {
%>
				if(!<%=rejectedDocInnerJoin %>){
<%
		} else if(isInnerJoinReject && !isOutputReject) {
%>
				if(<%=rejectedDocInnerJoin %> && !alreadyMapped_<%=cid%>){
					rejected_<%=cid%> = false;
<%
		} else if(!isInnerJoinReject && isOutputReject) {
%>
				if(!<%=rejectedDocInnerJoin %> && rejected_<%=cid%> && !alreadyMapped_<%=cid%>){
<%
		} else if(isInnerJoinReject && isOutputReject) {
%>
				if((<%=rejectedDocInnerJoin %> || rejected_<%=cid%>) && !alreadyMapped_<%=cid%>){
<%
		}
%>
<% } %>
<%  if(table.isActivateExpressionFilter() && table.getExpressionFilter() != null && !("").equals(table.getExpressionFilter())){ %>
	if( <%=matchXmlTreeExpr!=null?matchXmlTreeExpr.generateExprCode(table.getExpressionFilter()):false%> ){
		rejected_<%=cid%> = false;
		alreadyMapped_<%=cid%> = true;
<% } %>
<%
	boolean hasDocument = false;
	for(OutputTreeNode tableEntry : tableEntries) {

		if(("id_Document").equals(tableEntry.getType())){
			hasDocument = true;
			hasDocumentGlobal = true;
			String typeToGenerate = JavaTypesManager.getTypeToGenerate(tableEntry.getType(), tableEntry.isNullable());
%>
			gen_Doc_<%=table.getName() %>_<%=cid %>.generateElements(treeNodeAPI_<%=cid %>,<%= rejectedDocInnerJoin %>
		
		<%
		for (InputXmlTree inputTable: inputTables) {
	
		%>, <%=inputTable.getName() %>
		<%
	
		}
		for (VarTable var : varTables) {
			%>, <%=var.getName()%><%
		}
		%>);

			if(<%= tableName1 %>_tmp.<%=tableEntry.getName() %> == null){
				<%= tableName1 %>_tmp.<%=tableEntry.getName() %> = new <%=typeToGenerate %>();
				<%= tableName1 %>_tmp.<%=tableEntry.getName() %>.setDocument(gen_Doc_<%=table.getName() %>_<%=cid %>.getDocument());
			}
			
			<%= tableName1 %>_save = <%= tableName1 %>_tmp;
<%
		} else {
			String resultExpression = "";
			//if(matchXmlTreeExpr != null)
				resultExpression = matchXmlTreeExpr.generateExprCode(tableEntry.getExpression());
		if(resultExpression!=null && !("").equals(resultExpression)){
%>
			
			<%= tableName1 %>_tmp.<%=tableEntry.getName() %> = <%=resultExpression %>;
<%	
		}
	}

%>

<%	
}//for (OutputXmlTree table : outputTablesSortedByReject) {
%>
<%
	if(hasDocument && !isPlainNode) {
%>
		if(nb_line_<%=cid%>>=nodeList_<%=cid%>.size())
<%	
	}
%>
<%= tableName1 %> = <%= tableName1 %>_tmp;
<% if(table.isActivateExpressionFilter() && table.getExpressionFilter() != null && !("").equals(table.getExpressionFilter())){ %>
} else {
	rejected_<%=cid%> = true;
}// close for filter
<% } %>

<%	if(!isXpathFromLookup){%>
} // end for rejection
<% } else if(isXpathFromLookup && containDocType ){%>
} // end for doc rejection
<% } %>
<%
//	System.out.println("size of vartable end:" + varTables.size());
	if(varTables.size() > 0 ){
%>
<%	}
}%>
<%if(hasOutgoingConnection && isExpressionEmpty){
	int i = 0;
	while(i < lookupTableCount){
%>
	} // end for while loop
<%	
	i++;
		} 
	}
%>
}// end var
<%	if(!isXpathFromLookup){%>
	<%=rejectedInnerJoin %> = false;
<% } %>
<%
if((isXpathFromLookup || hasOutgoingConnection) && containDocType && !isPlainNode){%>

<% } %>

<%
	
}// if(maininputtable)
	
//========================the input xml part end=============================
%>
<%
	if((!hasDocumentGlobal && isPlainNode) || (hasDocumentGlobal && isPlainNode)) {
		// Nothing to generate
	}
	
	if((!isPlainNode && !hasDocumentGlobal) || (hasDocumentGlobal && !isPlainNode)) {
		gm.addBlocksCodeToClose(new BlockCode("G_TXM_M_001 close"));
%>
		if(nb_line_<%=cid%> == nodeList_<%=cid%>.size()) {
<%
			boolean flat = true;
			for (OutputXmlTree table : outputTables) {        
				EList<OutputTreeNode> tableEntries = table.getNodes();
				if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
					continue;
				}
				for(OutputTreeNode tableEntry : tableEntries) {
					if(("id_Document").equals(tableEntry.getType())){
						flat = false;
						break;
					}
				}
				
				String tableName1 = table.getName();
            
				String instanceVarName = tableName1 + "__" + node.getUniqueName();
				String className = tableName1 + "Struct";
				if(!flat) {
            
%>
					<%= tableName1 %> = <%= tableName1 %>_save;
<%
				}
			}
%>
		}
<%
	}
%>
