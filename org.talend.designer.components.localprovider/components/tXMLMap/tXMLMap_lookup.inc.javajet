	<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.talend.designer.xmlmap.model.emf.xmlmap.FilterConnection
			org.eclipse.emf.common.util.EList
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.metadata.IMetadataColumn
            java.util.Map
            java.util.HashMap
            java.util.List
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
        
"
skeleton="tXMLMap_java.skeleton"
%>
<%
	EConnectionType connectionType = null;
	if (nextInputTable != null && nextInputTable.isLookup()) { 
			
		IConnection connection =  hNameToConnection.get(nextInputTable.getName());
		if(connection == null){
			continue;
		}else{
			connectionType = connection.getLineStyle();

			if(connectionType == EConnectionType.FLOW_REF) {
				IMetadataTable metadataTable = connection.getMetadataTable();
				String tableName = nextInputTable.getName();
				String lookupMode = nextInputTable.getLookupMode();
				boolean isCacheOrReloadLookupMode = org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.CACHE_OR_RELOAD.name().equals(lookupMode);
				boolean isOneOfReloadLookupMode = isCacheOrReloadLookupMode ||
					   org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.RELOAD.name().equals(lookupMode);
				INode lookupSubProcessStartNode = searchSubProcessStartNode(connection);
			  	String lookupSubProcessStartNodeName = lookupSubProcessStartNode.getUniqueName();
				boolean isInnerJoin = false;
				if (nextInputTable.isInnerJoin()) {
					isInnerJoin = true;
			    	inputTablesWithInnerJoin.add(nextInputTable);
			 	}
			    //  nextJoinedTableNames =tableName+  "__" + tableName; 
			    // System.out.println("nextJoinedTableNames : " + nextJoinedTableNames);
		     
%>
		///////////////////////////////////////////////
		//Starting Lookup Table "<%= nextInputTable %>" 
		///////////////////////////////////////////////
		//tHash_Lookup_<%= tableName %>.initGet();
<%
			String expressionKey = "";
			List<IMetadataColumn> listColumns = metadataTable.getListColumns();
			ArrayList<String> keysNames = new ArrayList<String>();
			ArrayList<String> keysValues = new ArrayList<String>();
			ArrayList<String> keysTypes = new ArrayList<String>();
			EList<TreeNode> externalTreeNodes = nextInputTable.getNodes();
			
			ArrayList<String> expressionKeys = new ArrayList<String>();
			HashMap<String,String> xPathKeysOfLookupTable = new HashMap<String,String>();
			boolean findFromBasicType = false;
			boolean findFromDocumentType = false;
			String documentColumn = "";
			boolean hasOutputFromLookupDoc = false;//to output or another lookup
			ArrayList<String> xPathAsOutput = new ArrayList<String>();//output contain(1.lookup table to output table 2.lookup table to lookup table)
			String loopXPath = "";
			boolean isMultipleResult = false;
			
			boolean existXpathKeyFromCurrentLookup = false;
			for(int j = 0; j < listColumns.size(); j++){
				IMetadataColumn column = listColumns.get(j);
				String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
			    String columnName = column.getLabel();
			    TreeNode  externalInputTableEntry = externalTreeNodes.get(j);
			    if("Document".equals(typeToGenerate)) {
			    	FindNodeUtil findUtil = new FindNodeUtil();
					TreeNode loopNode = findUtil.findLoopPathNode(externalInputTableEntry);
					loopXPath = loopNode.getXpath();
			    }
			    List<TreeNode> allLeaf = new ArrayList<TreeNode>();
			    treeUtil.getAllLeaf(externalInputTableEntry,allLeaf); 
			    for(TreeNode leaf : allLeaf) { 
				    if (leaf != null) {
				    		if("Document".equals(typeToGenerate)) {
				    			documentColumn = columnName;
				    			EList<Connection> outputs = leaf.getOutgoingConnections();
				    			EList<LookupConnection> lookupOutputs = leaf.getLookupOutgoingConnections();
					    		if(outputs!=null && outputs.size()!=0) {
					    			xPathAsOutput.add(leaf.getXpath());
					    			hasOutputFromLookupDoc = true;
					    			hasOutgoingConnection = true;
					    		} else if(lookupOutputs!=null && lookupOutputs.size()!=0) {
					    			xPathAsOutput.add(leaf.getXpath());
					    			hasOutputFromLookupDoc = true;
					    			hasOutgoingConnection = true;
					    		}
				    		}
				    	  	if(leaf.getOutgoingConnections().size() > 0){
						    	hasOutgoingConnection = true;
						    }
				    	  	expressionKey = leaf.getExpression();
							if (expressionKey != null && !"".equals(expressionKey.trim())) {
							    keysNames.add(columnName);
							    String resultExpression = null;
							    expressionKeys.add(expressionKey);
							    if("Document".equals(typeToGenerate)) {
							    	documentColumn = columnName;
							    	findFromDocumentType = true;
							    	xPathKeysOfLookupTable.put(expressionKey,leaf.getXpath());
							    	
							    } else {
							    	findFromBasicType = true;
							    }
							    if(matchXmlTreeExpr != null){
							    	resultExpression = matchXmlTreeExpr.generateExprCode(expressionKey);
							    }
							    if(resultExpression != null && !("").equals(resultExpression)){
							    	keysValues.add(resultExpression);
							    	if(resultExpression.indexOf("/") != -1) {
							    		existXpathKeyFromCurrentLookup = true;
							    	}
							    } else {
							    	keysValues.add(expressionKey);
							    }
							    keysTypes.add(typeToGenerate);
							    boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
							}
	
				    }
				}
			}
			isXpathFromLookup = existXpathKeyFromCurrentLookup;
			String[] aKeysNames = keysNames.toArray(new String[0]);
			String[] aKeysValues = keysValues.toArray(new String[0]);
			String className = tableName + "Struct";
			String matchingMode = nextInputTable.getMatchingMode();
			if(matchingMode == null) {
				if(aKeysValues.length > 0) {
					matchingMode = "UNIQUE_MATCH";
				} else {
					matchingMode = "ALL_ROWS";
				}
			}
			if("ALL_ROWS".equals(matchingMode) || "ALL_MATCHES".equals(matchingMode)) {
				isMultipleResult = true;
			}
%>
		<% if(hasOutgoingConnection){ %>
			boolean forceLoop<%= tableName %> = false;
			<%= className %> <%= tableName %>ObjectFromLookup = null;
		
			
		<%} %>
<%
		if( null != aKeysValues && aKeysValues.length != 0 ){
			isExpressionEmpty = false;
			if(aKeysValues.length > 0) { 
				for (int iKeyName = 0; iKeyName < aKeysNames.length; iKeyName++) {
				   String typeToGenerate = keysTypes.get(iKeyName);
				   boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
				   if("Document".equals(typeToGenerate)) {
%>
					<%= tableName %>HashKey.documentLookupResult.put("<%=xPathKeysOfLookupTable.get(expressionKeys.get(iKeyName))%>",<%=aKeysValues[iKeyName] %>);										  
<%				
				   } else {
%>
				   	 <%= tableName %>HashKey.<%= aKeysNames[iKeyName] %> = <%=aKeysValues[iKeyName] %>;
					 <%= tableName %>HashKey.hashCodeDirty = true;
<%		
				   }
				}// end for aKeysNames
			} 
%>

	<%
		if(hasOutgoingConnection){
	%>
					if(!<%= rejectedInnerJoin %>){
					
					<% if(isOneOfReloadLookupMode) {//TD110
							if(isCacheOrReloadLookupMode) {
								if(findFromBasicType) { %>
								tHash_Lookup_Cache_<%= tableName %>.lookup( <%= tableName %>HashKey );
								<% } else if(findFromDocumentType) { %>
								tHash_Lookup_Cache_<%= tableName %>.lookup();
								<% } %>
	  							if(tHash_Lookup_Cache_<%= tableName %>.hasNext()) {
  									tHash_Lookup_<%= tableName %> = tHash_Lookup_Cache_<%= tableName %>;
	  							} else {
					<%
							}
					%>
								<%= lookupSubProcessStartNodeName %>Process(globalMap);
					<%
							boolean isAllRows = "ALL_ROWS".equals(nextInputTable.getMatchingMode());
				            if(nextInputTable.isPersistent()) {%>
								tHash_Lookup_<%=tableName%> = 
									(org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
										((org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
											 globalMap.get( "tHash_Lookup_<%=tableName%>" ));
							<%
						    } else {
						    %>
								tHash_Lookup_<%=tableName%> = 
								(org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
									((org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
										globalMap.get( "tHash_Lookup_<%=tableName%>" ));
							<%
						    }
						    %>
						    	tHash_Lookup_<%= tableName %>.initGet();
						    	<% if(findFromBasicType) { %>
						    	tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
						    	<% } else if(findFromDocumentType) { %>
						    	tHash_Lookup_<%= tableName %>.lookup();
						    	<% } 
						    if(isCacheOrReloadLookupMode) {
						    %>
						    	}
						    <%	
						    }
						}//TD110
					%>
					
					<% if(!isOneOfReloadLookupMode) {%>
						<%if(findFromBasicType) {%>
							tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
						<% } else if(findFromDocumentType) { %>
							tHash_Lookup_<%= tableName %>.lookup();
						<% } %>
					<% } %>
						if(tHash_Lookup_<%= tableName %>.hasNext()){
						
						} else {
						<% if(isInnerJoin) {//inner join,not find and should reject data(not Document)%>
							<%= rejectedInnerJoin %> = true;
							<%= rejectedDocInnerJoin %> = true;
						<% } else {//left outter join should keep main table data,not reject anytime.%>
							<%=tableName%> = <%=tableName%>Default;
						<% } %>
						}
					}
				   
				  	<% if(findFromDocumentType) {%>
				   	isMatchDocRow<%=cid%> = false;
				  	<% } %>
					while (tHash_Lookup_<%=tableName%>.hasNext()) { 
						<%=tableName%>Struct fromLookup_<%=tableName%> = null;
						<%=tableName%> = <%=tableName%>Default;
						fromLookup_<%=tableName%> = tHash_Lookup_<%=tableName%>.next();
						if (fromLookup_<%=tableName%> != null) {
						<% if(findFromDocumentType || hasOutputFromLookupDoc) {%>
							//begin to lookup Document Object (case 1:lookup doc key exists),(case 2:lookup doc key not exists but lookup line doc output exist)
							Document doc = fromLookup_<%=tableName%>.<%=documentColumn%>;
							java.util.List<String> xPathAsOutput = new java.util.ArrayList<String>();
						<%
						for(String xpath : xPathAsOutput) {
						%>
							xPathAsOutput.add("<%=xpath%>");
						<%
						}
						%>
							List<java.util.Map<String,Object>> result = doc.LookupDocument("<%=loopXPath%>",<%= tableName %>HashKey.documentLookupResult,xPathAsOutput);
							if(result == null || result.size() == 0) {
								// not find
							} else {
								//find and cache it,now only memory,inner join and unique match mode
								//once find,not reject.
								<% if(findFromDocumentType) { %>
								isMatchDocRow<%=cid%> = true;
								<% } %>
								for(java.util.Map<String,Object> docRow : result) {
									for(String path : docRow.keySet()) {
										treeNodeAPI_<%=cid %>.put(path, String.valueOf(docRow.get(path)));
									}
									
								}
								
							}
						<% } %>
							<%=tableName%> = fromLookup_<%=tableName%>;
						}
					}
					<% if(isInnerJoin && findFromDocumentType) {%>
				   	<%= rejectedDocInnerJoin %> = !isMatchDocRow<%=cid%>;
				    <%= rejectedInnerJoin %> = <%= rejectedDocInnerJoin %>;
				  	<% } %>
				  	<% if(!isInnerJoin && findFromDocumentType) { %>
				  	if(!isMatchDocRow<%=cid%>) {
				  		<%=tableName%> = <%=tableName%>Default;
				  	}
				  	<% } %>
				  	<% if(hasOutputFromLookupDoc && !findFromDocumentType) {//for the case : not lookup doc,but doc output exists%>
				  		//do nothing
				  	<% } %>
	<%				
	}
	%>
	<%
			} // end of expression key checking
		else {
	
			isExpressionEmpty = true;
			if(hasOutgoingConnection){
	%>
				if(!<%= rejectedInnerJoin %>){
					tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
					if(tHash_Lookup_<%= tableName %>.hasNext()){
					
					}
				}else {
				
				}
				while (tHash_Lookup_<%=tableName%>.hasNext()) { 
						
					<%=tableName%>Struct fromLookup_<%=tableName%> = null;
					<%=tableName%> = <%=tableName%>Default;
			
					fromLookup_<%=tableName%> = tHash_Lookup_<%=tableName%>.next();
					if (fromLookup_<%=tableName%> != null) {
						<%=tableName%> = fromLookup_<%=tableName%>;
					}
<%					}
				}
			}
		}
	}
%>