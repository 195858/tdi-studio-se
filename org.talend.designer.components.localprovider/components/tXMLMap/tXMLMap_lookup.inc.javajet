	<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.talend.designer.xmlmap.model.emf.xmlmap.FilterConnection
			org.eclipse.emf.common.util.EList
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.metadata.IMetadataColumn
            java.util.Map
            java.util.HashMap
            java.util.List
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
        
"
skeleton="tXMLMap_java.skeleton"
%>
<%
	EConnectionType connectionType = null;
	if (nextInputTable != null && nextInputTable.isLookup()) { 
		IConnection connection =  hNameToConnection.get(nextInputTable.getName());

		if(connection == null){
			continue;
		}else{
			connectionType = connection.getLineStyle();
			
			if(connectionType == EConnectionType.FLOW_REF) {
				IMetadataTable metadataTable = connection.getMetadataTable();
				String tableName = nextInputTable.getName();
				String lookupMode = nextInputTable.getLookupMode();
				boolean isCacheOrReloadLookupMode = org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.CACHE_OR_RELOAD.name().equals(lookupMode);
				boolean isOneOfReloadLookupMode = isCacheOrReloadLookupMode ||
					   org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.RELOAD.name().equals(lookupMode);
				INode lookupSubProcessStartNode = searchSubProcessStartNode(connection);
			  	String lookupSubProcessStartNodeName = lookupSubProcessStartNode.getUniqueName();
				boolean isInnerJoin = false;
				if (nextInputTable.isInnerJoin()) {
					isInnerJoin = true;
			    	inputTablesWithInnerJoin.add(nextInputTable);
			 	}
			    //  nextJoinedTableNames =tableName+  "__" + tableName; 
			    // System.out.println("nextJoinedTableNames : " + nextJoinedTableNames);
				%>
				///////////////////////////////////////////////
				//Starting Lookup Table "<%= nextInputTable %>" 
				///////////////////////////////////////////////
				//tHash_Lookup_<%= tableName %>.initGet();
				<%
				String expressionKey = "";
				List<IMetadataColumn> listColumns = metadataTable.getListColumns();
				ArrayList<String> keysNames = new ArrayList<String>();
				ArrayList<String> keysValues = new ArrayList<String>();
				ArrayList<String> keysTypes = new ArrayList<String>();
				EList<TreeNode> externalTreeNodes = nextInputTable.getNodes();
				
				ArrayList<String> expressionKeys = new ArrayList<String>();
				HashMap<String,String> xPathKeysOfLookupTable = new HashMap<String,String>();
				boolean findFromBasicType = false;
				boolean findFromDocumentType = false;
				String documentColumn = "";
				boolean hasOutputFromLookupDoc = false;//to output or another lookup
				Map<String,String> outNodesXPath = new HashMap<String,String>();//output contain(1.lookup table to output table 2.lookup table to lookup table)
				Map<String,String> lookupInputNodesXPath = new HashMap<String,String>();
				String loopXPath = "";
				boolean isMultipleResult = false;
				boolean existXpathKeyFromCurrentLookup = false;
				boolean hasExpressionKey = false;
				
				for(int j = 0; j < listColumns.size(); j++){
					IMetadataColumn column = listColumns.get(j);
					String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
				    String columnName = column.getLabel();
				    TreeNode  externalInputTableEntry = externalTreeNodes.get(j);
				    XPathHelper xpathHelper;
				    if("Document".equals(typeToGenerate)) {
				    	xpathHelper = new XPathHelper(externalInputTableEntry);
						loopXPath = xpathHelper.getLoopNodeXPath();
						outNodesXPath = xpathHelper.getOutNodesXPath();
						lookupInputNodesXPath = xpathHelper.getLookupInputNodesXPath();
						%>
						java.util.HashMap<String,String> xmlNameSpaceMap_<%=tableName%> = new java.util.HashMap<String,String>();
						<%=xpathHelper.buildNSMapping("xmlNameSpaceMap"+"_"+tableName)%>
				    <%
				    }
				    List<TreeNode> allLeaf = new ArrayList<TreeNode>();
				    treeUtil.getAllLeaf(externalInputTableEntry,allLeaf); 
				    
				    for(TreeNode leaf : allLeaf) { 
					    if (leaf != null) {
				    		if("Document".equals(typeToGenerate)) {
				    			documentColumn = columnName;
				    			EList<Connection> outputs = leaf.getOutgoingConnections();
				    			EList<LookupConnection> lookupOutputs = leaf.getLookupOutgoingConnections();
					    		if(outputs!=null && outputs.size()!=0) {
					    			hasOutputFromLookupDoc = true;
					    			hasOutgoingConnection = true;
					    		} else if(lookupOutputs!=null && lookupOutputs.size()!=0) {
					    			hasOutputFromLookupDoc = true;
					    			hasOutgoingConnection = true;
					    		}
				    		}
				    	  	if(leaf.getOutgoingConnections().size() > 0){
						    	hasOutgoingConnection = true;
						    }
						    if(leaf.getLookupOutgoingConnections().size() > 0) {
						    	hasOutgoingConnection = true;
						    }
						    
				    	  	expressionKey = leaf.getExpression();
							if (expressionKey != null && !"".equals(expressionKey.trim())) {
								hasExpressionKey = true;
							    keysNames.add(columnName);
							    String resultExpression = null;
							    expressionKeys.add(expressionKey);
							    if("Document".equals(typeToGenerate)) {
							    	documentColumn = columnName;
							    	findFromDocumentType = true;
							    	xPathKeysOfLookupTable.put(expressionKey,lookupInputNodesXPath.get(leaf.getXpath()));
							    	
							    } else {
							    	findFromBasicType = true;
							    }
							    if(matchXmlTreeExpr != null){
							    	resultExpression = matchXmlTreeExpr.generateExprCode(expressionKey);
							    }
							    if(resultExpression != null && !("").equals(resultExpression)){
							    	keysValues.add(resultExpression);
							    	if(resultExpression.indexOf("/") != -1) {
							    		existXpathKeyFromCurrentLookup = true;
							    	}
							    } else {
							    	keysValues.add(expressionKey);
							    }
							    keysTypes.add(typeToGenerate);
							    boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
							}
					    }
					}
				}
				
				isXpathFromLookup = existXpathKeyFromCurrentLookup;
				String[] aKeysNames = keysNames.toArray(new String[0]);
				String[] aKeysValues = keysValues.toArray(new String[0]);
				String className = tableName + "Struct";
				
				hasValidLookupTables = true;
				
				String matchingMode = nextInputTable.getMatchingMode();
				if(matchingMode == null) {
					if(aKeysValues.length > 0) {
						matchingMode = "UNIQUE_MATCH";
					} else {
						matchingMode = "ALL_ROWS";
					}
				}
				if("ALL_ROWS".equals(matchingMode) || "ALL_MATCHES".equals(matchingMode)) {
					isMultipleResult = true;
				}
				%>
				
				<%if(hasOutgoingConnection || hasExpressionKey){ %>
					boolean forceLoop<%= tableName %> = false;
					<%= className %> <%= tableName %>ObjectFromLookup = null;
					boolean hasResultFromLookupCache<%= tableName %> = false;
					java.util.Map<String,Object> cacheResult<%=tableName%> = new java.util.HashMap<String,Object>();
				<%} %>
				
				<%
				if( null != aKeysValues && aKeysValues.length != 0 ){
					isExpressionEmpty = false;
					
					if(aKeysValues.length > 0) {//TD114
					 	if(isCacheOrReloadLookupMode) {
			   			%>
			   				List<Object> lookupCacheKey<%=tableName%> = new java.util.ArrayList<Object>();
			   			<%	
			  			} 
						for (int iKeyName = 0; iKeyName < aKeysNames.length; iKeyName++) {
							String typeToGenerate = keysTypes.get(iKeyName);
							boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
				   			if("Document".equals(typeToGenerate)) {
							%>
								<%= tableName %>HashKey.documentLookupResult.put("<%=xPathKeysOfLookupTable.get(expressionKeys.get(iKeyName))%>",<%=aKeysValues[iKeyName] %>);										  
								<%					
								if(isCacheOrReloadLookupMode) {
								%>
									lookupCacheKey<%=tableName%>.add(<%=aKeysValues[iKeyName] %>);
								<%
								}
				   			} else {
							%>
						   	<%= tableName %>HashKey.<%= aKeysNames[iKeyName] %> = <%=aKeysValues[iKeyName] %>;
							<%= tableName %>HashKey.hashCodeDirty = true;
							<%		
					   		}
						}// end for aKeysNames
					}//TD114
					
					if(findFromBasicType && isCacheOrReloadLookupMode) {
					%>
						lookupCacheKey<%=tableName%>.add(<%= tableName %>HashKey);
					<%	
					} 
					%>
					
					<%
					if(hasOutgoingConnection || hasExpressionKey){
					%>
						if(!<%= rejectedInnerJoin %>){//TD120
							<%if(isOneOfReloadLookupMode) {//TD110
								if(isCacheOrReloadLookupMode) {
									if(findFromBasicType) { 
									%>
									tHash_Lookup_Cache_<%= tableName %>.lookup(lookupCacheKey<%=tableName%>);
									<% } else if(findFromDocumentType) { %>
									tHash_Lookup_Cache_<%= tableName %>.lookup(lookupCacheKey<%=tableName%>);
									<% } %>
		  							if(tHash_Lookup_Cache_<%= tableName %>.hasNext()) {
	  									hasResultFromLookupCache<%= tableName %> = true;
		  							} else {
								<%
								}
								%>
									<%= lookupSubProcessStartNodeName %>Process(globalMap);
								<%
								boolean isAllRows = "ALL_ROWS".equals(nextInputTable.getMatchingMode());
					            if(nextInputTable.isPersistent()) {%>
									tHash_Lookup_<%=tableName%> = 
										(org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
											((org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
												 globalMap.get( "tHash_Lookup_<%=tableName%>" ));
								<%
							    } else {
							    %>
									tHash_Lookup_<%=tableName%> = 
									(org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
										((org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
											globalMap.get( "tHash_Lookup_<%=tableName%>" ));
								<%
							    }
							    %>
					    			tHash_Lookup_<%= tableName %>.initGet();
					    		<% if(findFromBasicType) { %>
					    			tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
					    		<% } else if(findFromDocumentType) { %>
					    			tHash_Lookup_<%= tableName %>.lookup();
					    		<% } 
						    	if(isCacheOrReloadLookupMode) {
						    	%>
						    		}
							    <%	
							    }
							}//TD110
							%>
					
							<% if(!isOneOfReloadLookupMode) {%>
								<%if(findFromBasicType) {%>
									tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
								<% } else if(findFromDocumentType) { %>
									tHash_Lookup_<%= tableName %>.lookup();
								<% } %>
							<% } %>
							if(hasResultFromLookupCache<%=tableName %>  || tHash_Lookup_<%= tableName %>.hasNext()){
							
							} else {
								<% if(isInnerJoin) {//inner join,not find and should reject data(not Document)%>
									<%= rejectedInnerJoin %> = true;
									<%= rejectedDocInnerJoin %> = true;
								<% } else {//left outter join should keep main table data,not reject anytime.%>
									<%=tableName%> = <%=tableName%>Default;
								<% } %>
								
								<%if(isMultipleResult) {%>
								forceLoop<%= tableName %> = true;
								<%}%>
							}
						}//TD120
				   
				   		<%if(isMultipleResult) {%>
				   			if(<%= rejectedInnerJoin %>) {
				   				forceLoop<%= tableName %> = true;
				   			}
				   		<% } %>
				   
				   		<%=tableName%>Struct fromLookup_<%=tableName%> = null;
						<%=tableName%> = <%=tableName%>Default;
				   
				   		<% if(!isMultipleResult) {%>
					    if(hasResultFromLookupCache<%= tableName %>) {//TD10086
					    	<%if(isCacheOrReloadLookupMode) {%>
					    	java.util.Map<String,Object> cacheResult_<%=cid%> = tHash_Lookup_Cache_<%= tableName %>.next();
					    		<% for (Object key : outNodesXPath.keySet()) { %>
					    			treeNodeAPI_<%=cid %>.put("<%=key%>",String.valueOf(cacheResult_<%=cid%>.get("<%=key%>")));
					    		<% } %>
				    			<%=tableName%> = (<%=className%>)cacheResult_<%=cid%>.get("<%=tableName%>");
					    	<% } %>
					    } else if(!<%= rejectedInnerJoin %>) {
						  	<% if(findFromDocumentType) {%>
						   	isMatchDocRow<%=cid%> = false;
						  	<% } %>
							while (tHash_Lookup_<%=tableName%>.hasNext()) {//TD119
								fromLookup_<%=tableName%> = null;
								<%=tableName%> = <%=tableName%>Default;
								fromLookup_<%=tableName%> = tHash_Lookup_<%=tableName%>.next();
								if (fromLookup_<%=tableName%> != null) {
								<% if(findFromDocumentType || hasOutputFromLookupDoc) {%>
									//begin to lookup Document Object (case 1:lookup doc key exists),(case 2:lookup doc key not exists but lookup line doc output exist)
									Document lookupDoc_<%=cid%> = fromLookup_<%=tableName%>.<%=documentColumn%>;
									<% if("FIRST_MATCH".equals(matchingMode)) {%>
									boolean quit<%=tableName%> = false;
									<% } %>
									java.util.Map<String,String> xPathAsOutput_<%=cid%> = new java.util.HashMap<String,String>();
								<%
								for (Object key : outNodesXPath.keySet()) { 
									Object val = outNodesXPath.get(key);
								%>
									xPathAsOutput_<%=cid%>.put("<%=key%>","<%=val%>");
								<%
								}
								%>
									List<java.util.Map<String,Object>> result_<%=cid%> = lookupDoc_<%=cid%>.LookupDocument("<%=loopXPath%>",<%= tableName %>HashKey.documentLookupResult,xPathAsOutput_<%=cid%>,xmlNameSpaceMap_<%=tableName%>,"<%=matchingMode%>");
									if(result_<%=cid%> == null || result_<%=cid%>.size() == 0) {
										// not find
									} else {
										//find and cache it,now only memory,inner join and unique match mode
										//once find,not reject.
										<% if(findFromDocumentType) { %>
										isMatchDocRow<%=cid%> = true;
										<% } %>
										for(java.util.Map<String,Object> docRow_<%=cid%> : result_<%=cid%>) {
											for(String path_<%=cid%> : docRow_<%=cid%>.keySet()) {
												treeNodeAPI_<%=cid %>.put(path_<%=cid%>, String.valueOf(docRow_<%=cid%>.get(path_<%=cid%>)));
												<%if(isCacheOrReloadLookupMode) {%>
												cacheResult<%=tableName%>.put(path_<%=cid%>,String.valueOf(docRow_<%=cid%>.get(path_<%=cid%>)));
												<% } %>
											}
										}
										<% if("FIRST_MATCH".equals(matchingMode)) {%>
										quit<%=tableName%> = true;
										<% } %>
									}
								<% } %>
									<%=tableName%> = fromLookup_<%=tableName%>;
									
									<%if(isCacheOrReloadLookupMode) {%>
										<%if(findFromDocumentType) {%>
										if(isMatchDocRow<%=cid%>) {
											cacheResult<%=tableName%>.put("<%=tableName%>",<%=tableName%>);
											tHash_Lookup_Cache_<%= tableName %>.put(lookupCacheKey<%=tableName%>,cacheResult<%=tableName%>); 
										}
										<% } else { %>
										cacheResult<%=tableName%>.put("<%=tableName%>",<%=tableName%>); 
										tHash_Lookup_Cache_<%= tableName %>.put(lookupCacheKey<%=tableName%>,cacheResult<%=tableName%>); 
										<% } %>
									<% } %>
									
									<% if("FIRST_MATCH".equals(matchingMode) && (findFromDocumentType || hasOutputFromLookupDoc)) {%>
										if(quit<%=tableName%>) {//for first match,once find in document,no need to continue to lookup.
											break;
										}
									<% } %>
								}
							}//TD119
							<% if(isInnerJoin && findFromDocumentType) {%>
						   	<%= rejectedDocInnerJoin %> = !isMatchDocRow<%=cid%> && !hasResultFromLookupCache<%= tableName %>;
						    <%= rejectedInnerJoin %> = <%= rejectedDocInnerJoin %>;
						  	<% } %>
						  	<% if(!isInnerJoin && findFromDocumentType) { %>
						  	if(!isMatchDocRow<%=cid%> && !hasResultFromLookupCache<%= tableName %>) {
						  		<%=tableName%> = <%=tableName%>Default;
						  	}
						  	<% } %>
						  	<% if(hasOutputFromLookupDoc && !findFromDocumentType) {//for the case : not lookup doc,but doc output exists%>
						  		//do nothing
						  	<% } %>
				  		}//TD10086
				  		<% } %>
				  		
				  		//////////////////////////////////////////////////////////////////////////////////////////////
				  		<%if(isMultipleResult) {//TD114%>
				  		boolean fromCache<%=tableName%> = hasResultFromLookupCache<%= tableName %>;
				  		List<java.util.Map<String,Object>> multipleResultSet<%=tableName%> = new java.util.ArrayList<java.util.Map<String,Object>>();
				  		//the var for cache the <%=tableName%>Struct
				  		java.util.Map<String,Object> oneRow_<%=tableName%> = null;
						if(hasResultFromLookupCache<%= tableName %>) {
					    	<%if(isCacheOrReloadLookupMode) {%>
					    	java.util.Map<String,Object> cacheResult_<%=cid%> = tHash_Lookup_Cache_<%= tableName %>.next();
					    	multipleResultSet<%=tableName%>.add(cacheResult_<%=cid%>);
					    	<% } %>
					    } else if(!<%= rejectedInnerJoin %>) {
					    	<% if(findFromDocumentType) {%>
						   	isMatchDocRow<%=cid%> = false;
						  	<% } %>
					    	while (tHash_Lookup_<%=tableName%>.hasNext()) {
					    		fromLookup_<%=tableName%> = null;
								<%=tableName%> = <%=tableName%>Default;
								fromLookup_<%=tableName%> = tHash_Lookup_<%=tableName%>.next();
								if(fromLookup_<%=tableName%> != null) {
								<% if(findFromDocumentType || hasOutputFromLookupDoc) {//TA110%>
									Document lookupDoc_<%=cid%> = fromLookup_<%=tableName%>.<%=documentColumn%>;
									java.util.Map<String,String> xPathAsOutput_<%=cid%> = new java.util.HashMap<String,String>();
									<%
									for (Object key : outNodesXPath.keySet()) { 
										Object val = outNodesXPath.get(key);
									%>
										xPathAsOutput_<%=cid%>.put("<%=key%>","<%=val%>");
									<%
									}
									%>
									List<java.util.Map<String,Object>> result_<%=cid%> = lookupDoc_<%=cid%>.LookupDocument("<%=loopXPath%>",<%= tableName %>HashKey.documentLookupResult,xPathAsOutput_<%=cid%>,xmlNameSpaceMap_<%=tableName%>,"<%=matchingMode%>");
									if(result_<%=cid%> == null || result_<%=cid%>.size() == 0) {
										//do nothing
									} else {
										<% if(findFromDocumentType) { %>
										isMatchDocRow<%=cid%> = true;
										<% } %>
										for(java.util.Map<String,Object> docRow_<%=cid%> : result_<%=cid%>) {
											docRow_<%=cid%>.put("<%=tableName%>",fromLookup_<%=tableName%>);
											multipleResultSet<%=tableName%>.add(docRow_<%=cid%>);
											<%if(isCacheOrReloadLookupMode) {%>
											for(String path_<%=cid%> : docRow_<%=cid%>.keySet()) {
												cacheResult<%=tableName%>.put(path_<%=cid%>,String.valueOf(docRow_<%=cid%>.get(path_<%=cid%>)));
											}
											cacheResult<%=tableName%>.put("<%=tableName%>",fromLookup_<%=tableName%>);
											tHash_Lookup_Cache_<%= tableName %>.put(lookupCacheKey<%=tableName%>,cacheResult<%=tableName%>);
											<% } %>
										}
									}
								<% }//TA110 %>
									<%if(!findFromDocumentType){%>	
									<%=tableName%> = fromLookup_<%=tableName%>;
									//construct the resultset for mutiple lookup when no document lookup.
									oneRow_<%=tableName%> = new java.util.HashMap<String, Object>();
									oneRow_<%=tableName%>.put("<%=tableName%>",<%=tableName%>);
									multipleResultSet<%=tableName%>.add(oneRow_<%=tableName%>);
									<%}%>
								}
					    	}//end while
					    	
					    }//end else if
					    //now not support cache all_matches lookup
					    <% if(findFromDocumentType && !isInnerJoin) {%>
					    	forceLoop<%= tableName %> = !isMatchDocRow<%=cid%> && !hasResultFromLookupCache<%= tableName %>;
					    <% } %>
					    java.util.Iterator<java.util.Map<String,Object>> iter<%=tableName%> = multipleResultSet<%=tableName%>.iterator();
					    while(iter<%=tableName%>.hasNext() || forceLoop<%= tableName %>) { // G_TM_M_002
					    	<%=tableName%> = <%=tableName%>Default;
					    	<%=tableName%>Struct tempLookup<%=tableName%> = null; 
					    	if(!forceLoop<%= tableName %>) {
						    	java.util.Map<String,Object> oneRow<%=tableName%> = iter<%=tableName%>.next();
						   		<% for (Object key : outNodesXPath.keySet()) { %>
						    			treeNodeAPI_<%=cid %>.put("<%=key%>",String.valueOf(oneRow<%=tableName%>.get("<%=key%>")));
						    	<% } %>
					    		tempLookup<%=tableName%> = (<%=className%>)oneRow<%=tableName%>.get("<%=tableName%>");
					    		if(tempLookup<%=tableName%>!=null) {
					    			<%=tableName%> = tempLookup<%=tableName%>;
					    		}
				    		}
				    		forceLoop<%= tableName %> = false;
				  		<% 
				  			gm.addBlocksCodeToClose(new BlockCode("close loop of lookup '" + tableName +"' // G_TM_M_002"));
				  		}//TD114 
				  		%>
				  		/////////////////////////////////////////////////////////////////////////////////////////////////
				  		
					<%				
					}
					%>
				<%
				} // end of expression key checking
				else {
	
					isExpressionEmpty = true;
					if(hasOutgoingConnection){
					%>
						if(!<%= rejectedInnerJoin %>){
							tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
							if(tHash_Lookup_<%= tableName %>.hasNext()){
							
							}
						}else {
						
						}
						while (tHash_Lookup_<%=tableName%>.hasNext()) {//TD128 
								
							fromLookup_<%=tableName%> = null;
							<%=tableName%> = <%=tableName%>Default;
					
							fromLookup_<%=tableName%> = tHash_Lookup_<%=tableName%>.next();
							if (fromLookup_<%=tableName%> != null) {

								<%=tableName%> = fromLookup_<%=tableName%>;
							}
					<%
					}
				}
			}
		}
	} else {
		isXpathFromLookup = false;
	}
	%>