	<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.eclipse.emf.common.util.EList
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.metadata.IMetadataColumn
            java.util.Map
            java.util.HashMap
            java.util.List
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
"
skeleton="tXMLMap_java.skeleton"
%>
<%
	EConnectionType connectionType = null;
	for (int iInputTable = 0; iInputTable < sizeInputTables; iInputTable++) { 
		InputXmlTree  nextInputTable = inputTables.get(iInputTable);
		if (nextInputTable != null) { 
			
		IConnection connection =  hNameToConnection.get(nextInputTable.getName());
		if(connection == null){
			continue;
		}else{
			connectionType = connection.getLineStyle();
			if(connectionType == EConnectionType.FLOW_REF) {
			     IMetadataTable metadataTable = connection.getMetadataTable();
				 String tableName = nextInputTable.getName();
				
				 String lookupMode = nextInputTable.getLookupMode();
				 if (nextInputTable.isInnerJoin()) {
			         inputTablesWithInnerJoin.add(nextInputTable);
			     }
			   //  nextJoinedTableNames =tableName+  "__" + tableName; 
			    // System.out.println("nextJoinedTableNames : " + nextJoinedTableNames);
		     
%>
		///////////////////////////////////////////////
		//Starting Lookup Table "<%= nextInputTable %>" 
		///////////////////////////////////////////////
		//tHash_Lookup_<%= tableName %>.initGet();
		<%
			String expressionKey = "";
			List<IMetadataColumn> listColumns = metadataTable.getListColumns();
			ArrayList<String> keysNames = new ArrayList<String>();
			ArrayList<String> keysValues = new ArrayList<String>();
			ArrayList<String> keysTypes = new ArrayList<String>();
			EList<TreeNode> externalTreeNodes = nextInputTable.getNodes();
			for(int j = 0; j < listColumns.size(); j++){
				
				IMetadataColumn column = listColumns.get(j);
			    String columnName = column.getLabel();
			    TreeNode  externalInputTableEntry = externalTreeNodes.get(j);
			    if (externalInputTableEntry != null) {
				     	expressionKey = externalInputTableEntry.getExpression();

						if (expressionKey != null && !"".equals(expressionKey.trim())) {
						    keysNames.add(columnName);
						    String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
						    String resultExpression = null;
						    if(matchXmlTreeExpr != null){
						     resultExpression = matchXmlTreeExpr.generateExprCode(expressionKey);
						    }
						    
						    if(resultExpression != null)
						    	keysValues.add(resultExpression);
						    else
						    	 keysValues.add(expressionKey);
						            
						    keysTypes.add(typeToGenerate);
						    boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
			//			    if(javaPrimitiveKeyColumn) {
			//			         	hasPrimitiveKey = true;
						}
//			       }
//			}
			
			String[] aKeysNames = keysNames.toArray(new String[0]);
			String[] aKeysValues = keysValues.toArray(new String[0]);
			
			String className = tableName + "Struct";
			String matchingMode = nextInputTable.getMatchingMode();
			if(matchingMode == null) {
				if(aKeysValues.length > 0) {
					matchingMode = "UNIQUE_MATCH";
				} else {
					matchingMode = "ALL_ROWS";
				}
			}
			
			%>
			//boolean forceLoop<%= tableName %> = false;
			//<%= className %> <%= tableName %>ObjectFromLookup = null;
	<%
		String xpath = null;

		if(("id_Document").equals(tmpNode.getType())) {
			xpath = "[" + xpathTypeMap.get(str) + "]";
		}else{
			xpath = mainInputName+"."+tmpNode.getName();
			 isLookup = true;
		}
		
			if( null != expressionKey){
			if( xpath.equals(expressionKey.trim())){
				if(("id_Document").equals(tmpNode.getType())) {
					
	%>
			if(!<%= rejectedDocInnerJoin %>){
		<%}else {
		%>
			if(!<%= rejectedInnerJoin %>){
	<%}%>
	
	<% 
			if(aKeysValues.length > 0) { 
				for (int iKeyName = 0; iKeyName < aKeysNames.length; iKeyName++) {
				   String typeToGenerate = keysTypes.get(iKeyName);
				   boolean javaPrimitiveKeyColumn = JavaTypesManager.isJavaPrimitiveType(typeToGenerate);
	%>
					<%= tableName %>HashKey.<%= aKeysNames[iKeyName] %> = <%=aKeysValues[iKeyName] %>;
					<%= tableName %>HashKey.hashCodeDirty = true;
					tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );
	<%	
				}
		}
	%>
			if(!tHash_Lookup_<%= tableName %>.hasNext()) {
				<%if(("id_Document").equals(tmpNode.getType())) {
				%>
				
				<%= rejectedDocInnerJoin %> = true;
				<%} else {
					%>
				<%= rejectedInnerJoin %> = true;
				<%}%>
			}
			}
		//}
	<%
			}
		}
	  }
	}
	%>
<%		
		 }
	  }
	}
  }
%>