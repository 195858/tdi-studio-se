<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.eclipse.emf.common.util.EList
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.NodeType
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
            java.util.Map
            java.util.HashMap
            java.util.List
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
	" 
%>
<%
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	XmlMapComponent node = (XmlMapComponent) codeGenArgument.getArgument();
	String cid = node.getUniqueName();
	XmlMapData xmlMapData=(XmlMapData)ElementParameterParser.getObjectValueXMLTree(node);
	
	EList<InputXmlTree> inputTables = xmlMapData.getInputTrees();
	EList<OutputXmlTree> outputTables = xmlMapData.getOutputTrees();
	EList<VarTable> varTables = xmlMapData.getVarTables();
	
	class RepalceTableXpath {
		
		public void replaceTableXpath(TreeNode root){
			String xpath = root.getXpath();
			int index_p = xpath.indexOf(".");
			if(index_p<0){
    			xpath = xpath.replaceFirst("/", ".");
    			xpath = xpath.replaceFirst("/", ":/");
    			root.setXpath(xpath);
			}
    		for(TreeNode tmpNode : root.getChildren()) {
    			replaceTableXpath(tmpNode);
    		}
		}
		
	}
	RepalceTableXpath replaceXpath = new RepalceTableXpath();
	
	if(inputTables.size() > 0 && !inputTables.get(0).isLookup()) {
		InputXmlTree inputMainTable = inputTables.get(0);
		for(TreeNode tmpnode : inputMainTable.getNodes()) {
			if("id_Document".equals(tmpnode.getType())) {
				replaceXpath.replaceTableXpath(tmpnode);
				break;
			}
		}
	}

	for(OutputXmlTree outputMainTable : outputTables) {
		for(OutputTreeNode tmpnode : outputMainTable.getNodes()) {
			if("id_Document".equals(tmpnode.getType())) {
				replaceXpath.replaceTableXpath(tmpnode);
				break;
			}
		}
	}

	%>
//===============================input xml init part===============================

class NameSpaceTool_<%=cid%> {

    public java.util.HashMap<String, String> xmlNameSpaceMap = new java.util.HashMap<String, String>();
    
	private java.util.List<String> defualtNSPath = new java.util.ArrayList<String>();

    public void countNSMap(org.dom4j.Element el) {
        for (org.dom4j.Namespace ns : (java.util.List<org.dom4j.Namespace>) el.declaredNamespaces()) {
            if (ns.getPrefix().trim().length() == 0) {
                xmlNameSpaceMap.put("pre"+defualtNSPath.size(), ns.getURI());
                String path = "";
                org.dom4j.Element elTmp = el;
                while (elTmp != null) {
                	if (elTmp.getNamespacePrefix() != null && elTmp.getNamespacePrefix().length() > 0) {
                        path = "/" + elTmp.getNamespacePrefix() + ":" + elTmp.getName() + path;
                    } else {
                        path = "/" + elTmp.getName() + path;
                    }
                    elTmp = elTmp.getParent();
                }
                defualtNSPath.add(path);
            } else {
                xmlNameSpaceMap.put(ns.getPrefix(), ns.getURI());
            }

        }
        for (org.dom4j.Element e : (java.util.List<org.dom4j.Element>) el.elements()) {
            countNSMap(e);
        }
    }
    
    public String addDefaultNSPrefix(String path, String loopPath) {
        if (defualtNSPath.size() > 0) {
        	String fullPath = loopPath;
        	if(!path.equals(fullPath)){
            	for (String tmp : path.split("/")) {
            		if (("..").equals(tmp)) {
                        fullPath = fullPath.substring(0, fullPath.lastIndexOf("/"));
                    } else {
                        fullPath += "/" + tmp;
                    }
            	}
            }
        	int[] indexs = new int[fullPath.split("/").length - 1];
            java.util.Arrays.fill(indexs, -1);
            int length = 0;
            for (int i = 0; i < defualtNSPath.size(); i++) {
                if (defualtNSPath.get(i).length() > length && fullPath.startsWith(defualtNSPath.get(i))) {
                    java.util.Arrays.fill(indexs, defualtNSPath.get(i).split("/").length - 2, indexs.length, i);
                    length = defualtNSPath.get(i).length();
                }
            }

            StringBuilder newPath = new StringBuilder();
            String[] pathStrs = path.split("/");
            for (int i = 0; i < pathStrs.length; i++) {
                String tmp = pathStrs[i];
                if (newPath.length() > 0) {
                    newPath.append("/");
                }
                if (tmp.length() > 0 && tmp.indexOf(":") == -1 && tmp.indexOf(".") == -1 /*&& tmp.indexOf("@") == -1*/) {
                    int index = indexs[i + indexs.length - pathStrs.length];
                    if (index >= 0) {
                    	//==== add by wliu to support both filter and functions==
						if(tmp.indexOf("[")>0 && tmp.indexOf("]")>tmp.indexOf("[")){//include filter
							String tmpStr=replaceElementWithNS(tmp,"pre"+index+":");
							newPath.append(tmpStr);
						}else{
							if(tmp.indexOf("@") != -1 || tmp.indexOf("(")<tmp.indexOf(")")){  // include attribute
								newPath.append(tmp);
							}else{
						//==add end=======	
                        		newPath.append("pre").append(index).append(":").append(tmp);
                        	}
                        }                    
                    } else {
                        newPath.append(tmp);
                    }
                } else {
                    newPath.append(tmp);
                }
            }
            return newPath.toString();
        }
        return path;
    }

	private String matches = "@*\\b[a-z|A-Z|_]+[[-]*\\w]*\\b[^'|^\\(]";
    private java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(matches);
    
	private String replaceElementWithNS(String global, String pre){

        java.util.regex.Matcher match = pattern.matcher(global);
        StringBuffer sb = new StringBuffer();
        match.reset();
        while (match.find()) {
            String group = match.group();
            String tmp = "";
            if (group.toLowerCase().matches("\\b(div|mod|and|or)\\b.*") || group.matches("@.*")) {
                tmp = group;
            } else {
                tmp = tmp + pre + group;
            }
            match.appendReplacement(sb, tmp);
        }
        match.appendTail(sb);
        
        return sb.toString();
	}    

}

class XML_API_<%=cid%>{
	public boolean isDefNull(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        if (node != null && node instanceof org.dom4j.Element) {
        	org.dom4j.Attribute attri = ((org.dom4j.Element)node).attribute("nil");
        	if(attri != null && ("true").equals(attri.getText())){
            	return true;
            }
        }
        return false;
    }

    public boolean isMissing(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        return node == null ? true : false;
    }

    public boolean isEmpty(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        if (node != null) {
            return node.getText().length() == 0;
        }
        return false;
    }
}
<%

class GenerateMethodUtil {
	String cid = null;
	java.util.Map<String, String> typeMap = new java.util.HashMap<String, String>(); // Map<typeToGenerate, typeToGenerate>
	java.util.Map<String, String> pathTypeMap = new java.util.HashMap<String, String>(); // Map<input table xpath, typeToGenerate>
	java.util.Map<String, String> pathPatternMap = new java.util.HashMap<String, String>(); // Map<input table xpath, Pattern>
	java.util.Map<String, String> pathTypeToGenMap = new java.util.HashMap<String, String>(); // Map<"/root/name","String">
	
	void generateExprCode(String expression){
		StringBuilder strBuilder = new StringBuilder();
		if(expression==null || ("").equals(expression)) {
			return;
		}
//		System.out.println("expression=" + expression);
		if(expression.indexOf("[")>-1 && (expression.indexOf(".") > expression.indexOf("[")) 
			&& (expression.indexOf(".") < expression.indexOf(":")) && (expression.indexOf(":") < expression.indexOf("]")) ){
			// has the input tree path expression: [row1.doc:/root/subRoot]
			
// here we need to use a loop to query all the xpath in the expression
			
			int index_start = expression.indexOf("[");
			int index_end = expression.indexOf("]", index_start+1);
			String tmpXpath = expression.substring(index_start + 1, index_end );
//			System.out.println("tmpXpath=" + tmpXpath + " ::::"+pathTypeToGenMap.get(tmpXpath));
			if(index_start>0){
				strBuilder.append(expression.substring(0,index_start-1));
			}
			if("id_String".equals(pathTypeMap.get(tmpXpath)) || "id_Object".equals(pathTypeMap.get(tmpXpath))){
				strBuilder.append("treeNodeAPI_"+cid+".get_String(\""+ tmpXpath + "\")");
			} else if("id_Date".equals(pathTypeMap.get(tmpXpath))) {
				strBuilder.append("treeNodeAPI_"+cid+".get_Date(\""+ tmpXpath + "\" , \"" + pathPatternMap.get(tmpXpath) + "\")");
			} else if("id_byte[]".equals(pathTypeMap.get(tmpXpath))) {
				strBuilder.append("treeNodeAPI_"+cid+".get_Bytes(\""+ tmpXpath + "\")");
			} else {
				strBuilder.append("treeNodeAPI_"+cid+".get_" + pathTypeToGenMap.get(tmpXpath) + "(\""+ tmpXpath + "\")");
			}
			if(index_end+1 < expression.length()) {
				strBuilder.append(expression.substring(index_end+1));
			}
		} else { // there is no xpath in the expression
			strBuilder.append(expression);
		}
%><%=strBuilder.toString() %>
<%
	}
	
	void generateCode(TreeNode node, String cid){
%>
class TreeNode_API_<%=cid %> {
	java.util.Map<String, String> xpath_value_map = new java.util.HashMap<String, String>();
	
	void clear(){
		xpath_value_map.clear();
	}
	
	void put(String xpath, String value){
		xpath_value_map.put(xpath, value);
	}
	String get_null(String xpath) {
		return null;
	}
<%
		generateMethodCode(node, cid);
%>
}
<%
	}
	
	void generateMethodCode(TreeNode node, String cid) {

		if(node.getOutgoingConnections().size()>0){
			String talendType = node.getType();
			JavaType javaType = JavaTypesManager.getJavaTypeFromId(talendType);
			String typeToGenerate = JavaTypesManager.getTypeToGenerate(talendType, node.isNullable());
			String patternValue = node.getPattern() == null || node.getPattern().trim().length() == 0 ? null : node.getPattern();
			
			pathTypeMap.put(node.getXpath(), talendType);
			pathPatternMap.put(node.getXpath(), patternValue);
			pathTypeToGenMap.put(node.getXpath(), typeToGenerate);
//			System.out.println("javaType:Id=" + javaType.getId() + "---talendType="+talendType +"---typeGen=" +typeToGenerate);
			if(typeMap.get(typeToGenerate)==null){
				typeMap.put(typeToGenerate,typeToGenerate);
				if ("id_String".equals(talendType) || "id_Object".equals(talendType)) {
%>
	String get_String(String xpath){
		return xpath_value_map.get(xpath);
	}
<%
				} else if ("id_Date".equals(talendType)) {
%>
	java.util.Date get_Date(String xpath, String pattern){
		if(xpath_value_map.get(xpath)==null) return null;
		return ParserUtils.parseTo_Date(xpath_value_map.get(xpath), pattern);
	}
<%
				} else if("id_byte[]".equals(talendType)){ 
%>
	byte[] get_Bytes(String xpath){
		if(xpath_value_map.get(xpath)==null) return null;
		return xpath_value_map.get(xpath).getBytes();
	}
<%
				} else {
%>
	<%=typeToGenerate %> get_<%=typeToGenerate %>(String xpath){
		return ParserUtils.parseTo_<%= typeToGenerate %>(xpath_value_map.get(xpath));
	}
<%
				}
			}
		} else {
    		for(TreeNode tmpNode : node.getChildren()) {
    			generateMethodCode(tmpNode,cid);
    		}
		}
	}
}

	// define the var row
	for (VarTable var : xmlMapData.getVarTables()) {
		String tableName = var.getName();
        String instanceVarName = tableName + "__" + node.getUniqueName();
        String className = instanceVarName + "__Struct";
%>
	class <%=className %> {
<%
            for(VarNode varNode : var.getNodes()){
                String javaType = varNode.getType();
%>	<%= JavaTypesManager.getTypeToGenerate(javaType, varNode.isNullable()) %> <%=varNode.getName() %>;
<%
            }
%>
	}
	<%= className %> <%= instanceVarName %> = new <%= className %>();
<%
	}
%>
// ###############################
// # Outputs initialization
<%

		List<IConnection> outputConnections = (List<IConnection>) node.getOutgoingConnections();
		Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
        for (IConnection connection : outputConnections) {
		  		nameToOutputConnection.put(connection.getName(), connection);
		}

//        EList<OutputXmlTree> outputTablesList = new ArrayList<OutputXmlTree>(outputTables);
        // constants
        for (OutputXmlTree table : outputTables) {
        
            EList<OutputTreeNode> tableEntries = table.getNodes();
            if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
                continue;
            }
            String tableName1 = table.getName();
            
            String instanceVarName = tableName1 + "__" + node.getUniqueName();
            String className = tableName1 + "Struct";
            
%>
<%= className %> <%= tableName1 %>_tmp = new <%= className %>();
<%
        }
%>
// ###############################
<%
	
	List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();
	InputXmlTree mainInputTable = null;  // the main input table
	if(inputConnections==null || inputConnections.size() < 1) {
		return "";
	}
//	System.out.println("inputTables size=" + inputTables.size());
//	System.out.println("outputTables size=" + outputTables.size());
//	System.out.println("varTables size=" + varTables.size());
	if(inputTables==null || inputTables.size()==0) return "";
	for(IConnection conn : inputConnections) { // find the input main table
		InputXmlTree inputTable = inputTables.get(0);
		EConnectionType connectionType = conn.getLineStyle();
		if (connectionType == EConnectionType.FLOW_MAIN) {
			if(!inputTable.isLookup()) { // lookup is used to sign it is lookup table
    			mainInputTable = inputTable;
    			break;
			}
		}
	}
	
	class FindNodeUtil{
		
		TreeNode findLoopPathNode(TreeNode node){
			if(node == null){
				return null;
			}
			if(node.isLoop()) {
				return node;
			}
			for(TreeNode tmpNode : node.getChildren()) {
				TreeNode resultNode = findLoopPathNode(tmpNode);
				if(resultNode!=null){
					return resultNode;
				}
			}
			
			return null;
		}
		
		void findXpathArray(TreeNode node, String loopPath, List<String> resultList) {
			if(node.getOutgoingConnections().size()>0){
				String xpath = node.getXpath();
				String result = null;
				if(xpath==null || ("").equals(xpath)){
				} else if(xpath.equals(loopPath)){ // get the value in the loop elment
					result = ".";
				} else if(xpath.contains(loopPath)){ // find the loop path
					result = xpath.substring(loopPath.length() + 1);
				} else {
					StringBuilder resultBuff = new StringBuilder();
					String tmp = loopPath;
					
					while(!xpath.contains(tmp)){
						int index = tmp.lastIndexOf("/");
						if(index<0){ break; }
						tmp = tmp.substring(0,index-1);
						resultBuff.append("../");
					}
					if(tmp.lastIndexOf("/") < 0 ){
						System.out.println("Loop Path is not set or loop Path is invalid");
					}else{
						resultBuff.append(xpath.substring(tmp.length() + 1));
					}
					result = resultBuff.toString();
				}
				resultList.add(result);
			} else {
    			for(TreeNode tmpNode : node.getChildren()) {
    				findXpathArray(tmpNode, loopPath, resultList);
    			}
			}
		}
	}
	GenerateMethodUtil generateMethodUtil = new GenerateMethodUtil();
	generateMethodUtil.cid = cid;
	if(mainInputTable != null) {
		String mainInputName = mainInputTable.getName();
		for(TreeNode tmpNode : mainInputTable.getNodes()){
			if(("id_Document").equals(tmpNode.getType())) { // find the type:document node.
                // generate the method to get the correct type in the xml tree
                generateMethodUtil.generateCode(tmpNode, cid); // begin part keep this part
                break;
            }
        }
    }

%>
	TreeNode_API_<%=cid %> treeNodeAPI_<%=cid %> = new TreeNode_API_<%=cid %>();
	int nb_line_<%=cid%> = 0; 
	NameSpaceTool_<%=cid%> nsTool_<%=cid%> = new NameSpaceTool_<%=cid%>();
    XML_API_<%=cid%> xml_api_<%=cid%> = new XML_API_<%=cid%>();

<%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//=====================================================output xml init part=======================================================================
class GenerateToolByDom4j{
	String cid = null;
	GenerateMethodUtil generateMethodUtil = null;
	
	void setAllMainNodes(TreeNode root) {
		TreeNode loop = getLoopNode(root);
		if(loop==null) return;
		loop.setMain(true);
		TreeNode parent = (TreeNode)loop.eContainer();
		while((parent != null) && (!("id_Document").equals(parent.getType())) ) {
			parent.setMain(true);
			parent = (TreeNode)parent.eContainer();
		}
	}
	
	public TreeNode getLoopNode(TreeNode root) {
		if(root == null) {
			return null;
		}
		if(root.isLoop()){
			return root;
		}
		
		for(TreeNode node : root.getChildren()){
			TreeNode tmpNode = getLoopNode(node);
			if(tmpNode!=null) {
				return tmpNode;
			}
		}
		return null;
	}
	
	public void generateCode(OutputTreeNode node, String currEleName, String parentName){
		if(node.getNodeType()==NodeType.ELEMENT){
			createElement(currEleName,node,parentName);
			setText(currEleName,node);
		
    		// add namespace support here in the future
    		//
    		
    		addAttribute(currEleName, node);
//    		System.out.println("parent:" + ((OutputTreeNode)node).getName() + "===node:" + node.getName() );
    		if(!isRootEndMainNode(node)){
    			int index = 0;
    			for(TreeNode child:node.getChildren()){
    				generateCode((OutputTreeNode)child,currEleName+"_"+index++,currEleName);
    			}
			}
		}
	}
	
	private void createElement(String currEleName, OutputTreeNode node, String parentName){
		int index = node.getName().indexOf(":");
		if(index>0 && hasParent(node)){
%>
		org.dom4j.Element <%=currEleName%>;
		if (<%=parentName%>.getNamespaceForPrefix("<%=node.getName().substring(0,index)%>") == null) {
            <%=currEleName%> = <%=parentName%>.addElement("<%=node.getName().substring(index+1)%>");
        } else {
        	<%=currEleName%> = <%=parentName%>.addElement("<%=node.getName()%>");
        }
<%
		}else{
%>
		org.dom4j.Element <%=currEleName%> = <%=parentName%>.addElement("<%=node.getName()%>");
<%
		}
		if(isRootEndMainNode(node)){
%>
		subTreeRootParent = <%=currEleName%>;
<%
		}
	}
	
	private void addAttribute(String currEleName, OutputTreeNode node){
		for(TreeNode tmpNode : node.getChildren()) {
			if(tmpNode.getNodeType()==NodeType.ATTRIBUT) {
%>
//		if(<%//tool.getValue(node);%>!=null){
			<%=currEleName%>.addAttribute("<%=tmpNode.getName() %>",String.valueOf(<%generateMethodUtil.generateExprCode(tmpNode.getExpression()); %>));
//		}
<%
			}
		}
	}
	
	private void setText(String currEleName, OutputTreeNode node){
		if(node.getExpression()!=null && !("").equals(node.getExpression())){
%>
		nestXMLTool.setText(<%=currEleName%>, String.valueOf(<%generateMethodUtil.generateExprCode(node.getExpression()); %>));
<%
		}
	}
	private boolean hasParent(OutputTreeNode node){
		if(node.eContainer()!=null){
			OutputTreeNode parent = (OutputTreeNode)node.eContainer();
			if(!("id_Document").equals(parent.getType()) && parent.isMain()){
				return true;
			}
		}
		return false;
	}
	
	private boolean isRootEndMainNode(OutputTreeNode node){
//		System.out.println(node.getName() + ":main=" + node.isMain() + ":Loop=" + node.isLoop() + ":group=" + node.isGroup());
		if(!node.isMain() || node.isLoop() || node.isGroup()){
			return false;
		}
		for(TreeNode tmpNode: node.getChildren()){
			if(tmpNode.isMain() && (tmpNode.isLoop() || tmpNode.isGroup())){
				return true;
			}
		}
		return false;
	}
	// the root node which a group child or loop child
	private boolean isMediaMainNode(OutputTreeNode node) {
		if(node.isMain()) {
			for(TreeNode tmpNode : node.getChildren()) {
				if(tmpNode.isMain() && (tmpNode.isLoop() || tmpNode.isGroup())) {
					return true;
				}
			}
		}
		return false;
	}
	
	private void generateGroupCmpCode(OutputTreeNode node) {
		if(node.isLoop()) return;
		if(node.isMain() && node.isGroup()){ // the group node
%>if(isNewElememt 
<%
			for(TreeNode tmpNode : node.getChildren()){
				if(tmpNode.getExpression()!=null && !("").equals(tmpNode.getExpression()) ) {
%>
treeNodeAPI.get()
<%
				}
			}
%>
) {
<%
		}
	}
}
%>
class NestXMLTool_<%=cid%>{
	public void parseAndAdd(org.dom4j.Element nestRoot, String value){
		try {
            org.dom4j.Document doc4Str = org.dom4j.DocumentHelper.parseText("<root>"+ value + "</root>");
    		nestRoot.setContent(doc4Str.getRootElement().content());
    	} catch (Exception e) {
    		e.printStackTrace();
    		nestRoot.setText(value);
        }
	}
	
	public void setText(org.dom4j.Element element, String value){
		if (value.startsWith("<![CDATA[") && value.endsWith("]]>")) {
			String text = value.substring(9, value.length()-3);
			element.addCDATA(text);
		}else{
			element.setText(value);
		}
	}
	
	public void replaceDefaultNameSpace(org.dom4j.Element nestRoot){
		if (nestRoot!=null) {
			for (org.dom4j.Element tmp: (java.util.List<org.dom4j.Element>) nestRoot.elements()) {
        		if (("").equals(tmp.getQName().getNamespace().getURI()) && ("").equals(tmp.getQName().getNamespace().getPrefix())){
        			tmp.setQName(org.dom4j.DocumentHelper.createQName(tmp.getName(), nestRoot.getQName().getNamespace()));
	        	}
    	    	replaceDefaultNameSpace(tmp);
       		}
       	}
	}
	
	public void removeEmptyElement(org.dom4j.Element root){
		if (root!=null) {
			for (org.dom4j.Element tmp: (java.util.List<org.dom4j.Element>) root.elements()) {
				removeEmptyElement(tmp);
			}
			if (root.content().size() == 0 
    			&& root.attributes().size() == 0 
    			&& root.declaredNamespaces().size() == 0) {
    			if(root.getParent()!=null){
                	root.getParent().remove(root);
                }
            }
		}
	}
}
//NestXMLTool_<%=cid%> nestXMLTool_<%=cid%> = new NestXMLTool_<%=cid%>();

<%
	//init the generate tool.
	GenerateToolByDom4j generateToolByDom4j = new GenerateToolByDom4j();
	generateToolByDom4j.cid = cid;
	generateToolByDom4j.generateMethodUtil = generateMethodUtil;
// define the generate the output document class
for(OutputXmlTree outputTable : outputTables) {
	String tableName = outputTable.getName();
	for(OutputTreeNode outputNode: outputTable.getNodes()) {
		if(("id_Document").equals(outputNode.getType())){
%>
class GenerateDocument_<%=tableName %> {
	
	TreeNode_API_<%=cid %> treeNodeAPI_<%=cid %> = null;
	
	org.dom4j.Document doc = null;
	
	NestXMLTool_<%=cid%> nestXMLTool = null;
	
	org.dom4j.Element root4Group = null;
	
	org.dom4j.io.OutputFormat format = null;
	
	java.util.List<java.util.List<String>> groupbyList = null;
	
	boolean isFirst = true;
	
	boolean	needRoot = true;
<%
//Integer groupSize = new Integer(0);
//getGroupSize(outputNode, groupSize);
%>
	
    public GenerateDocument_<%=tableName %>(){
//    	this.treeNodeAPI = treeNodeAPI;
    	
    	nestXMLTool = new NestXMLTool_<%=cid%>();
    	
    	groupbyList = new java.util.ArrayList<java.util.List<String>>();
    	
    	doc = org.dom4j.DocumentHelper.createDocument();
    	format = org.dom4j.io.OutputFormat.createPrettyPrint();
    	format.setTrimText(false);
    }
    
    public org.dom4j.Document getDocument(){
    	return this.doc;
    }
	
void generateElements(TreeNode_API_<%=cid %> treeNodeAPI <%
for (InputXmlTree inputTable: inputTables) {
%>, <%=inputTable.getName() %>Struct <%=inputTable.getName() %><%
}
for (VarTable var : varTables) {
		String tableName1 = var.getName();
        String instanceVarName = tableName1 + "__" + cid;
        String className = instanceVarName + "__Struct";
%>, <%=className %> <%=var.getName()%><%
}
%>) {
if(this.treeNodeAPI_<%=cid %>==null) {
	this.treeNodeAPI_<%=cid %> = treeNodeAPI;
}
org.dom4j.Element subTreeRootParent = null;
// build root xml tree 
if (needRoot) {
	needRoot=false;
<%
	OutputTreeNode root = (OutputTreeNode)outputNode.getChildren().get(0); // get the root tree node
	generateToolByDom4j.setAllMainNodes(root);
	generateToolByDom4j.generateCode(root,"root","doc");
%>
	root4Group = subTreeRootParent;
}else{
	subTreeRootParent=root4Group;
}
// build group xml tree 
boolean isNewElememt = false;
	
<%

OutputTreeNode loop = (OutputTreeNode)generateToolByDom4j.getLoopNode(root);
if(loop==null){
	System.out.println("Loop is empty");
}else {
	generateToolByDom4j.generateCode(loop,"loop","subTreeRootParent");
}
%>
}
	
}
<%
		} // if(docuemnt)
	}// for(outputNode)
} // for (outputXMLTree)
%>