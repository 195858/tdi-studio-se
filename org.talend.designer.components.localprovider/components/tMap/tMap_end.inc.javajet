<%@ jet 
	imports="
	java.util.ArrayList
	java.util.List
	org.talend.designer.mapper.external.data.ExternalMapperData 
	org.talend.designer.mapper.external.data.ExternalMapperTable
	org.talend.designer.mapper.external.data.ExternalMapperTableEntry
	org.talend.designer.codegen.config.CodeGeneratorArgument
	org.talend.designer.mapper.MapperComponent
	org.talend.core.model.process.IElementParameter
	org.talend.core.model.process.INode
	org.talend.core.model.process.IConnection
	java.util.HashMap
	java.util.Map
    org.talend.core.model.process.ElementParameterParser
	" 
	skeleton="tMap_commons.skeleton"
%>

<%

	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	MapperComponent node = (MapperComponent) codeGenArgument.getArgument();
	boolean stats = codeGenArgument.isStatistics();
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ExternalMapperData data = (ExternalMapperData) node.getExternalData();

	String componentName = node.getUniqueName();
	boolean isVirtualIn = componentName.endsWith("TMAP_IN");
	boolean isVirtualOut = componentName.endsWith("TMAP_OUT");

    List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();

	if(isVirtualIn) {
		String searchedComponentName = componentName.replaceAll("TMAP_IN", "TMAP_OUT");
		List<? extends INode> generatedNodes = node.getProcess().getGeneratingNodes();
		for(INode loopNode : generatedNodes) {
			if(loopNode.getUniqueName().equals(searchedComponentName)) {
				inputConnections = (List<IConnection>) loopNode.getIncomingConnections();
				break;
			}
		}
	}


		// Bug partially fixed, see bug:785	
		// Bug partially fixed, see bug:3966	
		
		boolean hasIterate = hasIterateConnectionBefore(inputConnections);
        
        
%>
// ###############################
// # Lookup hashes releasing
<%

		if(!isVirtualOut) {

	        HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
        	for (IConnection connection : inputConnections) {
	            hNameToConnection.put(connection.getName(), connection);
        	}

	        List<ExternalMapperTable> inputTablesList = new ArrayList<ExternalMapperTable>(data.getInputTables());
	        int lstSizeInputs = inputTablesList.size();
	        
	        if(lstSizeInputs > 1) {
	        	String mainTableName = inputTablesList.get(0).getName();
	    
	    		String tmpJoinedTableNames = "";    	
	    		String joinedTableNames = "";    	
	    		int tmpIndexLastJoined = -1;
	    		boolean hasPersistentLookup = false;
		        for (int i = 0; i < lstSizeInputs; i++) {
		            ExternalMapperTable inputTable = (ExternalMapperTable) inputTablesList.get(i);

					if(hNameToConnection.get(inputTable.getName()) != null) {
	        			if(inputTable.isPersistent() 
		        			&& !"ALL_ROWS".equals(inputTable.getMatchingMode()) 
	        			) {
		        			tmpJoinedTableNames = joinedTableNames;
	        				tmpIndexLastJoined = i;
	        				hasPersistentLookup = true;
	        			}

	        			joinedTableNames += ((i > 0) ? "__" : "") + inputTable.getName();
	        		}

	        	}

	        	if(hasPersistentLookup) {
				%>
					fsi_<%= tmpJoinedTableNames %>.endGet();
				<%
	        	}
	        	
	        }
	        
	        for (int i = 1; i < lstSizeInputs; i++) {
	            ExternalMapperTable inputTable = (ExternalMapperTable) inputTablesList.get(i);


	            List<ExternalMapperTableEntry> tableEntries = inputTable.getMetadataTableEntries();
	            if (tableEntries == null) {
	                continue;
	            }
	            String tableName = inputTable.getName();
	            IConnection connection = hNameToConnection.get(tableName);
	            if(connection == null) {
	            	continue;
	            }
				if(!hasIterate) {
				%>
					tHash_Lookup_<%=tableName%>.endGet();
					globalMap.remove( "tHash_Lookup_<%=tableName%>" );
				<%
				}
	        }
		}
%>
// ###############################        
