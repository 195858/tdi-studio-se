public class CLASS {


	public boolean hasConcurrencyContext(List<IConnection> inputConnections) {

		for(IConnection connection : inputConnections) {
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
	            INode node = connection.getSource();
				return recursiveSearchIterateForConcurrency(node);
			}
		}
		return false;
	
	}

	public boolean hasIterateConnectionBefore(List<IConnection> inputConnections) {

		for(IConnection connection : inputConnections) {
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
	            INode node = connection.getSource();
				return recursiveSearchIterate(node);
			}
		}
		return false;
	
	}
	
	public boolean recursiveSearchIterate(INode node) {
	
		//System.out.println(node);
	
		List<IConnection> connections = (List<IConnection>) node.getIncomingConnections();

		for(IConnection connection : connections) {
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
	            node = connection.getSource();
				//System.out.println(connection.getName() + " connectionType=" + connectionType + " connection=" + String.valueOf(connection));
    	        return recursiveSearchIterate(node);
            } else if(connectionType == EConnectionType.ITERATE) {
				//System.out.println("ITERATE return true");
    	        return true;
            }
		}
		
		//System.out.println("return false");
		return false;
	
	}

	public boolean recursiveSearchIterateForConcurrency(INode node) {
	
		//System.out.println(node);
	
		List<IConnection> connections = (List<IConnection>) node.getIncomingConnections();

		for(IConnection connection : connections) {
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
	            node = connection.getSource();
				//System.out.println(connection.getName() + " connectionType=" + connectionType + " connection=" + String.valueOf(connection));
    	        return recursiveSearchIterateForConcurrency(node);
            } else if(connectionType == EConnectionType.ITERATE) {
				//System.out.println("ITERATE return true");
				boolean parallelIterate = "true".equals(ElementParameterParser.getValue(connection, "__ENABLE_PARALLEL__"));
    	        return parallelIterate;
            }
		}
		
		//System.out.println("return false");
		return false;
	
	}

	public INode searchSubProcessStartNode(IConnection connection) {
       	INode source = connection.getSource();
    	//System.out.println(" source=" +  source);
    	INode subprocessStartNode = null;
    	if(source != null) {
			String searchedComponentName = source.getUniqueName();
        	//System.out.println(" searchedComponentName=" +  searchedComponentName);
			List<? extends INode> generatedNodes = source.getProcess().getGeneratingNodes();
			for(INode loopNode : generatedNodes) {
				if(loopNode.getUniqueName().equals(searchedComponentName)) {
					subprocessStartNode = loopNode.getSubProcessStartNode(false);
		        	//System.out.println(" subprocessStartNode=" +  subprocessStartNode.getUniqueName());
				}
			}
		}
	
		return subprocessStartNode;
	}
	
	
	
    /**
     *add by wyang for feature:11325, treat as a patch:
     * 
     *when tHashInput as Lookup branch of tMap, in order to let tMap operate
     * the struct which buffered in tAdvancedHash directly, so, rename the name
     * of tHashInput lookup connection to the same name of tAdvancedHash input
     * connection
     * 
     * return Map<String, String> ---it is like this:---><oldName,
     * newName>------><row3, row1>
     */
    public Map<String, String> processtHashInputLookupCase_Begin(
            MapperComponent node, StringBuffer stringBuffer) {
        Map<String, String> returnMap = new HashMap<String, String>();

        List<IConnection> inputConnections = (List<IConnection>) node
                .getIncomingConnections();
        {
            String componentName = node.getUniqueName();
            boolean isVirtualIn = componentName.endsWith("TMAP_IN"); 
            //if current component is tMap_1_TMAP_IN, it have to get tMap_1_TMAP_OUT first, and then treat tMapOut as tMap, do the next process
            if(isVirtualIn){
                inputConnections = (List<IConnection>)node.getIncomingConnections().get(0).getSource().getIncomingConnections();
            }
        }
        
        ExternalMapperData data = (ExternalMapperData) node.getExternalData();

        List<ExternalMapperTable> inputTables = data.getInputTables();        

        // if there have many tHashInput as Lookup, so iterate it.
       outer: for (IConnection conn : inputConnections) {
            INode source = conn.getSource();
            boolean istHashInput = source.getComponent().getName().equals(
                    "tHashInput");
            if (istHashInput) {
                String connName = conn.getName();
                for (ExternalMapperTable aInputTable : inputTables) {
                    String tableName = aInputTable.getName();
                    if (connName.equals(tableName)) {
                        // OK, let rename it!!!

                        String linkedtHashOutput = ElementParameterParser
                                .getValue(source, "__LIST__");
                        INode rootNode = node; // node means tMap
                        List<? extends INode> nodeList = source.getProcess()
                                .getGeneratingNodes();
                        for (INode n : nodeList) {
                            if (n.getUniqueName().equals(linkedtHashOutput)) {
                                rootNode = n; // rootNode means tAdvancedHash
                                break;
                            }
                        }

                        // get it!!!
                        if (rootNode != node) {
                            // get the input connection
                            IConnection inputConn = null;
                            String inComingName = "";
                            List<? extends IConnection> connsIn = rootNode
                                    .getIncomingConnections();
                            for (IConnection connABC : connsIn) {// 3
                                inputConn = connABC;
                                break; // only get the first connection
                            }// 3

                            if (inputConn != null) {
                                inComingName = inputConn.getName();

                                // store it, because at the end, it will be
                                // recovery again(rename back).
                                String oldName = aInputTable.getName();                                
                                
                                if(!returnMap.values().contains(inComingName)){
                                    returnMap.put(oldName, inComingName);
                                }else{
                                    //in order to void the 2 tHashInput link to the same tMap
                                    stringBuffer.append("Design job error:\nCan't support this case: 2 tHashInput with the same tHashOutput link to one tMap.");
                                    break outer; 
                                }
                                
                                // OK, let rename it!!!
                                // RENAME============================
                                aInputTable.setName(inComingName);
                                ((org.talend.core.model.process.AbstractConnection) conn)
                                        .setName(inComingName);
                                // RENAME============================
                                
                                //outputExpression.replace(oldName, inComingName)
                                renameAll(data, oldName, inComingName);                                 

                            }

                        }
                    }
                }
            }
        }
        
        
        //String componentName = node.getUniqueName();        
        //System.out.println(componentName + " returnMap:" + returnMap);
       
        return returnMap;
    }

    /**
     *add by wyang for feature:11325, treat as a patch: return Map<String,
     * String> ---it is like this:---><oldName, newName>------><row3, row1>
     * rename back, use oldName overwrite the newName, like: rename row1 to row3
     */
    public void processtHashInputLookupCase_End(MapperComponent node,
            Map<String, String> returnMap) {
        
        if(returnMap==null || returnMap.size()==0){
            return;
        }
        
        java.util.Set<String> keySet = returnMap.keySet();

        if (keySet.size() > 0) {
            List<IConnection> inputConnections = (List<IConnection>) node
                    .getIncomingConnections();
            
            {
                String componentName = node.getUniqueName();
                boolean isVirtualIn = componentName.endsWith("TMAP_IN"); 
                //if current component is tMap_1_TMAP_IN, it have to get tMap_1_TMAP_OUT first, and then treat tMapOut as tMap, do the next process
                if(isVirtualIn){
                    inputConnections = (List<IConnection>)node.getIncomingConnections().get(0).getSource().getIncomingConnections();
                }
            }
            
            ExternalMapperData data = (ExternalMapperData) node
                    .getExternalData();

            List<ExternalMapperTable> inputTables = data.getInputTables();

            // iterate all names paire
            for (String oldName : keySet) {
                String newName = returnMap.get(oldName);

                //1. for inputConnections
                for (IConnection conn : inputConnections) {                    
                    if (newName.equals(conn.getName())) {
                       // System.out.println("revert " + newName + " to " + oldName);
                        // OK, let rename it!!!
                        // RENAME============================
                        ((org.talend.core.model.process.AbstractConnection) conn)
                                .setName(oldName);
                        // RENAME============================
                        //break;
                    }
                }

                //2. for ExternalMapperTable
                for (ExternalMapperTable aInputTable : inputTables) {
                    if (newName.equals(aInputTable.getName())) {
                        // OK, let rename it!!!
                        // RENAME============================
                        aInputTable.setName(oldName);
                        // RENAME============================
                        //break;
                    }
                }
                
                //outputExpression.replace(newName, oldName)
                renameAll(data, newName, oldName);  

            }

        }
    }

    /**
     *add by wyang for feature:11325, 
     *   
     */
    private void renameAll(ExternalMapperData data, String oldName, String newName) {
        // correct the Var expression, replace row3.A to row1.A
        List<ExternalMapperTable> outputTables = data.getOutputTables();
        for (ExternalMapperTable emTable : outputTables) {
            List<ExternalMapperTableEntry> outputTableEntries = emTable.getMetadataTableEntries();
            for (ExternalMapperTableEntry outputTableEntry : outputTableEntries) {
                String outputExpression = outputTableEntry.getExpression();                                        
                //1. outputTableEntry Expression
                outputTableEntry.setExpression(outputExpression.replace(oldName, newName));
            }
            
            //2. Filter
            String expressionFilter = emTable.getExpressionFilter();
            if(expressionFilter != null){
                emTable.setExpressionFilter(expressionFilter.replace(oldName, newName));
            }    
        } 
        
        List<ExternalMapperTable> varsTables = data.getVarsTables();                                
        for (ExternalMapperTable varsTable : varsTables) {
            List<ExternalMapperTableEntry> outputTableEntries = varsTable.getMetadataTableEntries();
            if(outputTableEntries != null){
                for (ExternalMapperTableEntry outputTableEntry : outputTableEntries) {
                    String outputExpression = outputTableEntry.getExpression();                                        
                    //3. outputTableEntry Expression
                    if(outputExpression != null){
                        outputTableEntry.setExpression(outputExpression.replace(oldName, newName));
                    }    
                }
            }
            
            //4. Filter
            String expressionFilter = varsTable.getExpressionFilter();
            if(expressionFilter != null){
                varsTable.setExpressionFilter(expressionFilter.replace(oldName, newName));
            }    
        }
        
        List<ExternalMapperTable> inputTables2 = data.getInputTables();
        for (ExternalMapperTable emTable : inputTables2) {
            List<ExternalMapperTableEntry> outputTableEntries = emTable.getMetadataTableEntries();
            for (ExternalMapperTableEntry outputTableEntry : outputTableEntries) {
                String outputExpression = outputTableEntry.getExpression();                                        
                //5. outputTableEntry Expression
                if(outputExpression != null){
                    outputTableEntry.setExpression(outputExpression.replace(oldName, newName));
                }    
            }
            
            //6. Filter
            String expressionFilter = emTable.getExpressionFilter();
            if(expressionFilter != null){
                emTable.setExpressionFilter(expressionFilter.replace(oldName, newName));
            }    
        }
    }
    
    
    /**
     *add by wyang for feature:11325, 
     *when at the tMap_end.inc.javajet, to check whether there can clear the buffer or not
     */
    public boolean canClearBuffer(MapperComponent node,
            Map<String, String> returnMap, String tableName) {

        // it means it is related with tHashInput
        if (returnMap == null || returnMap.size() == 0) {
            return true;
        }

        List<IConnection> inputConnections = (List<IConnection>) node
                .getIncomingConnections();
        {
            String componentName = node.getUniqueName();
            boolean isVirtualIn = componentName.endsWith("TMAP_IN");
            // if current component is tMap_1_TMAP_IN, it have to get
            // tMap_1_TMAP_OUT first, and then treat tMapOut as tMap, do the
            // next process
            if (isVirtualIn) {
                inputConnections = (List<IConnection>) node
                        .getIncomingConnections().get(0).getSource()
                        .getIncomingConnections();
            }
        }

        // if there have many tHashInput as Lookup, so iterate it.
        for (IConnection conn : inputConnections) {
            INode source = conn.getSource();
            boolean istHashInput = source.getComponent().getName().equals(
                    "tHashInput");
            if (istHashInput) {
                //it means it is tHashInput, it can't clear the buffer now, maybe the buffer will be used later again
                return false;
            }
        }

        return true;
    }    


    public String generate(Object argument) {

    }
}