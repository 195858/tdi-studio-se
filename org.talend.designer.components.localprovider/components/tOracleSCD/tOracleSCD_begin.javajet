<%@ jet 
imports="
	org.talend.core.model.process.INode
	org.talend.core.model.process.ElementParameterParser
	org.talend.core.model.metadata.IMetadataTable
	org.talend.core.model.metadata.IMetadataColumn
	org.talend.designer.codegen.config.CodeGeneratorArgument
	org.talend.core.model.process.IConnection
	org.talend.core.model.process.IConnectionCategory
	org.talend.core.model.metadata.builder.database.ExtractMetaDataUtils
	org.talend.core.model.metadata.types.JavaTypesManager
	org.talend.core.model.metadata.types.JavaType
	java.util.List
	java.util.ArrayList
	java.util.Map
	java.util.HashMap
    org.talend.commons.utils.StringUtils
"
%>

<%
CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
INode node = (INode) codeGenArgument.getArgument();
String cid = node.getUniqueName();

// Search incoming schema
IMetadataTable inMetadata = null;
IConnection inConnection = null;
String inConnectionName = null;

List<? extends IConnection> incomingConnections = node.getIncomingConnections();
if (incomingConnections != null && !incomingConnections.isEmpty()) {
    inConnection = incomingConnections.get(0);
    inConnectionName = inConnection.getName();
    inMetadata = inConnection.getMetadataTable();
}

// Search outgoing schema
IMetadataTable metadata = null;

List<IMetadataTable> metadatas = node.getMetadataList();
if (metadatas != null && metadatas.size() > 0) {
    metadata = metadatas.get(0);
}

// We only generate output if incoming and outgoing schema are defined
if (inMetadata != null && metadata != null) {
	// Database parameters
	String dbhost = ElementParameterParser.getValue(node, "__HOST__");
	String dbport = ElementParameterParser.getValue(node, "__PORT__");
	String dbname = ElementParameterParser.getValue(node, "__DBNAME__");
	String dbuser = ElementParameterParser.getValue(node, "__USER__");
	String dbpwd = ElementParameterParser.getValue(node, "__PASS__");
	String dbtable = ElementParameterParser.getValue(node, "__TABLE__");
	String dbencoding = ElementParameterParser.getValue(node, "__ENCODING__");
	boolean useExistingConnection = ElementParameterParser.getValue(node,"__USE_EXISTING_CONNECTION__").equals("true");
	
	// Create database connection
	if (useExistingConnection) {
		String connection = ElementParameterParser.getValue(node, "__CONNECTION__");
		String connectionName = "conn_" + connection;
		%>
		java.sql.Connection connection_<%=cid%> = (java.sql.Connection) globalMap.get("<%=connectionName%>");
		<%
	} else {
		%>
		java.lang.Class.forName("oracle.jdbc.driver.OracleDriver");
		<%
		String connectionType = ElementParameterParser.getValue(node, "__CONNECTION_TYPE__");
		if (connectionType.equals("ORACLE_SID")) {
			%>
			String connectionString_<%=cid%> = "jdbc:oracle:thin:@" + <%=dbhost%> + ":" + <%=dbport%> + ":" + <%=dbname%>;
			<%
		} else if(connectionType.equals("ORACLE_SERVICE_NAME")) {
			%>
			String connectionString_<%=cid%> = "jdbc:oracle:thin:@(description=(address=(protocol=tcp)(host=" + <%=dbhost%> + ")(port=" + <%=dbport%> + "))(connect_data=(service_name=" + <%=dbname%> + ")))";
			<%
		}
		%>
		java.sql.Connection connection_<%=cid%> = java.sql.DriverManager.getConnection(connectionString_<%=cid%>, <%=dbuser%>, <%=dbpwd%>);
		<%
	}
	
	// SCD parameters
	String surrogateKeyField = ElementParameterParser.getValue(node, "__SURROGATE_KEY__");
	String surrogateKeyCreation = ElementParameterParser.getValue(node, "__SK_CREATION__");
	String skSequence = ElementParameterParser.getValue(node, "__SK_DB_SEQUENCE__");
	String skInputField = ElementParameterParser.getValue(node, "__SK_INPUT_FIELD__");
	String skRoutine = ElementParameterParser.getValue(node, "__SK_ROUTINE__");
	String surrogateKeyDBField = null;
	for(IMetadataColumn column : metadata.getListColumns()) {
	    if(column.getLabel().equals(surrogateKeyField)) {
	        surrogateKeyDBField = column.getOriginalDbColumnName();
	        break;
	    }
	}
	
    List<Map<String, String>> sourceKeys =
        (List<Map<String, String>>) ElementParameterParser.getObjectValue(node, "__SOURCE_KEYS__");
	
    boolean useL1 = ElementParameterParser.getValue(node, "__USE_L1__").equals("true");
    List<Map<String, String>> l1fields = new ArrayList<Map<String, String>>();
    if (useL1) {
        l1fields = (List<Map<String, String>>) ElementParameterParser.getObjectValue(node, "__L1_FIELDS__");
    }
	
    boolean useL2 = ElementParameterParser.getValue(node, "__USE_L2__").equals("true");
    List<Map<String, String>> l2fields = new ArrayList<Map<String, String>>();
    if (useL2) {
        l2fields = (List<Map<String, String>>) ElementParameterParser.getObjectValue(node, "__L2_FIELDS__");
    }
	
    String startdateField = ElementParameterParser.getValue(node, "__L2_STARTDATE_FIELD__");
    String startdateValue = ElementParameterParser.getValue(node, "__L2_STARTDATE_VALUE__");
    String startdateInputField = ElementParameterParser.getValue(node, "__L2_STARTDATE_INPUT_FIELD__");
    String enddateField = ElementParameterParser.getValue(node, "__L2_ENDDATE_FIELD__");
    String enddateValue = ElementParameterParser.getValue(node, "__L2_ENDDATE_VALUE__");
    String enddateYear = ElementParameterParser.getValue(node, "__L2_ENDDATE_FIXED_VALUE__");
    String startDateDBField = null;
    String endDateDBField = null;
    for(IMetadataColumn column : metadata.getListColumns()) {
        if(column.getLabel().equals(startdateField)) {
            startDateDBField = column.getOriginalDbColumnName();
            break;
        }
    }
    for(IMetadataColumn column : metadata.getListColumns()) {
        if(column.getLabel().equals(enddateField)) {
            endDateDBField = column.getOriginalDbColumnName();
            break;
        }
    }
    
    boolean useActive = ElementParameterParser.getValue(node, "__USE_L2_ACTIVE__").equals("true");
    String activeField = ElementParameterParser.getValue(node, "__L2_ACTIVE_FIELD__");
    String activeDBField = null;
    for(IMetadataColumn column : metadata.getListColumns()) {
        if(column.getLabel().equals(activeField)) {
            activeDBField = column.getOriginalDbColumnName();
            break;
        }
    }    
    
    JavaType activeFieldType = null;
    for (IMetadataColumn column : metadata.getListColumns()) {
        if (column.getLabel().equals(activeField)) {
        	activeFieldType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
			break;
        }
    }
    
    boolean useVersion = ElementParameterParser.getValue(node, "__USE_L2_VERSION__").equals("true");
    String versionField = ElementParameterParser.getValue(node, "__L2_VERSION_FIELD__");
    String versionDBField = null;
    for(IMetadataColumn column : metadata.getListColumns()) {
        if(column.getLabel().equals(versionField)) {
            versionDBField = column.getOriginalDbColumnName();
            break;
        }
    }
    
	boolean useL3 = ElementParameterParser.getValue(node, "__USE_L3__").equals("true");
	List<Map<String, String>> l3fields = new ArrayList<Map<String, String>>();
    if (useL3) {
        l3fields = (List<Map<String, String>>) ElementParameterParser.getObjectValue(node, "__L3_FIELDS__");
    }
    
	// Build map with type (sk, L1, L2) of each column
    Map<String, String> typeOfColumn = new HashMap<String, String>();
    for(Map<String, String> sk : sourceKeys) {
        for(IMetadataColumn column : inMetadata.getListColumns()) {
            if(sk.get("NAME").equals(column.getLabel())) {
                typeOfColumn.put(column.getOriginalDbColumnName(), "SK");
                break;
            }
        }
    }
    for(Map<String, String> l1field : l1fields) {
        for(IMetadataColumn column : inMetadata.getListColumns()) {
            if(l1field.get("NAME").equals(column.getLabel())) {
                typeOfColumn.put(column.getOriginalDbColumnName(), "L1");
                break;
            }
        }
    }
    for(Map<String, String> l2field : l2fields) {
        for(IMetadataColumn column : inMetadata.getListColumns()) {
            if(l2field.get("NAME").equals(column.getLabel())) {
                typeOfColumn.put(column.getOriginalDbColumnName(), "L2");
                break;
            }
        }
    }
    for(Map<String, String> l3field : l3fields) {
        for(IMetadataColumn column : metadata.getListColumns()) {
            if(l3field.get("CURRENT_VALUE").equals(column.getLabel())) {
                typeOfColumn.put(column.getOriginalDbColumnName(), "L3C");
            } else if(l3field.get("PREV_VALUE").equals(column.getLabel())) {
                typeOfColumn.put(column.getOriginalDbColumnName(), "L3P");
            }
        }
    }    
	
	// Debug mode
	boolean debug = ElementParameterParser.getValue(node, "__DEBUG__").equals("true");
    
    %>
    java.sql.Timestamp timestamp_<%=cid%>;
	String value_<%=cid%>;
	
    // Source keys
    class SCDSK_<%=cid%> {
    	private int hashCode;
    	public boolean hashCodeDirty = true;
    	<%
		for (IMetadataColumn column : inMetadata.getListColumns()) {			
	        if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
		    	if (typeOfColumn.get(column.getOriginalDbColumnName()).equals("SK")) {
		        	%>
		        	private <%=JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable())%> <%=column.getOriginalDbColumnName()%>;
		        	<%
		        }
	        }
	    }
	    %>
	    
	    public boolean equals(Object o) {
	    	if (!(o instanceof SCDSK_<%=cid%>)) {
	    		return false;
	    	}
	    	
	    	SCDSK_<%=cid%> sk = (SCDSK_<%=cid%>) o;
	    	
	    	 <%
			boolean isFirstSK = true;
			boolean hasSourceKey = false;
            boolean returned =  false;
	    	for (IMetadataColumn column : inMetadata.getListColumns()) {				
		        if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
			    	if (typeOfColumn.get(column.getOriginalDbColumnName()).equals("SK")) {
		                JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
			        	String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
			            
			            if (isFirstSK) {
	                        isFirstSK = false;
	                    } else {
	                    	%> && <%
	                    }
		                
		                if (javaType == JavaTypesManager.DATE ||
		                	javaType == JavaTypesManager.OBJECT ||
		                	javaType == JavaTypesManager.STRING ||
	                		column.isNullable()) {
	                		 if(!returned){
	                            returned =  true;
	                             %>return <%
	                            }
							%><%=column.getOriginalDbColumnName()%>.equals(sk.<%=column.getOriginalDbColumnName()%>)<%
		                } else {
		                 if(!returned){
	                            returned =  true;
	                             %>return <%
	                            }
		                	%><%=column.getOriginalDbColumnName()%> == sk.<%=column.getOriginalDbColumnName()%><%
		                }
		                 hasSourceKey =  true;
			        }
		        }
		    }
		   	if(!hasSourceKey){
                %>return false;<%
            }else{
                %>;<%
            }
            %>
	    }
	    
	    public int hashCode() {
	    	if (hashCodeDirty) {
		    	int prime = 31;
		    	hashCode = 0;
		    	<%
		    	for (IMetadataColumn column : inMetadata.getListColumns()) {					
			        if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
				    	if (typeOfColumn.get(column.getOriginalDbColumnName()).equals("SK")) {
			                JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());			                
			                if (javaType == JavaTypesManager.DATE ||
			                	javaType == JavaTypesManager.OBJECT ||
			                	javaType == JavaTypesManager.STRING ||
			                	column.isNullable()) {
					    		%>
					    		hashCode = prime * hashCode + (<%=column.getOriginalDbColumnName()%> == null ? 0 : <%=column.getOriginalDbColumnName()%>.hashCode());
					    		<%
				    		} else {
				    			if (javaType == JavaTypesManager.LONG) {
				    			    %>
				    			    hashCode = prime * hashCode + (new Long(<%=column.getOriginalDbColumnName()%>)).hashCode();
				    			    <%
                                } else {
                                    %>
                                    hashCode = prime * hashCode + <%=column.getOriginalDbColumnName()%>;
                                    <%
					    		}
				    		}
				    	}
				   	}
				}
				%>
				hashCodeDirty = false;
			}
			
			return hashCode;
	    }
    }
    
    // Lookup cache structure
	class SCDStruct_<%=cid%> {
		<%
		// L1, L2, L3 fields
		for (IMetadataColumn column : metadata.getListColumns()) {			
	        if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
		    	if (!typeOfColumn.get(column.getOriginalDbColumnName()).equals("SK")) {
		        	%>
		        	private <%=JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable())%> <%=column.getOriginalDbColumnName()%>;
		        	<%
		        }
	        }
	    }
		
	    // Version field
	    if (useVersion) {
		    for (IMetadataColumn column : metadata.getListColumns()) {				
		        if (column.getLabel().equals(versionField)) {
			    	%>
					private <%=JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable())%> <%=column.getOriginalDbColumnName()%>;
					<%
					break;
		        }
		    }
		}
		%>
	}
	<%
	
    // Build lookup cache
    List<String> selectColumns = new ArrayList<String>();
    List<String> javaTypeColumns = new ArrayList<String>();
	
    // First we iterate on the input schema columns...
    for (IMetadataColumn column : metadata.getListColumns()) {		
        if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
            selectColumns.add(column.getOriginalDbColumnName());
            javaTypeColumns.add(JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()));
        }
    }
    
    if (useVersion) {
    	for (IMetadataColumn column : metadata.getListColumns()) {			
	        if (column.getOriginalDbColumnName().equals(versionDBField)) {
		        selectColumns.add(column.getOriginalDbColumnName());
				javaTypeColumns.add(JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()));
				break;
	        }
	    }
    }
    
	String[] selectColumnsArray = selectColumns.toArray(new String[selectColumns.size()]);
    String selectColumnsString = StringUtils.join(selectColumnsArray, ", ");
    
    %>
    // Retrieve active records
    String dbquery_<%=cid %> = "SELECT <%=selectColumnsString%> FROM " + <%=dbtable%>
    <%
    if (useL2) {
    	if (enddateValue.equals("NULL_VALUE")) {
	    	%>
			+ " WHERE <%=endDateDBField%> IS NULL"
			<%
		} else {
	    	%>
			+ " WHERE EXTRACT(YEAR FROM <%=endDateDBField%>) = " + <%=enddateYear%>
			<%
		}
    }
    %>;
	java.sql.Statement statement_<%=cid%> = connection_<%=cid%>.createStatement();
	java.sql.ResultSet resultSet_<%=cid%> = statement_<%=cid%>.executeQuery(dbquery_<%=cid %>);
	
    // Build lookup cache
    java.util.HashMap<SCDSK_<%=cid%>, SCDStruct_<%=cid%>> cache_<%=cid%> = new java.util.HashMap<SCDSK_<%=cid%>, SCDStruct_<%=cid%>>();
	
	while (resultSet_<%=cid%>.next()) {
		SCDSK_<%=cid%> sk_<%=cid%> = new SCDSK_<%=cid%>();
		SCDStruct_<%=cid%> row_<%=cid%> = new SCDStruct_<%=cid%>();
		<%
		int colPosition = 1;		
		for (int i = 0; i < selectColumns.size(); i++) {
			String colname = selectColumns.get(i);			
	        if (typeOfColumn.containsKey(colname) || colname.equals(versionDBField)) {
	            // Search Java type in order to call fitted method getXxx on ResultSet
	            String typeToGenerate = javaTypeColumns.get(i);
	            String struct = (!colname.equals(versionDBField) && typeOfColumn.get(colname).equals("SK") ? "sk_" : "row_") + cid;	            
	            if (typeToGenerate.equals("byte[]")) {
 	  	   			typeToGenerate = "Bytes";
				} else if (typeToGenerate.equals("java.util.Date")) {
					typeToGenerate = "Timestamp";
				} else if (typeToGenerate.equals("Integer")) {
					typeToGenerate = "Int";
				} else {
					typeToGenerate = typeToGenerate.substring(0, 1).toUpperCase() + typeToGenerate.substring(1);
				}		  		
				if (typeToGenerate.equals("Char") || typeToGenerate.equals("Character")) {
					%>
					value_<%=cid%> = resultSet_<%=cid%>.getString(<%=colPosition%>);
				  	if (value_<%=cid%> != null && value_<%=cid%>.length() > 0) {
				  		<%=struct%>.<%=colname%> = resultSet_<%=cid %>.getString(<%=colPosition%>).charAt(0);
				  	} else {
				  	    <%
				  	    if (typeToGenerate.equals("Character")) {
				  	    	%>
				  	    	if (value_<%=cid%> == null) {
				  	   			<%=struct%>.<%=colname%> = null;
					  		} else {
					  			<%=struct%>.<%=colname%> = '\0';
					  		}
				  			<%
				  		} else {
				  			%>
					  		if (value_<%=cid%>.equals("")) {
				  				<%=struct%>.<%=colname%> = '\0';
				  			} else {
					  			throw new RuntimeException("Value is empty for column : '<%=colname%>', value is invalid or this column should be nullable or have a default value.");
							}
				  			<%
				  		}
				  		%>
				  	}
					<%
				} else if (typeToGenerate.equals("Timestamp")) {
					%>
					timestamp_<%=cid%> = resultSet_<%=cid%>.getTimestamp(<%=colPosition%>);
					if (timestamp_<%=cid%> != null) {
						<%=struct%>.<%=colname%> = new java.util.Date(timestamp_<%=cid%>.getTime());
					} else {
						<%=struct%>.<%=colname%> = null;
					}
			 		<% 	
				} else {
					%>
					if (resultSet_<%=cid %>.getObject(<%=colPosition%>) != null) {
						<%=struct%>.<%=colname%> = resultSet_<%=cid %>.get<%=typeToGenerate%>(<%=colPosition%>);
 			 		}
 					<%
 			 	}
	            
	            colPosition++;
	        }
	    }
	    %>
	    
        cache_<%=cid%>.put(sk_<%=cid%>, row_<%=cid%>);
	}
	
	statement_<%=cid%>.close();
	
	<%
	if (surrogateKeyCreation.equals("TABLE_MAX")) {
		for (IMetadataColumn column : metadata.getListColumns()) {
	        String colname = column.getLabel();			
	        if (colname.equals(surrogateKeyField)) {
	            %>
	            <%=JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable())%> nextSurrogateKey_<%=cid%> = 1;
				<%
			}
		}
		%>
		if (cache_<%=cid%>.size() > 0) {
			// Get table max value for surrogate key
			dbquery_<%=cid%> = "SELECT MAX(<%=surrogateKeyDBField%>) FROM " + <%=dbtable%>;
			statement_<%=cid%> = connection_<%=cid%>.createStatement();
			resultSet_<%=cid%> = statement_<%=cid%>.executeQuery(dbquery_<%=cid%>);
			<%
	    	for (IMetadataColumn column : metadata.getListColumns()) {
		        String colname = column.getLabel();
				
		        if (colname.equals(surrogateKeyField)) {
		            // Search Java type in order to call fitted method getXxx on ResultSet
		            String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
		            
		            if (typeToGenerate.equals("Integer")) {
						typeToGenerate = "Int";
					} else {
						typeToGenerate = typeToGenerate.substring(0, 1).toUpperCase() + typeToGenerate.substring(1);
					}
			  		
					%>
					if (resultSet_<%=cid%>.next() && resultSet_<%=cid%>.getObject(1) != null) {
						nextSurrogateKey_<%=cid%> = resultSet_<%=cid%>.get<%=typeToGenerate%>(1) + 1;
	 			 	}
	 				<%
		        }
			}
			%>
			
			statement_<%=cid%>.close();
	    }
	    <%
	}
	
	if (debug) {
		%>
		System.out.println("[<%=cid%>] comparison cache loaded");
		<%
	}
	
    // INSERT query generation
    int colposition = 1;
    List<String> colnames = new ArrayList<String>();
    List<String> parameters = new ArrayList<String>();
	
	// Surrogate key
    boolean ifEqualWithSK = false;
    String skAndSourceKey = null;
    for(Map<String, String> sourceKeyMap : sourceKeys) {
        if(surrogateKeyField.equals(sourceKeyMap.get("NAME"))) {
            skAndSourceKey = surrogateKeyDBField;
            ifEqualWithSK = true;
            break;
        }
    }
    if(!surrogateKeyCreation.equals("AUTO_INCREMENT") && !surrogateKeyCreation.equals("DB_SEQUENCE")) {
        colnames.add(surrogateKeyDBField);
        parameters.add("?");
        colposition++;
    }    
    if(ifEqualWithSK) {
        for(IMetadataColumn column : metadata.getListColumns()) {
            if(typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
                if(!column.getOriginalDbColumnName().equals(skAndSourceKey)) {
                    colnames.add(column.getOriginalDbColumnName());
                    parameters.add("?");
                    colposition++;
                }
            }
        }
    } else {
        // First we iterate on the input schema columns...
        for (IMetadataColumn column : metadata.getListColumns()) {
            // ... and we add each column only if it was chosen to be in the
            // output, ie if its type was defined.
            if (typeOfColumn.containsKey(column.getOriginalDbColumnName())) {
                colnames.add(column.getOriginalDbColumnName());
                parameters.add("?");
                colposition++;
            }
        }        
    }    
		
    // Then we add L2 dedicated columns to store historical informations
    if (useL2) {
        if (useActive) {
        	colnames.add(activeDBField);
            if (activeFieldType == JavaTypesManager.STRING ||
            		activeFieldType == JavaTypesManager.BOOLEAN) {
	            parameters.add("'true'");
            } else {
            	parameters.add("1");
            }
        }
		
        if (useVersion) {
            colnames.add(versionDBField);
            parameters.add("?");
            colposition++;
        }
        
        colnames.add(startDateDBField);
        parameters.add("?");
		colposition++;
		
        colnames.add(endDateDBField);
        parameters.add(enddateValue.equals("NULL_VALUE") ? "NULL" : "TO_DATE('\" + " + enddateYear + " + \"-01-01', 'yyyy-mm-dd')");
    }
	
    String colnamesString = StringUtils.join(colnames.toArray(), ", ");
    String parametersString = StringUtils.join(parameters.toArray(), ", ");
    
    %>
    // Build prepared statements
    String insertQueryString_<%=cid%> = "INSERT INTO " + <%=dbtable%> + " (<%=surrogateKeyCreation.equals("DB_SEQUENCE") ? surrogateKeyDBField + ", " : ""%><%=colnamesString%>) " +
    	"VALUES (<%=surrogateKeyCreation.equals("DB_SEQUENCE") ? "\" + " + skSequence + " + \".nextval, " : ""%><%=parametersString%>)";
    java.sql.PreparedStatement insertQuery_<%=cid%> = connection_<%=cid%>.prepareStatement(insertQueryString_<%=cid%>);
    <%
    if (startdateValue.equals("JOB_START_TIME")) {
    	%>
	    insertQuery_<%=cid%>.setTimestamp(<%=colposition - 1%>,
	    	new java.sql.Timestamp(start_Hash.get("<%=cid%>")));
    	<%
    }
    
    // L1 query generation
    List keyClauses = new ArrayList();
	List l1fieldClauses = new ArrayList();
	
    for (IMetadataColumn column : metadata.getListColumns()) {
        String colname = column.getOriginalDbColumnName();		
        if (typeOfColumn.containsKey(colname)) {
            if (typeOfColumn.get(colname).equals("SK")) {
                keyClauses.add(colname + " = ?");
            } else if (typeOfColumn.get(colname).equals("L1")) {
            	l1fieldClauses.add(colname + " = ?");
            }
        }
    }
	
    String keyClausesString = StringUtils.join(keyClauses.toArray(), " AND ");
    String l1fieldClausesString = StringUtils.join(l1fieldClauses.toArray(), ", ");
    
    if (useL1) {
	    %>
	    String l1QueryString_<%=cid%> = "UPDATE " + <%=dbtable%> + " SET <%=l1fieldClausesString%> WHERE <%=keyClausesString%>";
	    java.sql.PreparedStatement l1Query_<%=cid%> = connection_<%=cid%>.prepareStatement(l1QueryString_<%=cid%>);
        <%
    }
    
    // L2 query generation
    if (useL2) {
		%>
		String l2QueryString_<%=cid%> = "UPDATE " + <%=dbtable%> + " " +
			"SET <%=endDateDBField%> = ? " +<%
		if (useActive) {
			%>
 			", <%=activeDBField%> = <%
 			if (activeFieldType == JavaTypesManager.STRING ||
            		activeFieldType == JavaTypesManager.BOOLEAN) {
	            %>'false'<%
            } else {
            	%>0<%
            }
            %> " +<%
	    }
	    %>
			"WHERE <%=keyClausesString%> " +
		<%
		if (enddateValue.equals("NULL_VALUE")) {
	    	%>
			" AND <%=endDateDBField%> IS NULL";
			<%
		} else {
	    	%>
			" AND EXTRACT(YEAR FROM <%=endDateDBField%>) = " + <%=enddateYear%>;
			<%
		}
		%>
	    java.sql.PreparedStatement l2Query_<%=cid%> = connection_<%=cid%>.prepareStatement(l2QueryString_<%=cid%>);
	    <%
	    if (startdateValue.equals("JOB_START_TIME")) {
	    	%>
		    l2Query_<%=cid%>.setTimestamp(1, new java.sql.Timestamp(start_Hash.get("<%=cid%>")));
	    	<%
	    }
	}
	
	// L3 query generation
	if (useL3) {
		List l3fieldClauses = new ArrayList();
		String prevLabel = null;
	    for (IMetadataColumn column : metadata.getListColumns()) {
	        String colname = column.getOriginalDbColumnName();			
	        if (typeOfColumn.containsKey(colname)) {
	            if (typeOfColumn.get(colname).equals("L3C")) {
	            	l3fieldClauses.add(colname + " = ?");
	            	
	            	// Search previous value field matching current value field
					for (Map<String, String> l3field : l3fields) {
						if (l3field.get("CURRENT_VALUE").equals(column.getLabel())) {
						    prevLabel = l3field.get("PREV_VALUE");
						    break;
						}
					}
					for(IMetadataColumn tmpColumn : metadata.getListColumns()) {
					    if(tmpColumn.getLabel().equals(prevLabel)) {
                            l3fieldClauses.add(
                                    tmpColumn.getOriginalDbColumnName() + " = ?");
                                break;					        
					    }
					}
	            }
	        }
	    }
		
	    String l3fieldClausesString = StringUtils.join(l3fieldClauses.toArray(), ", ");
	    
	    %>
	    String l3QueryString_<%=cid%> = "UPDATE " + <%=dbtable%> + " " +
	    	"SET <%=l3fieldClausesString%> " +
	    	"WHERE <%=keyClausesString%>"<%
	    if (useL2) {
	    	if (enddateValue.equals("NULL_VALUE")) {
		    	%>
				+ " AND <%=endDateDBField%> IS NULL";
				<%
			} else {
		    	%>
				+ " AND EXTRACT(YEAR FROM <%=endDateDBField%>) = " + <%=enddateYear%>;
				<%
			}
		}
		%>;
	    java.sql.PreparedStatement l3Query_<%=cid%> = connection_<%=cid%>.prepareStatement(l3QueryString_<%=cid%>);
	    <%
	}
	
	%>
	SCDSK_<%=cid%> lookupRow_<%=cid%> = new SCDSK_<%=cid%>();
	SCDStruct_<%=cid%> cacheRow_<%=cid%> = null;
    <%
} else {
	%>
	// No code generated: define input and output schema first
	<%
}
%>
