<%@ jet 
	imports="
	java.util.ArrayList
	java.util.Collections
	java.util.Comparator
	java.util.List
	java.util.HashMap
	java.util.Map
	java.util.HashSet
	java.util.Set
	org.talend.designer.codegen.config.CodeGeneratorArgument
	org.talend.commons.utils.generation.CodeGenerationUtils
	org.talend.designer.mapper.MapperMain
	org.talend.designer.mapper.MapperComponent
	org.talend.designer.mapper.external.data.ExternalMapperData
	org.talend.designer.mapper.external.data.ExternalMapperTable
	org.talend.designer.mapper.external.data.ExternalMapperTableEntry
	org.talend.designer.mapper.language.ILanguage
	org.talend.designer.mapper.language.generation.GenerationManagerFactory
	org.talend.designer.mapper.language.generation.JavaGenerationManager
	org.talend.designer.mapper.language.generation.HashedMetadataTable
	org.talend.designer.mapper.language.LanguageProvider
	org.talend.designer.mapper.model.tableentry.TableEntryLocation
	org.talend.designer.mapper.utils.DataMapExpressionParser
	org.talend.core.model.process.IConnection
	org.talend.core.model.process.EConnectionType
	org.talend.designer.mapper.language.generation.TableType
	org.talend.core.model.metadata.IMetadataTable
	org.talend.core.model.metadata.IMetadataColumn
	org.talend.core.model.metadata.MetadataTalendType
	org.talend.core.model.metadata.types.JavaTypesManager
	org.talend.core.model.metadata.types.JavaType
	org.talend.core.model.process.BlockCode
	org.talend.core.model.process.IMatchingMode
	" 
%>
<%


	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	MapperComponent node = (MapperComponent) codeGenArgument.getArgument();
	boolean stats = codeGenArgument.isStatistics(); 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
        ILanguage currentLanguage = LanguageProvider.getJavaLanguage();
        
        List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();
        List<IConnection> outputConnections = (List<IConnection>) node.getOutgoingConnections();
        ExternalMapperData data = (ExternalMapperData) node.getExternalData();
        String uniqueNameComponent = node.getUniqueName();
        boolean checkingSyntax = codeGenArgument.isCheckingSyntax();

        String cr = "\n";
        String rejected = "rejected_" + uniqueNameComponent;
        String rejectedInnerJoin = "rejectedInnerJoin_" + uniqueNameComponent;

        List<ExternalMapperTable> inputTables = data.getInputTables();
        List<ExternalMapperTable> varsTables = data.getVarsTables();
        List<ExternalMapperTable> outputTables = data.getOutputTables();

        int indent = 1;

		boolean isPersistent = true;

        DataMapExpressionParser expressionParser = new DataMapExpressionParser(currentLanguage);

        JavaGenerationManager gm = (JavaGenerationManager) node.initGenerationManager();

        gm.setInputTables(inputTables);
        gm.setVarsTables(varsTables);

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // INPUTS : initialization of input arrays from expressions keys and hashes
        // 
        
        HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
        for (IConnection connection : inputConnections) {
            hNameToConnection.put(connection.getName(), connection);
        }
        
        HashMap<String, ExternalMapperTableEntry> hExternalInputTableEntries = new HashMap<String, ExternalMapperTableEntry>();
		int sizeInputTables = inputTables.size();

		ExternalMapperTable mainInputTable = null;
		String mainInputTableName = null;
		
		if(sizeInputTables > 0) { // T_TM_M_199

			ExternalMapperTable externalTable = inputTables.get(0);
            String tableName = externalTable.getName();
            IConnection connection = hNameToConnection.get(tableName);
            EConnectionType connectionType = connection.getLineStyle();
            if (connectionType == EConnectionType.FLOW_MAIN) {
            	mainInputTable = externalTable;
            	mainInputTableName = mainInputTable.getName();
            }

		} // T_TM_M_199

		String nextLookupName = null;
		List<IMetadataColumn> nextLookupColumnsKeys = new ArrayList<IMetadataColumn>();

		if(sizeInputTables > 1) { // T_TM_M_200
			for (int iInputTable = 1; iInputTable < sizeInputTables - 1; iInputTable++) { // T_TM_M_201
				ExternalMapperTable inputTable = inputTables.get(iInputTable);
            	String tableName = inputTable.getName();
            	IConnection connection = hNameToConnection.get(tableName);
            	if (connection == null) {
	                continue;
            	}
            	//EConnectionType connectionType = connection.getLineStyle();
	            
            	IMetadataTable metadataTable = connection.getMetadataTable();
            	if (inputTable != null) { // T_TM_M_205
	                hExternalInputTableEntries.clear();
                	List<ExternalMapperTableEntry> metadataTableEntries = inputTable.getMetadataTableEntries();
                	if (metadataTableEntries == null) {
	                    continue;
                	}
                	nextLookupName = inputTable.getName();
                	for (ExternalMapperTableEntry externalTableEntry : metadataTableEntries) {
	                    hExternalInputTableEntries.put(externalTableEntry.getName(), externalTableEntry);
                	}
                	List<IMetadataColumn> listColumns = metadataTable.getListColumns();
                	for (IMetadataColumn column : listColumns) { // T_TM_M_204
	                    String columnName = column.getLabel();
                    	ExternalMapperTableEntry externalInputTableEntry = hExternalInputTableEntries.get(columnName);
                    	if (externalInputTableEntry != null) { // T_TM_M_203
	                        String expressionKey = externalInputTableEntry.getExpression();
                        	if (expressionKey != null && !"".equals(expressionKey.trim())) { // T_TM_M_202
                        		nextLookupColumnsKeys.add(column);
					            String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
				                JavaGenerationManager.PROBLEM_KEY_FIELD.METADATA_COLUMN.toString(), tableName, columnName);
            					if (checkingSyntax) {
    	        				%>
 	           						<%= CodeGenerationUtils.buildJavaStartFieldKey(key) %>
        	    				<%
            					}
					            %>
					            <%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= tableName %>__<%= column.getLabel() %> = <%= expressionKey %>;
            					<%
            					if (checkingSyntax) {
                				%>
                					<%= CodeGenerationUtils.buildJavaEndFieldKey(key) %>
            				    <%
            					}
							} // T_TM_M_202
                        } // T_TM_M_203
                    } // T_TM_M_204
					break;
				} // T_TM_M_205
             } // T_TM_M_201
          } // T_TM_M_200
		
        %>

                    SortableRow_<%= mainInputTableName %> rsc_<%= mainInputTableName %> = new SortableRow_<%= mainInputTableName %>();

                    rsc_<%= mainInputTableName %>.fillFrom(<%= mainInputTableName %><%
                    
                    for (IMetadataColumn column : nextLookupColumnsKeys) {
                    	String columnName = column.getLabel();
                    	%>, exprKey_<%= nextLookupName %>__<%=column.getLabel() %><%
                    }
                    %>);

                    fsi_<%= mainInputTableName %>.put(null, rsc_<%= mainInputTableName %>);

                }// End of branch temporary "<%= mainInputTableName %>"

            } // end temporary main loop

            fsi_<%= mainInputTableName %>.endPut();

            boolean rejectedInnerJoin_tMap_1 = false;

            org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator fsi_Join_M__LF1 = new org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator();
            org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator fsi_Join_M__LF1__LF2 = new org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator();

            // org.talend.designer.components.thash.io.IPersistentJoiner<V> fsi_Join_M__LF1 = null;//new
            // org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator();
            // org.talend.designer.components.thash.io.IPersistentJoiner<V> fsi_Join_M__LF1__LF2 = null;//new
            // org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator();


        // ###############################
        // # Input tables (lookups)
        <%

        ArrayList<ExternalMapperTable> inputTablesWithInnerJoin = new ArrayList<ExternalMapperTable>();
        ArrayList<ExternalMapperTable> lookupTables = new ArrayList<ExternalMapperTable>();
        boolean hasValidLookupTables = false;

		  int closeBracketCounter = 0;
		%>
		  boolean <%= rejectedInnerJoin %> = false;
            				    								  
		<%

		String previousLookupName = null;
		String previousTableName = mainInputTableName;

		String currentJoinedTableNames = mainInputTableName;
		String nextJoinedTableNames = mainInputTableName;

		List<IConnection> cumulatedInputConnections = new ArrayList<IConnection>();

		sizeInputTables = inputTables.size();
        for (int iInputTable = 0; iInputTable < sizeInputTables; iInputTable++) {
			ExternalMapperTable externalTable = inputTables.get(iInputTable);
			
			boolean nextTableIsLast = iInputTable + 1 == sizeInputTables - 1;
			boolean isLastTable = (iInputTable == sizeInputTables - 1);
			boolean isBeforeOfThirdTable = (iInputTable < 2);
			
			
            String tableName = externalTable.getName();
            IConnection connection = hNameToConnection.get(tableName);
            if (connection == null) {
                continue;
            }
            EConnectionType connectionType = connection.getLineStyle();
            
            if (connectionType == EConnectionType.FLOW_MAIN) {
            
            		cumulatedInputConnections.add(connection);
            
			  	  	   if(externalTable.isActivateExpressionFilter() && externalTable.getExpressionFilter() != null && !externalTable.getExpressionFilter().trim().equals("")) { 

		                String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
   	                     JavaGenerationManager.PROBLEM_KEY_FIELD.FILTER.toString(), tableName);
					  	  	 %>
		              
			   	  		  if(
 				  		  			<%= checkingSyntax ? CodeGenerationUtils.buildJavaStartFieldKey(key) : "" %>
 				  		  			!(
 				  		  			<%// keep this line to allow comments in filter %>
 				  		  			<%= externalTable.getExpressionFilter()%>
 				  		  			<%// keep this line to allow comments in filter %>
 				  		  			)
  				  		  			<%= checkingSyntax ? CodeGenerationUtils.buildJavaEndFieldKey(key) : "" %>
	  	  		  				) {
		      	  				continue;
		    		  	  	   }
		    	  	  	  
				 	  	   <%
			 	  	   }
                  continue;
                  
            } else if (connectionType == EConnectionType.FLOW_REF) { // T_TM_M_249



                IMetadataTable metadataTable = connection.getMetadataTable();
                if (externalTable != null) {
                    if (externalTable.isInnerJoin()) {
                        inputTablesWithInnerJoin.add(externalTable);
                    }
                    lookupTables.add(externalTable);
                    hExternalInputTableEntries.clear();
                    List<ExternalMapperTableEntry> metadataTableEntries = externalTable.getMetadataTableEntries();
                    if (metadataTableEntries == null) {
                        continue;
                    }


            if(isPersistent) {
					nextJoinedTableNames += "__" + tableName; 

			%>
			
				tHash_Lookup_<%= tableName %>.initGet();
			
				SortableRow_<%= currentJoinedTableNames %> rsc_<%= currentJoinedTableNames %>;

				<%
				if(!previousTableName.equals(mainInputTableName)) {
				%>

	       			<%= previousTableName %>Struct <%= previousTableName %> = new <%= previousTableName %>Struct();
	       			
				<%
				}
				%>
			
	           	while (fsi_<%= currentJoinedTableNames %>.hasNext()) { // G_TM_M_250 loop "<%= currentJoinedTableNames %>"
				
					rsc_<%= currentJoinedTableNames %> = (SortableRow_<%= currentJoinedTableNames %>) fsi_<%= currentJoinedTableNames %>.next();
               		rsc_<%= currentJoinedTableNames %>.copyDataTo(<%
               		
               			String comma = "";
		         		for(IConnection aConnection : cumulatedInputConnections) {
			         		%><%=comma%> <%= aConnection.getName() %><%
		         			comma = ", ";
		         		}
               		
               		%>);
               		
			<%
			}


                    for (ExternalMapperTableEntry externalTableEntry : metadataTableEntries) {
                        hExternalInputTableEntries.put(externalTableEntry.getName(), externalTableEntry);
                    }
                    List<IMetadataColumn> listColumns = metadataTable.getListColumns();
                    ArrayList<String> keysNames = new ArrayList<String>();
                    ArrayList<String> keysValues = new ArrayList<String>();
                    for (IMetadataColumn column : listColumns) {
                        String columnName = column.getLabel();
                        ExternalMapperTableEntry externalInputTableEntry = hExternalInputTableEntries.get(columnName);
                        if (externalInputTableEntry != null) {
                            String expressionKey = externalInputTableEntry.getExpression();
                            if (expressionKey != null && !"".equals(expressionKey.trim())) {
                                keysNames.add(columnName);
                                keysValues.add(expressionKey);
                            }
                        }
                    }
                    String[] aKeysNames = keysNames.toArray(new String[0]);
                    String[] aKeysValues = keysValues.toArray(new String[0]);
    		           
    		        String className = tableName + "Struct";

                    hasValidLookupTables = true;
                    
                     String matchingMode = externalTable.getMatchingMode();
					if(matchingMode == null) {
						if(aKeysValues.length > 0) {
							matchingMode = "UNIQUE_MATCH";
						} else {
							matchingMode = "ALL_ROWS";
						}
					}
                     boolean isMultipleResultMode = matchingMode.equals("ALL_ROWS") || matchingMode.equals("ALL_MATCHES");
                     %>
                            
 					    boolean forceLoop<%= tableName %> = false;
       		  	    	
       		  	    	<%
       		  	    	
       		  	    	
       		  	    	String beforeMatchFilter = null;
       		  	    	
                        %>
 							<%= className %> <%= tableName %>ObjectFromLookup = null;
                          
		           		  	if(!<%= rejectedInnerJoin %><%
		           		  		
		           		  		if (beforeMatchFilter != null) { // T 101
   	                    				%> && <%= beforeMatchFilter %><%
           		  	    			} // T 101
		           		  	    
		           		  	 %>) { // G 20

								<% 
                        		if(!isPersistent && (aKeysValues.length > 0 || checkingSyntax)) { // T 001


                        		for (int iKeyName = 0; iKeyName < aKeysNames.length; iKeyName++) {

                        		    String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
                        		    JavaGenerationManager.PROBLEM_KEY_FIELD.METADATA_COLUMN.toString(), tableName, aKeysNames[iKeyName]);
                        		    if (checkingSyntax) {
    	                        		%>
 	                        		   <%= CodeGenerationUtils.buildJavaStartFieldKey(key) %>
                        			    <%
                        		    }

                        		    String expression = tableName + "HashKey." + aKeysNames[iKeyName] + " = " + aKeysValues[iKeyName] + ";";
                        		    %>
                        		    <%= expression %>
                        		    <%
                        		    if (checkingSyntax) {
                        		    	%>
                        		        <%= CodeGenerationUtils.buildJavaEndFieldKey(key) %>
                        		        <%
                        		    }
                        		}


                        		} // T 001
                        		%>

								<% 
                        		if(!isPersistent && aKeysValues.length > 0) { // T 002
                        		%>
		                        	<%=tableName%>HashKey.hashCodeDirty = true;
                        		<%
                        		} // T 002
                        		%>
	  					
	  							tHash_Lookup_<%= tableName %>.lookup( <%= tableName %>HashKey );

								if(!tHash_Lookup_<%= tableName %>.hasNext()) { // G 090
		  				
		  							<%
		  							if(externalTable.isInnerJoin()) {
		  							%>
			  							<%= rejectedInnerJoin %> = true;
		  							<%
	  								}
	  								%>
						
									<%if(isMultipleResultMode) { // T 56 %>
	
		  								forceLoop<%= tableName %> = true;
		  					
	  								<% } // T 56 %>
  									  		
  									  

		  						} // G 090
	  								
							} // G 20
			           		  	  
							<%
							if(isMultipleResultMode) { // T 57 
							%>
								
								else { // G 20 - G 21
   									forceLoop<%= tableName %> = true;
			           		  	} // G 21
                    		  	
                    		<%
							} // T 57

							if(matchingMode.equals("UNIQUE_MATCH")) { // T 52 
							%>
				           		if(tHash_Lookup_<%= tableName %>.getCount(<%= tableName %>HashKey) > 1) { // G 071
			  							
			  						<%
			  						StringBuilder sbMoreOneResult = new StringBuilder("\"WARNING: UNIQUE MATCH is configured for the lookup '"+ tableName +"' and it contains more one result from keys : ");
			  						for(int iKeys = 0; iKeys < aKeysNames.length; iKeys++) {
			  							if(iKeys > 0) {
					  						sbMoreOneResult.append(",");
			  						 	}
				  						sbMoreOneResult.append( " " + tableName + "."+ aKeysNames[iKeys] + " = '\" + " + tableName + "HashKey."+ aKeysNames[iKeys] + " + \"'");
									}
			  						sbMoreOneResult.append( "\"");
									%>
									 		
									System.out.println(<%= sbMoreOneResult.toString()%>);
								} // G 071
							<% 
							} // T 52 
							%>

							<%= tableName %>Struct <%= tableName %> = null;
                    		  	 
							<%
							if(isMultipleResultMode) { // T 60
							%>

								while (tHash_Lookup_<%= tableName %>.hasNext() || forceLoop<%= tableName %>) { // G_TM_M_043

								<%
								if(!isPersistent) {
									gm.addBlocksCodeToClose(new BlockCode("close loop of lookup '" + tableName +"' // G_TM_M_043"));
								}
								%>
                    		  	 
							<% } // T 60 %>   
                    		  	 
							<%= tableName %>Struct fromLookup_<%= tableName %> = null;
							<%= tableName %> = <%= tableName %>Default;
										 
							<% 
							if (isMultipleResultMode) { // T 69 
							%>
								
								if(!forceLoop<%= tableName %>) { // G 46
								
							<%
							} // T 69
		                    %>
								 
							<%
							if (!isMultipleResultMode) { // T 600
                    		%>
							
								if (tHash_Lookup_<%= tableName %>.hasNext()) { // G 099
								
							<%
							} // T 600
                    		%>
								
								fromLookup_<%= tableName %> = tHash_Lookup_<%= tableName %>.next();

							<%
							if (!isMultipleResultMode) { // T 601
							%>
							
								} // G 099
							
							<%
							} // T 601
							%>

							if(fromLookup_<%= tableName %> != null) {
								<%= tableName %> = fromLookup_<%= tableName %>;
							}
			  							
							<%
							if(
								externalTable.isActivateExpressionFilter() 
								&& externalTable.getExpressionFilter() != null 
								&& !externalTable.getExpressionFilter().trim().equals("")
							) { // T 012 
                    		  	  	   		
								String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
								JavaGenerationManager.PROBLEM_KEY_FIELD.FILTER.toString(), tableName);
								%>
                    		  	  		
								if( !<%= rejectedInnerJoin %> && 
									<%= checkingSyntax ? CodeGenerationUtils.buildJavaStartFieldKey(key) : "" %>
									!(
										<%// keep this line to allow comments in filter %>
										<%= externalTable.getExpressionFilter()%>
										<%// keep this line to allow comments in filter %>
									)
									<%= checkingSyntax ? CodeGenerationUtils.buildJavaEndFieldKey(key) : "" %>
								) { // G 016
                    		  	  		  
									fromLookup_<%= tableName %> = null;
									<%= tableName %> = <%= tableName %>Default;
                    		  	  		  		
									<%
									if(externalTable.isInnerJoin()) { // G 058
									%>
									
										<%= rejectedInnerJoin %> = true;
													
									<%
									} // G 058
									%>
								} // G 016
     	               		  	
								<%
								if(aKeysValues.length == 0){ // T 081
								%>
								
									if(fromLookup_<%= tableName %> == null && !<%= rejectedInnerJoin %>) { // G 017
								
										continue;
									
									} // G 017
								
								<%
								} // T 081
								%>
     	               		  	  	  
							<%
							} // T 012
							%>	
	                    		  	
		                    <%
		                    if(isMultipleResultMode) { // T 70 
		                    %>
	                    	
	                    		} // G 46
	                    		  	
								forceLoop<%= tableName %> = false;
									 	
							<%
							} // T 70


                if(isPersistent && !isLastTable) {
                	if(isBeforeOfThirdTable) {
					%>
	            		}  // G_TM_M_043 loop <%= tableName %>
					<%
					}

			ExternalMapperTable nextInputTable = inputTables.get(iInputTable + 1);
			if(!isLastTable) { // T_TM_M_216
				nextLookupColumnsKeys.clear();
            	String nextTableName = nextInputTable.getName();
            	IConnection nextConnection = hNameToConnection.get(nextTableName);
            	if (nextConnection == null) {
	                continue;
            	}
            	//EConnectionType connectionType = nextConnection.getLineStyle();
	            
            	IMetadataTable nextMetadataTable = nextConnection.getMetadataTable();
            	if (nextInputTable != null) { // T_TM_M_215
	                hExternalInputTableEntries.clear();
                	List<ExternalMapperTableEntry> nextMetadataTableEntries = nextInputTable.getMetadataTableEntries();
                	if (nextMetadataTableEntries == null) {
	                    continue;
                	}
                	nextLookupName = nextInputTable.getName();
                	for (ExternalMapperTableEntry externalTableEntry : nextMetadataTableEntries) {
	                    hExternalInputTableEntries.put(externalTableEntry.getName(), externalTableEntry);
                	}
                	List<IMetadataColumn> nextListColumns = nextMetadataTable.getListColumns();
                	for (IMetadataColumn column : nextListColumns) { // T_TM_M_214
	                    String columnName = column.getLabel();
                    	ExternalMapperTableEntry externalInputTableEntry = hExternalInputTableEntries.get(columnName);
                    	if (externalInputTableEntry != null) { // T_TM_M_213
	                        String expressionKey = externalInputTableEntry.getExpression();
                        	if (expressionKey != null && !"".equals(expressionKey.trim())) { // T_TM_M_212
                        		nextLookupColumnsKeys.add(column);
					            String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
				                JavaGenerationManager.PROBLEM_KEY_FIELD.METADATA_COLUMN.toString(), nextTableName, columnName);
            					if (checkingSyntax) {
    	        				%>
 	           						<%= CodeGenerationUtils.buildJavaStartFieldKey(key) %>
        	    				<%
            					}
					            %>
					            <%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= nextTableName %>__<%= column.getLabel() %> = <%= expressionKey %>;
            					<%
            					if (checkingSyntax) {
                				%>
                					<%= CodeGenerationUtils.buildJavaEndFieldKey(key) %>
            				    <%
            					}
							} // T_TM_M_212
                        } // T_TM_M_213
                    } // T_TM_M_214
				} // T_TM_M_215

           		cumulatedInputConnections.add(connection);
				currentJoinedTableNames = nextJoinedTableNames;

				%>

					SortableRow_<%= currentJoinedTableNames %> rsc_<%= currentJoinedTableNames %> = new SortableRow_<%= currentJoinedTableNames %>();

					rsc_<%= currentJoinedTableNames %>.fillFrom(<%

				        String comma = "";
		         		for(IConnection aConnection : cumulatedInputConnections) {
				        	%><%=comma%> <%= aConnection.getName() %><%
			         		comma = ", ";
		         		}
                    	int sizeNextColumns = nextLookupColumnsKeys.size();
                    	for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { // T_TM_M_105
	                    	IMetadataColumn column = nextLookupColumnsKeys.get(iColumn);
	
		         			%><%=comma%> exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %><%
	                    
                    	} // T_TM_M_105
					
					%>);

					// Sort and store in KeyFile(s) and DataFile(s)
					fsi_<%= currentJoinedTableNames %>.put(null, rsc_<%= currentJoinedTableNames %>);
					
				<%


			} // T_TM_M_216


	    		
					%>
	            	} // G_TM_M_250 loop "<%= currentJoinedTableNames %>"
	            	
					<%
				}

            	previousTableName = tableName;



                } // if(externalTable != null) {

            } // T_TM_M_249 else if(connectionType == EConnectionType.FLOW_REF) {
            
            
            
        } // for (ExternalMapperTable externalTable : inputTables) {
        boolean atLeastOneInputTableWithInnerJoin = !inputTablesWithInnerJoin.isEmpty();


		%>
		{ // Dummy bracket to open block for "<%= mainInputTableName %>"
		<%


        %>// ###############################
        <%
        
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // VARIABLES
        // 
        
        %>
        { // start of Var scope
        
	        // ###############################
        	// # Vars tables
        
        <%
        
        for (ExternalMapperTable varsTable : varsTables) {
            List<ExternalMapperTableEntry> varsTableEntries = varsTable.getMetadataTableEntries();
            if (varsTableEntries == null) {
                continue;
            }
            String varsTableName = varsTable.getName();
            String instanceVarName = varsTableName + "__" + uniqueNameComponent;
            String className = instanceVarName + "__Struct";

            %><%= cr + className + " " + varsTableName + " = " + instanceVarName + ";" %><%
            
            for (ExternalMapperTableEntry varsTableEntry : varsTableEntries) {
                String varsColumnName = varsTableEntry.getName();
                String varExpression = varsTableEntry.getExpression();
                if (varExpression == null || varExpression.trim().length() == 0) {
                    varExpression = JavaTypesManager.getDefaultValueFromJavaIdType(varsTableEntry.getType(),
                            varsTableEntry.isNullable());
                }
                TableEntryLocation[] entryLocations = expressionParser.parseTableEntryLocations(varExpression);
                ArrayList<TableEntryLocation> listCoupleForAddTablePrefix = new ArrayList<TableEntryLocation>();
                for (TableEntryLocation location : entryLocations) {
                    if (gm.isInputTable(varExpression)) {
                        listCoupleForAddTablePrefix.add(location);
                    }
                }

                String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
                        JavaGenerationManager.PROBLEM_KEY_FIELD.METADATA_COLUMN.toString(), varsTableName,
                        varsColumnName);

                if (checkingSyntax) {
                    %><%= cr  + CodeGenerationUtils.buildJavaStartFieldKey(key) %><%
                }

                %><%= cr + gm.getGeneratedCodeTableColumnVariable(uniqueNameComponent, varsTableName, varsColumnName, false) + " = " + varExpression
                        + ";" %><%

                if (checkingSyntax) {
                    %><%= cr + CodeGenerationUtils.buildJavaEndFieldKey(key)%><%
                }

            }
        }
        
        %>// ###############################<%
        
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////

        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////////////////////////////////////
        // OUTPUTS
        // 
        
        %>
        // ###############################
        // # Output tables
        <%

		StringBuilder sb = new StringBuilder();

        ArrayList<ExternalMapperTable> outputTablesSortedByReject = new ArrayList<ExternalMapperTable>(outputTables);
        // sorting outputs : rejects tables after not rejects table
        Collections.sort(outputTablesSortedByReject, new Comparator<ExternalMapperTable>() {

            public int compare(ExternalMapperTable o1, ExternalMapperTable o2) {
                if (o1.isReject() != o2.isReject()) {
                    if (o1.isReject()) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                if (o1.isRejectInnerJoin() != o2.isRejectInnerJoin()) {
                    if (o1.isRejectInnerJoin()) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                return 0;
            }

        });

        boolean lastValueReject = false;
        boolean oneFilterForNotRejectTable = false;
        boolean allNotRejectTablesHaveFilter = true;
        boolean atLeastOneReject = false;
        boolean atLeastOneRejectInnerJoin = false;
        boolean closeTestInnerJoinConditionsBracket = false;

        Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
        for (IConnection outputConnection : outputConnections) {
            nameToOutputConnection.put(outputConnection.getName(), outputConnection);
        }

        int lstSizeOutputs = outputTablesSortedByReject.size();
        // ///////////////////////////////////////////////////////////////////
        // init of allNotRejectTablesHaveFilter and atLeastOneReject
        String lastValidOutputTableName = null;
        for (int i = 0; i < lstSizeOutputs; i++) {
            ExternalMapperTable outputTable = (ExternalMapperTable) outputTablesSortedByReject.get(i);

            String outputTableName = outputTable.getName();

            if (outputTable.isRejectInnerJoin()) {
                atLeastOneRejectInnerJoin = true;
            }
            List<ExternalMapperTableEntry> columnsEntries = outputTable.getMetadataTableEntries();
            List<ExternalMapperTableEntry> filters = outputTable.getConstraintTableEntries();
            boolean hasFilter = filters != null && filters.size() > 0 && !gm.checkFiltersAreEmpty(outputTable) 
            	|| outputTable.isActivateExpressionFilter() && outputTable.getExpressionFilter() != null && !outputTable.getExpressionFilter().trim().equals("");
            if (columnsEntries != null && columnsEntries.size() > 0) {
                if (!hasFilter && !(outputTable.isReject() || outputTable.isRejectInnerJoin())) {
                    allNotRejectTablesHaveFilter = false;
                }
                if (outputTable.isReject()) {
                    atLeastOneReject = true;
                }
            }

			IConnection outputConnection = nameToOutputConnection.get(outputTableName);
            if (outputConnection != null) {
                sb.append(cr + outputTableName + " = null;");
            }
                if(checkingSyntax 
                || !checkingSyntax && outputConnection != null) {
	            	lastValidOutputTableName = outputTableName;
	            }

        }
        // ///////////////////////////////////////////////////////////////////

		// System.out.println(uniqueNameComponent + " lastValidOutputTableName="+lastValidOutputTableName);

        sb.append(cr);

        if (allNotRejectTablesHaveFilter && atLeastOneReject) {
            // write rejected = false;
            sb.append(cr + "boolean " + rejected + " = true;");
        }

        // write conditions for inner join reject
        if (lastValidOutputTableName != null && hasValidLookupTables && lstSizeOutputs > 0 && atLeastOneInputTableWithInnerJoin) {
            sb.append(cr + "if(");
            sb.append("!" + rejectedInnerJoin);
            sb.append(" ) {");
            closeTestInnerJoinConditionsBracket = true;
        }

        // ///////////////////////////////////////////////////////////////////
        // run through output tables list for generating intilization of outputs arrays
        int dummyVarCounter = 0;
        for (int indexCurrentTable = 0; indexCurrentTable < lstSizeOutputs; indexCurrentTable++) {
            ExternalMapperTable outputTable = (ExternalMapperTable) outputTablesSortedByReject.get(indexCurrentTable);
            List<ExternalMapperTableEntry> outputTableEntries = outputTable.getMetadataTableEntries();
            String outputTableName = outputTable.getName();
            boolean connectionExists = true;
            IConnection outputConnection = nameToOutputConnection.get(outputTableName);
            HashedMetadataTable hashedMetadataTable = null;
            if (outputTableEntries == null || outputConnection == null) {
                connectionExists = false;
            } else {
            	hashedMetadataTable = new HashedMetadataTable(outputConnection.getMetadataTable());
            }

			// System.out.println("Output table: (1)" + outputTableName);

            List<ExternalMapperTableEntry> filters = outputTable.getConstraintTableEntries();

            boolean currentIsReject = outputTable.isReject();
            boolean currentIsRejectInnerJoin = outputTable.isRejectInnerJoin();

            boolean hasFilters = filters != null && filters.size() > 0 && !gm.checkFiltersAreEmpty(outputTable);
            boolean hasExpressionFilter = outputTable.isActivateExpressionFilter() && outputTable.getExpressionFilter() != null && !outputTable.getExpressionFilter().trim().equals("");

            boolean rejectValueHasJustChanged = lastValueReject != (currentIsReject || currentIsRejectInnerJoin);

            oneFilterForNotRejectTable = !(currentIsReject || currentIsRejectInnerJoin) && (hasFilters || hasExpressionFilter);

            if (rejectValueHasJustChanged) {

                if (closeTestInnerJoinConditionsBracket) {
                    indent--;
                    sb.append(cr + "} // closing inner join bracket (1)");
                    if (atLeastOneReject && allNotRejectTablesHaveFilter) {
                        sb.append(cr + " else {");
                        indent++;
                        sb.append(cr + rejected + " = false;");
                        indent--;
                        sb.append(cr + "} // closing else inner join bracket (1)");
                    }
                    closeTestInnerJoinConditionsBracket = false;
                }
            }

            // No connection matching and no checking errors
            if (connectionExists || checkingSyntax) {
	            if (rejectValueHasJustChanged) {
	                sb.append(cr + "// ###### START REJECTS ##### ");
	            }

	            // write filters conditions and code to execute
	            if (!currentIsReject && !currentIsRejectInnerJoin || rejectValueHasJustChanged
	                    && oneFilterForNotRejectTable || currentIsReject && allNotRejectTablesHaveFilter
	                    || currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin || checkingSyntax) {

	                boolean closeFilterOrRejectBracket = false;
	                if (currentIsReject || currentIsRejectInnerJoin) {
	                    sb.append(cr + cr + "// # Output reject table : '" + outputTableName + "'");
	                } else {
	                    sb.append(cr + cr + "// # Output table : '" + outputTableName + "'");
	                }
	                if (hasFilters || hasExpressionFilter || currentIsReject || currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin) {
	                    sb.append(cr + "// # Filter conditions ");
	
	                    String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
	                            JavaGenerationManager.PROBLEM_KEY_FIELD.FILTER.toString(), outputTableName, null);
	                    if (checkingSyntax) {
	                        sb.append("\n").append(CodeGenerationUtils.buildJavaStartFieldKey(key));
	                    }
	
	                    String ifConditions = "if( ";
	
	                    String rejectedTests = null;
	                    if (allNotRejectTablesHaveFilter && atLeastOneReject && currentIsReject && currentIsRejectInnerJoin
	                            && atLeastOneInputTableWithInnerJoin) {
	                        rejectedTests = rejected + " || " + rejectedInnerJoin;
	                        if (hasFilters || hasExpressionFilter) {
	                            rejectedTests = "(" + rejectedTests + ")";
	                        }
	                    } else if (allNotRejectTablesHaveFilter && atLeastOneReject && currentIsReject) {
	                        rejectedTests = rejected;
	                    } else if (currentIsRejectInnerJoin && atLeastOneInputTableWithInnerJoin) {
	                        rejectedTests = rejectedInnerJoin;
	                    }
	                    if (hasFilters && !hasExpressionFilter || hasExpressionFilter) {
	                        String filtersConditions = null;
	                        if(hasExpressionFilter) {
		                     	filtersConditions = outputTable.getExpressionFilter();
		                     } else {
		                        filtersConditions = gm.buildConditions(filters, expressionParser);
		                     }
	                        if (rejectedTests == null) {
	                            ifConditions += cr + cr + filtersConditions  + cr + cr;
	                        } else {
	                            ifConditions += rejectedTests + " && (" + cr + cr + filtersConditions + cr + cr +")";
	                        }
	                    } else {
	                        ifConditions += rejectedTests;
	                    }
	                    ifConditions += " ) {";
	
	                    sb.append(cr).append(ifConditions);
	
	                    if (checkingSyntax) {
	                        sb.append("\n").append(CodeGenerationUtils.buildJavaEndFieldKey(key));
	                    }
	
	                    indent++;
	                    closeFilterOrRejectBracket = true;
	                    if (allNotRejectTablesHaveFilter && !(currentIsReject || currentIsRejectInnerJoin)
	                            && atLeastOneReject) {
	                        sb.append(cr + rejected + " = false;");
	                    }
	                }

	                if (outputTableEntries != null && (!currentIsReject && !currentIsRejectInnerJoin || currentIsReject || currentIsRejectInnerJoin
	                        && atLeastOneInputTableWithInnerJoin || checkingSyntax)) {
	                    for (ExternalMapperTableEntry outputTableEntry : outputTableEntries) {
	                        String outputColumnName = outputTableEntry.getName();
	                        IMetadataColumn metadataColumn = null;
	                        if(connectionExists) {
		                        metadataColumn = hashedMetadataTable.getColumn(outputColumnName);
		                    }
	                        
	                        String outputExpression = outputTableEntry.getExpression();
	                        if (outputExpression == null || outputExpression.trim().length() == 0) {
	                        	if(metadataColumn == null) {
		                            outputExpression = JavaTypesManager.getDefaultValueFromJavaIdType(outputTableEntry
	    	                                .getType(), outputTableEntry.isNullable());
	    	                    } else {
		                            outputExpression = JavaTypesManager.getDefaultValueFromJavaIdType(metadataColumn
	    	                                .getTalendType(), metadataColumn.isNullable());
	    	                    }
	                        }
	
	                        String key = CodeGenerationUtils.buildProblemKey(uniqueNameComponent,
	                                JavaGenerationManager.PROBLEM_KEY_FIELD.METADATA_COLUMN.toString(), outputTableName,
	                                outputColumnName);
	                        if (checkingSyntax) {
	                            sb.append("\n").append(CodeGenerationUtils.buildJavaStartFieldKey(key));
	                        }
	
	                        String assignationVar = null;
	                        if (connectionExists) {
	                            assignationVar = gm.getGeneratedCodeTableColumnVariable(uniqueNameComponent, outputTableName + "_tmp",
	                                    outputColumnName, false);
	                        } else {
	                        	if(metadataColumn == null) {
		                            assignationVar = JavaTypesManager.getTypeToGenerate(outputTableEntry.getType(),
	                                    outputTableEntry.isNullable())
	                                    + " dummyVar" + (dummyVarCounter++);
	                            } else {
		                            assignationVar = JavaTypesManager.getTypeToGenerate(metadataColumn
	    	                                .getTalendType(), metadataColumn.isNullable())
	                                    + " dummyVar" + (dummyVarCounter++);
	                            }
	                        }
    	                    String expression = assignationVar + " = " + outputExpression + ";";
	
	                        sb.append(cr).append(expression);
	
	                        if (checkingSyntax) {
	                            sb.append("\n").append(CodeGenerationUtils.buildJavaEndFieldKey(key));
	                        }
	
	                    } // for entries
	
	                    if (connectionExists) {
	                        sb.append(cr + outputTableName + " = " + outputTableName + "_tmp;");
	                    }

	                }
	                if (closeFilterOrRejectBracket) {
	                    indent--;
	                    sb.append(cr + "} // closing filter/reject");
	                }
	
	            }
	            lastValueReject = currentIsReject || currentIsRejectInnerJoin;
	
	         }

			// System.out.println("Output table: (2)" + outputTableName);

            boolean isLastTable = indexCurrentTable == lstSizeOutputs - 1;
            if (closeTestInnerJoinConditionsBracket 
            	&& (isLastTable || !checkingSyntax && (outputTableName.equals(lastValidOutputTableName) || lastValidOutputTableName == null))) {
                indent--;
                sb.append(cr + "}  // closing inner join bracket (2)");
                closeTestInnerJoinConditionsBracket = false;
            }

        } // for output tables

        sb.append(cr + "// ###############################");

        
        sb.append(cr);
        indent--;
        sb.append(cr + "} // end of Var scope");
        
        sb.append(cr + cr + rejectedInnerJoin + " = false;");
        
        sb.append(cr);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


%>
<%= sb.toString()%>
	
