<%@ jet 
	imports="
	java.util.ArrayList
	java.util.List
	java.util.Map
	java.util.HashMap
	org.talend.core.model.metadata.IMetadataTable
	org.talend.core.model.metadata.IMetadataColumn
	org.talend.core.model.metadata.MetadataTalendType
	org.talend.core.model.metadata.types.JavaTypesManager
	org.talend.core.model.metadata.types.JavaType
	org.talend.designer.mapper.MapperMain
	org.talend.designer.codegen.config.CodeGeneratorArgument
	org.talend.designer.mapper.MapperComponent
	org.talend.designer.mapper.external.data.ExternalMapperData 
	org.talend.designer.mapper.external.data.ExternalMapperTable
	org.talend.designer.mapper.external.data.ExternalMapperTableEntry
	org.talend.core.model.process.IConnection
	org.talend.designer.mapper.language.ILanguage
	org.talend.designer.mapper.language.generation.GenerationManagerFactory
	org.talend.designer.mapper.language.generation.JavaGenerationManager
	org.talend.designer.mapper.language.LanguageProvider
	" 
%>

<%

	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	MapperComponent node = (MapperComponent) codeGenArgument.getArgument();
	boolean stats = codeGenArgument.isStatistics();
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ExternalMapperData data = (ExternalMapperData) node.getExternalData();
        List<ExternalMapperTable> varsTables = data.getVarsTables();
        ILanguage currentLanguage = LanguageProvider.getJavaLanguage();
        JavaGenerationManager gm = (JavaGenerationManager) GenerationManagerFactory.getInstance().getGenerationManager(currentLanguage);

%>
// ###############################
// # Lookup's keys initialization<%

        List<IConnection> inputConnections = (List<IConnection>) node.getIncomingConnections();

        HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
        for (IConnection connection : inputConnections) {
            hNameToConnection.put(connection.getName(), connection);
        }

        List<ExternalMapperTable> inputTables = new ArrayList<ExternalMapperTable>(data.getInputTables());
        int lstSizeInputs = inputTables.size();
        for (int i = 1; i < lstSizeInputs; i++) {
            ExternalMapperTable inputTable = (ExternalMapperTable) inputTables.get(i);
            String tableName = inputTable.getName();
            IConnection connection = hNameToConnection.get(tableName);
            if (connection == null) {
                continue;
            }
            List<ExternalMapperTableEntry> tableEntries = inputTable.getMetadataTableEntries();
            if (tableEntries == null) {
                continue;
            }
            String className = tableName + "Struct";
%>

org.talend.designer.components.commons.AdvancedMemoryLookup<<%=tableName%>Struct> tHash_Lookup_<%=tableName%> = (org.talend.designer.components.commons.AdvancedMemoryLookup<<%=tableName%>Struct>) globalMap.get( "tHash_Lookup_<%=tableName%>" );
<%=className%> <%=tableName%>HashKey = new <%=className%>();
<%=className%> <%=tableName%>Default = new <%=className%>();
<%
        }
%>
// ###############################        

// ###############################
// # Vars initialization
<%

        /////////////////////////////////////////////////////////////////////////
        gm.setVarsTables(varsTables);

        List<ExternalMapperTable> varTablesList = new ArrayList<ExternalMapperTable>(varsTables);

        // constants
        for (ExternalMapperTable table : varTablesList) {
            List<ExternalMapperTableEntry> tableEntries = table.getMetadataTableEntries();
            if (tableEntries == null) {
                continue;
            }
            String tableName = table.getName();
            
            String instanceVarName = tableName + "__" + node.getUniqueName();
            String className = instanceVarName + "__Struct";
            
%>
class  <%=className%>  {

<%
            int lstSize = tableEntries.size();
            for (int i = 0; i < lstSize; i++) {
                ExternalMapperTableEntry varTableEntry = (ExternalMapperTableEntry) tableEntries.get(i);
                String javaType = varTableEntry.getType();

%>	<%= JavaTypesManager.getTypeToGenerate(javaType, varTableEntry.isNullable()) %> <%= varTableEntry.getName() %>;

<%
            }
%>}
<%= className %> <%= instanceVarName %> = new <%= className %>();
<%
        }
%>
// ###############################

// ###############################
// # Outputs initialization
<%

		  List<IConnection> outputConnections = (List<IConnection>) node.getOutgoingConnections();
		  Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
        for (IConnection connection : outputConnections) {
		  		nameToOutputConnection.put(connection.getName(), connection);
		  }

        List<ExternalMapperTable> outputTablesList = new ArrayList<ExternalMapperTable>(data.getOutputTables());
        // constants
        for (ExternalMapperTable table : outputTablesList) {
        
            List<ExternalMapperTableEntry> tableEntries = table.getMetadataTableEntries();
            if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
                continue;
            }
            String tableName = table.getName();
            
            String instanceVarName = tableName + "__" + node.getUniqueName();
            String className = tableName + "Struct";
            
%>
<%= className %> <%= tableName %>_tmp = new <%= className %>();
<%
        }
%>
// ###############################
<%

HashMap<String, ExternalMapperTableEntry> hExternalInputTableEntries = new HashMap<String, ExternalMapperTableEntry>();

String currentPartialName = "";

int sizeInputTables = inputTables.size();
        
for (int iInputTable = 0; iInputTable < sizeInputTables - 1; iInputTable++) { // T TM B 101
        
	ExternalMapperTable currentInputTable = inputTables.get(iInputTable);
	ExternalMapperTable nextInputTable = inputTables.get(iInputTable + 1);
	
	if(currentPartialName.length() > 0) {
		currentPartialName += "__";
	}
	
	currentPartialName += currentInputTable.getName();

	List<IMetadataColumn> nextColumnsKeys = new ArrayList<IMetadataColumn>();
	List<IConnection> currentInputConnections = new ArrayList<IConnection>();
	
	%>
	
	org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator fsi_<%= currentInputTable.getName() %> = new org.talend.designer.components.thash.io.hashimpl.FlowSorterIterator();
	fsi_<%= currentInputTable.getName() %>.initPut("/home/amaumont/data/dev/projets/Talend/hashfile/sort/data_<%= currentPartialName %>");

	class SortableRow_<%= currentPartialName %> implements Comparable<SortableRow_<%= currentPartialName %>> { // G TM B 001 

	<%
	        

	        String nextTableName = nextInputTable.getName();
            IConnection nextConection = hNameToConnection.get(nextTableName);
            if (nextConection == null) {
                continue;
            }
	
	
        
                IMetadataTable nextMetadataTable = nextConection.getMetadataTable();
                if (nextInputTable != null) {
                    hExternalInputTableEntries.clear();
                    List<ExternalMapperTableEntry> metadataTableEntries = nextInputTable.getMetadataTableEntries();
                    if (metadataTableEntries == null) {
                        continue;
                    }
                    for (ExternalMapperTableEntry nextInputTableEntry : metadataTableEntries) {
                        hExternalInputTableEntries.put(nextInputTableEntry.getName(), nextInputTableEntry);
                    }
                    List<IMetadataColumn> listColumns = nextMetadataTable.getListColumns();
                    for (IMetadataColumn column : listColumns) {
                        String columnName = column.getLabel();
                        ExternalMapperTableEntry externalInputTableEntry = hExternalInputTableEntries.get(columnName);
                        if (externalInputTableEntry != null) {
                            String expressionKey = externalInputTableEntry.getExpression();
                            if (expressionKey != null && !"".equals(expressionKey.trim())) {
                            
                            	nextColumnsKeys.add(column);
                            
                            	%><%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>;
                            	
                            	<%
 		                           
                            }
                        }
                    }
				}
			
			
			
				        String currentTableName = currentInputTable.getName();
            IConnection currentConection = hNameToConnection.get(currentTableName);
            if (currentConection == null) {
                continue;
            }
	
        
                IMetadataTable currentMetadataTable = currentConection.getMetadataTable();
                if (currentInputTable != null) {
                    hExternalInputTableEntries.clear();
                    List<ExternalMapperTableEntry> metadataTableEntries = currentInputTable.getMetadataTableEntries();
                    if (metadataTableEntries == null) {
                        continue;
                    }
                    for (ExternalMapperTableEntry currentInputTableEntry : metadataTableEntries) {
                        hExternalInputTableEntries.put(currentInputTableEntry.getName(), currentInputTableEntry);
                    }
                    currentInputConnections.add(currentConection);
                    List<IMetadataColumn> listColumns = currentMetadataTable.getListColumns();
                    for (IMetadataColumn column : listColumns) {
                        String columnName = column.getLabel();
                            
                            	%><%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> <%= currentInputTable.getName() %>__<%=column.getLabel() %>;
                            	
                            	<%
 		                           
                    }
				}
				
		%>
		
		
		
		         public void fillFrom(<%
		         
		         String comma = "";
		         for(IConnection connection : currentInputConnections) {
			         %><%=comma%><%= connection.getName() %>Struct <%= connection.getName() %><%
		         	comma = ",";
		         }
                    int sizeNextColumns = nextColumnsKeys.size();
                    for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { // T TM B 105
                    	IMetadataColumn column = nextColumnsKeys.get(iColumn);

		         	%><%=comma%><%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %><%
                    
                    } // T TM B 105
		         %>) {

					<%
		        	for(IConnection connection : currentInputConnections) {
		        	
		        		IMetadataTable table = connection.getMetadataTable();
						List<IMetadataColumn> listColumns = table.getListColumns();
                    	for (IMetadataColumn column : listColumns) {
						%>
					
	                    this.<%= connection.getName() %>__<%= column.getLabel() %> = <%= connection.getName() %>.<%= column.getLabel() %>;
                    
	                	<%
                		}
                	}
                	%>
                    <%
                    sizeNextColumns = nextColumnsKeys.size();
                    for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { // T TM B 104
                    	IMetadataColumn column = nextColumnsKeys.get(iColumn);

						%>this.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %> = exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>;
						<%
                    
                    } // T TM B 104
                    %>
                }

                public void copyDataTo(<%
		         
		         comma = "";
		         for(IConnection connection : currentInputConnections) {
			         %><%=comma%><%= connection.getName() %>Struct <%= connection.getName() %><%
		         	comma = ",";
		         }
		         %>) {

					<%
		        	for(IConnection connection : currentInputConnections) {
		        	
		        		IMetadataTable table = connection.getMetadataTable();
						List<IMetadataColumn> listColumns = table.getListColumns();
                    	for (IMetadataColumn column : listColumns) {
						%>
					
	                    <%= connection.getName() %>.<%= column.getLabel() %> = this.<%= connection.getName() %>__<%= column.getLabel() %>;
                    
	                	<%
                		}
                	}
                	%>

                }

		
		
		
		
		        public int compareTo(SortableRow_<%= currentPartialName %> other) {

                    int returnValue = 0;
                    
                    <%
                    sizeNextColumns = nextColumnsKeys.size();
                    for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { // T TM B 102
                    	IMetadataColumn column = nextColumnsKeys.get(iColumn);
                    %>
                    
                    	returnValue = checkNullsAndCompare(this.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>, other.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>);
                    	if (returnValue != 0) {
	                        return returnValue;
                    	}
                    
                    <%
                    } // T TM B 102
                    %>

                    return returnValue;
                }

		    private int checkNullsAndCompare(Object object1, Object object2) {

        int ascendingInt = 1;

        int returnValue = 0;
        if (object1 instanceof String && object2 instanceof String) {
            returnValue = compareStrings((String) object1, (String) object2);
        } else if (object1 instanceof Comparable && object2 instanceof Comparable) {
            returnValue = ((Comparable) object1).compareTo(object2);
        } else if (object1 != null && object2 != null) {
            returnValue = compareStrings(object1.toString(), object2.toString());
        } else if (object1 == null && object2 != null) {
            returnValue = 1;
        } else if (object1 != null && object2 == null) {
            returnValue = -1;
        } else {
            returnValue = 0;
        }

        return ascendingInt * returnValue;
    }

    private int compareStrings(String string1, String string2) {
        boolean ignoreCase = true;
        if (ignoreCase) {
            return string1.compareToIgnoreCase(string2);
        } else {
            return string1.compareTo(string2);
        }
    }

		
		
		
		} // G TM B 001
		
<%
} // T TM B 101      
%>        
        
