<%@ jet 
	imports="
			org.talend.core.model.process.INode 
			org.talend.core.model.process.ElementParameterParser 
			org.talend.designer.codegen.config.CodeGeneratorArgument
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.metadata.IMetadataColumn
			org.talend.core.model.metadata.MetadataTalendType
			org.talend.core.model.metadata.types.JavaTypesManager
			org.talend.core.model.metadata.types.JavaType
			
			org.talend.designer.xmlmap.generation.GenerationManagerFactory
			org.talend.designer.xmlmap.generation.GenerationManager

			org.talend.core.model.process.AbstractExternalNode
			org.talend.designer.xmlmap.XmlMapComponent
			org.talend.designer.xmlmap.model.emf.xmlmap.XmlMapData
			org.eclipse.emf.common.util.EList
			org.talend.core.model.metadata.IMetadataTable
			org.talend.core.model.utils.NodeUtil
			org.talend.designer.xmlmap.model.emf.xmlmap.VarNode
			org.talend.designer.xmlmap.model.emf.xmlmap.VarTable
			org.talend.designer.xmlmap.model.emf.xmlmap.InputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputXmlTree
			org.talend.designer.xmlmap.model.emf.xmlmap.TreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.AbstractNode
			org.talend.designer.xmlmap.model.emf.xmlmap.OutputTreeNode
			org.talend.designer.xmlmap.model.emf.xmlmap.NodeType
			org.talend.core.model.process.IConnection
			org.talend.core.model.process.EConnectionType
            java.util.Map
            java.util.HashMap
            java.util.List
			java.util.HashSet
			java.util.Set
            java.util.ArrayList
            org.talend.core.model.metadata.types.JavaTypesManager
        	org.talend.core.model.metadata.types.JavaType
        	org.talend.core.model.process.IHashableInputConnections;
	" 
	skeleton="../tXMLMap/tXMLMap_java.skeleton"
%>
<%
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	XmlMapComponent node = (XmlMapComponent) codeGenArgument.getArgument();
	GenerationManager gm = (GenerationManager) GenerationManagerFactory.getInstance().getGenerationManager();
	String cid = node.getUniqueName();
	
	String uniqueNameComponent = cid.replaceAll("_TXMLMAP_OUT", "");
	
	INode graphicalNode = null;
	for(INode loopNode : node.getProcess().getGraphicalNodes()) {
		if(loopNode.getUniqueName().equals(uniqueNameComponent)) {
			graphicalNode = loopNode;
		}
	}

	XmlMapData xmlMapData =(XmlMapData)ElementParameterParser.getObjectValueXMLTree(graphicalNode);
	
	EList<InputXmlTree> inputTables = xmlMapData.getInputTrees();
	EList<OutputXmlTree> outputTables = xmlMapData.getOutputTrees();
	EList<VarTable> varTables = xmlMapData.getVarTables();
	
	boolean hasConcurrencyContext = false;
	List<IConnection> inputConnections = (List<IConnection>)node.getIncomingConnections();
	HashMap<String, IConnection> hNameToConnection = new HashMap<String, IConnection>();
	for(IConnection connection : inputConnections){
		hNameToConnection.put(connection.getName(), connection);
	}
	
	List<InputXmlTree> inputTableTrees = new ArrayList<InputXmlTree>();
	for(int i=0; i<inputTables.size(); i++){
		InputXmlTree  currentTree = inputTables.get(i);
		if(hNameToConnection.get(currentTree.getName()) != null){
			inputTableTrees.add(currentTree);
		}
	}
	
	boolean hasDocumentInAnyLookupTable = false;
	List<TreeNode> lookupDocumentTreeNodes = new ArrayList<TreeNode>();
	
	int lstSizeInputs = inputTableTrees.size();
	for(int i = 1; i<lstSizeInputs; i++){//TA8080
		InputXmlTree inputTable = (InputXmlTree)inputTableTrees.get(i);
		String tableName = inputTable.getName();
		
		EList<TreeNode> treeNodes = inputTable.getNodes();
		if(treeNodes!=null) {
			for(TreeNode treeNode : treeNodes) {
				if("id_Document".equals(treeNode.getType())) {
					hasDocumentInAnyLookupTable = true;
					lookupDocumentTreeNodes.add(treeNode);
				}
			}
		}		
		
		List<IMetadataTable> treeNodeEntries = node.getMetadataList();
		if(treeNodeEntries == null){
		      continue;
	    }
		
		boolean isAllRows = "ALL_ROWS".equals(inputTable.getMatchingMode());
		String className = tableName + "Struct";
		String lookupMode = inputTable.getLookupMode();
		boolean isReloadLookupMode = org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.RELOAD.name().equals(lookupMode);
		boolean isCacheOrReloadLookupMode = org.talend.designer.xmlmap.model.tree.LOOKUP_MODE.CACHE_OR_RELOAD.name().equals(lookupMode);
		boolean isOneOfReloadLookupMode = isReloadLookupMode || isCacheOrReloadLookupMode;
		if(inputTable.isPersistent()){
%>

	org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct> tHash_Lookup_<%=tableName%> = 
		(org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
			((org.talend.designer.components.lookup.persistent.Persistent<%= isAllRows ? "" : "Sorted" %>LookupManager<<%=tableName%>Struct>) 
				 globalMap.get( "tHash_Lookup_<%=tableName%>" ))
				<%
				if(hasConcurrencyContext) {
				%>
				.clone()
				<%}%>;
	<%
		} else {
	%>
	org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct> tHash_Lookup_<%=tableName%> = <%
	
	if(isOneOfReloadLookupMode) {
		 %>null;<%
	} else {
		%>(org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
			((org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<<%=tableName%>Struct>) 
				globalMap.get( "tHash_Lookup_<%=tableName%>" ))
				<%
				if(hasConcurrencyContext) {
				%>
				.clone()
				<%}%>;
	<%
	}
	%>
	<%
	}
	String matchingModeStr = inputTable.getMatchingMode();
	if(isCacheOrReloadLookupMode) {
	%>
	
	routines.system.DocumentLookupCache tHash_Lookup_Cache_<%=tableName%> = new routines.system.DocumentLookupCache("<%=matchingModeStr%>");
	<%}
	if(isAllRows && !isOneOfReloadLookupMode) {
	%>
		tHash_Lookup_<%=tableName%>.initGet();
	<%}%>
	<%=className%> <%=tableName%>HashKey = new <%=className%>();
	<%=className%> <%=tableName%>Default = new <%=className%>();
	<%=className%> <%=tableName%> = new <%=className%>();
	<%
	}//TA8080
	%>
	
	<%
	class RepalceTableXpath {
		
		public void replaceTableXpath(TreeNode root){
			String xpath = root.getXpath();
			int index_p = xpath.indexOf(".");
			if(index_p<0){
    			xpath = xpath.replaceFirst("/", ".");
    			xpath = xpath.replaceFirst("/", ":/");
    			root.setXpath(xpath);
			}
    		for(TreeNode tmpNode : root.getChildren()) {
    			replaceTableXpath(tmpNode);
    		}
		}
	}
	RepalceTableXpath replaceXpath = new RepalceTableXpath();
	
	if(inputTables.size() > 0 && !inputTables.get(0).isLookup()) {
		InputXmlTree inputMainTable = inputTables.get(0);
		for(TreeNode tmpnode : inputMainTable.getNodes()) {
			if("id_Document".equals(tmpnode.getType())) {
				replaceXpath.replaceTableXpath(tmpnode);
				break;
			}
		}
	}
	for(OutputXmlTree outputMainTable : outputTables) {
		for(OutputTreeNode tmpnode : outputMainTable.getNodes()) {
			if("id_Document".equals(tmpnode.getType())) {
				replaceXpath.replaceTableXpath(tmpnode);
				break;
			}
		}
	}
	%>
//===============================input xml init part===============================

class NameSpaceTool_<%=cid%> {

    public java.util.HashMap<String, String> xmlNameSpaceMap = new java.util.HashMap<String, String>();
    
	private java.util.List<String> defualtNSPath = new java.util.ArrayList<String>();

    public void countNSMap(org.dom4j.Element el) {
        for (org.dom4j.Namespace ns : (java.util.List<org.dom4j.Namespace>) el.declaredNamespaces()) {
            if (ns.getPrefix().trim().length() == 0) {
                xmlNameSpaceMap.put("pre"+defualtNSPath.size(), ns.getURI());
                String path = "";
                org.dom4j.Element elTmp = el;
                while (elTmp != null) {
                	if (elTmp.getNamespacePrefix() != null && elTmp.getNamespacePrefix().length() > 0) {
                        path = "/" + elTmp.getNamespacePrefix() + ":" + elTmp.getName() + path;
                    } else {
                        path = "/" + elTmp.getName() + path;
                    }
                    elTmp = elTmp.getParent();
                }
                defualtNSPath.add(path);
            } else {
                xmlNameSpaceMap.put(ns.getPrefix(), ns.getURI());
            }

        }
        for (org.dom4j.Element e : (java.util.List<org.dom4j.Element>) el.elements()) {
            countNSMap(e);
        }
    }
    
    public String addDefaultNSPrefix(String path, String loopPath) {
        if (defualtNSPath.size() > 0) {
        	String fullPath = loopPath;
        	if(!path.equals(fullPath)){
            	for (String tmp : path.split("/")) {
            		if (("..").equals(tmp)) {
                        fullPath = fullPath.substring(0, fullPath.lastIndexOf("/"));
                    } else {
                        fullPath += "/" + tmp;
                    }
            	}
            }
        	int[] indexs = new int[fullPath.split("/").length - 1];
            java.util.Arrays.fill(indexs, -1);
            int length = 0;
            for (int i = 0; i < defualtNSPath.size(); i++) {
                if (defualtNSPath.get(i).length() > length && fullPath.startsWith(defualtNSPath.get(i))) {
                    java.util.Arrays.fill(indexs, defualtNSPath.get(i).split("/").length - 2, indexs.length, i);
                    length = defualtNSPath.get(i).length();
                }
            }

            StringBuilder newPath = new StringBuilder();
            String[] pathStrs = path.split("/");
            for (int i = 0; i < pathStrs.length; i++) {
                String tmp = pathStrs[i];
                if (newPath.length() > 0) {
                    newPath.append("/");
                }
                if (tmp.length() > 0 && tmp.indexOf(":") == -1 && tmp.indexOf(".") == -1 /*&& tmp.indexOf("@") == -1*/) {
                    int index = indexs[i + indexs.length - pathStrs.length];
                    if (index >= 0) {
                    	//==== add by wliu to support both filter and functions==
						if(tmp.indexOf("[")>0 && tmp.indexOf("]")>tmp.indexOf("[")){//include filter
							String tmpStr=replaceElementWithNS(tmp,"pre"+index+":");
							newPath.append(tmpStr);
						}else{
							if(tmp.indexOf("@") != -1 || tmp.indexOf("(")<tmp.indexOf(")")){  // include attribute
								newPath.append(tmp);
							}else{
						//==add end=======	
                        		newPath.append("pre").append(index).append(":").append(tmp);
                        	}
                        }                    
                    } else {
                        newPath.append(tmp);
                    }
                } else {
                    newPath.append(tmp);
                }
            }
            return newPath.toString();
        }
        return path;
    }

	private String matches = "@*\\b[a-z|A-Z|_]+[[-]*\\w]*\\b[^'|^\\(]";
    private java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(matches);
    
	private String replaceElementWithNS(String global, String pre){

        java.util.regex.Matcher match = pattern.matcher(global);
        StringBuffer sb = new StringBuffer();
        match.reset();
        while (match.find()) {
            String group = match.group();
            String tmp = "";
            if (group.toLowerCase().matches("\\b(div|mod|and|or)\\b.*") || group.matches("@.*")) {
                tmp = group;
            } else {
                tmp = tmp + pre + group;
            }
            match.appendReplacement(sb, tmp);
        }
        match.appendTail(sb);
        
        return sb.toString();
	}    

}

class XML_API_<%=cid%>{
	public boolean isDefNull(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        if (node != null && node instanceof org.dom4j.Element) {
        	org.dom4j.Attribute attri = ((org.dom4j.Element)node).attribute("nil");
        	if(attri != null && ("true").equals(attri.getText())){
            	return true;
            }
        }
        return false;
    }

    public boolean isMissing(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        return node == null ? true : false;
    }

    public boolean isEmpty(org.dom4j.Node node) throws javax.xml.transform.TransformerException {
        if (node != null) {
            return node.getText().length() == 0;
        }
        return false;
    }
}
<%

class GenerateMethodUtil {
	String cid = null;
	java.util.Map<String, String> typeMap = new java.util.HashMap<String, String>(); // Map<typeToGenerate, typeToGenerate>
	java.util.Map<String, String> pathTypeMap = new java.util.HashMap<String, String>(); // Map<input table xpath, typeToGenerate>
	java.util.Map<String, String> pathPatternMap = new java.util.HashMap<String, String>(); // Map<input table xpath, Pattern>
	java.util.Map<String, String> pathTypeToGenMap = new java.util.HashMap<String, String>(); // Map<"/root/name","String">
	
	void generateExprCode(String expression){
			StringBuilder strBuilder = new StringBuilder();
			if(expression==null || ("").equals(expression)) {
				return;
			}
	
			String currentExpression = expression;
			String tmpXpath = "";
			java.util.regex.Pattern expressionFromDoc = java.util.regex.Pattern.compile("\\[.*\\..*:.*\\]");
			java.util.regex.Matcher matcherFromDoc;
			
			boolean end = false;
			
			if(expression.indexOf("[")>-1) {
				strBuilder.append(expression.substring(0, expression.indexOf("[")));
				currentExpression = currentExpression.substring(currentExpression.indexOf("["), currentExpression.length());
				
				while(currentExpression.length()>0 && !end) {
					expression = currentExpression.substring(0, currentExpression.indexOf("]")+1);
					currentExpression = currentExpression.substring(expression.length(), currentExpression.length());
					matcherFromDoc = expressionFromDoc.matcher(expression);
					if(matcherFromDoc.matches()) {
						tmpXpath = expression.substring(1, expression.length()-1);
						if("id_String".equals(pathTypeMap.get(tmpXpath)) || "id_Object".equals(pathTypeMap.get(tmpXpath))){
							strBuilder.append("treeNodeAPI.get_String(\""+ tmpXpath + "\")");
						} else if("id_Date".equals(pathTypeMap.get(tmpXpath))) {
							strBuilder.append("treeNodeAPI.get_Date(\""+ tmpXpath + "\" , \"" + pathPatternMap.get(tmpXpath) + "\")");
						} else if("id_byte[]".equals(pathTypeMap.get(tmpXpath))) {
							strBuilder.append("treeNodeAPI.get_Bytes(\""+ tmpXpath + "\")");
						} else {
							String type = pathTypeToGenMap.get(tmpXpath);
							if(type != null) {
								strBuilder.append("treeNodeAPI.get_" + pathTypeToGenMap.get(tmpXpath) + "(\""+ tmpXpath + "\")");
							} else {
								strBuilder.append("treeNodeAPI.get_String(\""+ tmpXpath + "\")");
							}
						}				
					} else {
						strBuilder.append(expression);
					}
					if(currentExpression.indexOf("[")>-1) {
						strBuilder.append(currentExpression.substring(0, currentExpression.indexOf("[")));
						currentExpression = currentExpression.substring(currentExpression.indexOf("["), currentExpression.length());
					} else {
						strBuilder.append(currentExpression);
						end=true;
					}
				
				}
			} else {
				strBuilder.append(expression);
			}
			%><%=strBuilder.toString()%><%
		}
		
		public List<TreeNode> getGroupByNodeList(TreeNode group) {
			List<TreeNode> list = new ArrayList<TreeNode>();
			for (TreeNode attri : group.getChildren()) {
				if(NodeType.ATTRIBUT.equals(attri.getNodeType())) {
					list.add(attri);
				}
			}
			if (NodeType.ELEMENT.equals(group.getNodeType()) && group.getChildren().size()==0) {
				list.add(group);
			} else {
				if(NodeType.ELEMENT.equals(group.getNodeType()))
				for (TreeNode element : group.getChildren()) {
					if (!element.isMain() && !element.isLoop()) {
						list.addAll(getGroupByNodeList(element));
					}
				}
			}
			return list;
		}

	
	void generateCode(List<TreeNode> nodes, String cid){
%>
class TreeNode_API_<%=cid %> {
	java.util.Map<String, String> xpath_value_map = new java.util.HashMap<String, String>();
	
	void clear(){
		xpath_value_map.clear();
	}
	
	void put(String xpath, String value){
		xpath_value_map.put(xpath, value);
	}
	String get_null(String xpath) {
		return null;
	}
<%
		generateMethodCodeForAll(nodes, cid);
%>
}
<%
	}
	
	void generateMethodCodeForAll(List<TreeNode> nodes, String cid) {
		for(TreeNode node : nodes) {
			generateMethodCodeForOne(node,cid);
		}
	}
	
	void generateMethodCodeForOne(TreeNode node, String cid) {
		
		if(!(node.getChildren().size()>0)){
			String talendType = node.getType();
			JavaType javaType = JavaTypesManager.getJavaTypeFromId(talendType);
			String typeToGenerate = JavaTypesManager.getTypeToGenerate(talendType, node.isNullable());
			String patternValue = node.getPattern() == null || node.getPattern().trim().length() == 0 ? null : node.getPattern();
			
			pathTypeMap.put(node.getXpath(), talendType);
			pathPatternMap.put(node.getXpath(), patternValue);
			pathTypeToGenMap.put(node.getXpath(), typeToGenerate);
//			System.out.println(node.getXpath() + " javaType:Id=" + javaType.getId() + "---talendType="+talendType +"---typeGen=" +typeToGenerate);
			if(typeMap.get(typeToGenerate)==null){
				typeMap.put(typeToGenerate,typeToGenerate);
				if ("id_String".equals(talendType) || "id_Object".equals(talendType)) {
%>
	String get_String(String xpath){
		return xpath_value_map.get(xpath);
	}
<%
				} else if ("id_Date".equals(talendType)) {
%>
	java.util.Date get_Date(String xpath, String pattern){
		if(xpath_value_map.get(xpath)==null) return null;
		return ParserUtils.parseTo_Date(xpath_value_map.get(xpath), pattern);
	}
<%
				} else if("id_byte[]".equals(talendType)){ 
%>
	byte[] get_Bytes(String xpath){
		if(xpath_value_map.get(xpath)==null) return null;
		return xpath_value_map.get(xpath).getBytes();
	}
<%
				} else {
%>
	<%=typeToGenerate %> get_<%=typeToGenerate %>(String xpath){
		return ParserUtils.parseTo_<%= typeToGenerate %>(xpath_value_map.get(xpath));
	}
<%
				}
			}
		} else {
    		for(TreeNode tmpNode : node.getChildren()) {
    			generateMethodCodeForOne(tmpNode,cid);
    		}
		}
	}
}

	// define the var row
	for (VarTable var : xmlMapData.getVarTables()) {
		String tableName = var.getName();
        String instanceVarName = tableName + "__" + node.getUniqueName();
        String className = instanceVarName + "__Struct";
%>
	class <%=className %> {
<%
            for(VarNode varNode : var.getNodes()){
                String javaType = varNode.getType();
%>	<%= JavaTypesManager.getTypeToGenerate(javaType, varNode.isNullable()) %> <%=varNode.getName() %>;
<%
            }
%>
	}
	<%= className %> <%= instanceVarName %> = new <%= className %>();
<%
	}
%>
// ###############################
// # Outputs initialization
<%

		List<IConnection> outputConnections = (List<IConnection>) graphicalNode.getOutgoingConnections();
		Map<String, IConnection> nameToOutputConnection = new HashMap<String, IConnection>();
        for (IConnection connection : outputConnections) {
		  		nameToOutputConnection.put(connection.getName(), connection);
		}

        for (OutputXmlTree table : outputTables) {
        
            EList<OutputTreeNode> tableEntries = table.getNodes();
            if (tableEntries == null || nameToOutputConnection.get(table.getName()) == null) {
                continue;
            }
            String tableName1 = table.getName();
            
            String instanceVarName = tableName1 + "__" + node.getUniqueName();
            String className = tableName1 + "Struct";
            
%>
<%= className %> <%= tableName1 %>_tmp = new <%= className %>();
<%= className %> <%= tableName1 %>_save = null;
//the aggregate variable
<%= className %> <%= tableName1 %>_aggregate = null;
<%
        }
%>
//init the resultset for aggregate
java.util.List<Object> allOutsForAggregate_<%=uniqueNameComponent %> = new java.util.ArrayList<Object>();
// ###############################
<%
	
	InputXmlTree mainInputTable = null;  // the main input table
	if(inputConnections==null || inputConnections.size() < 1) {
		return "";
	}

	if(inputTables==null || inputTables.size()==0) return "";
	for(IConnection conn : inputConnections) { // find the input main table
		InputXmlTree inputTable = inputTables.get(0);
		EConnectionType connectionType = conn.getLineStyle();
		if (connectionType == EConnectionType.FLOW_MAIN) {
			if(!inputTable.isLookup()) { // lookup is used to sign it is lookup table
    			mainInputTable = inputTable;
    			break;
			}
		}
	}
	
	boolean hasDocumentInMainInputTable = false;
	//we should consider all document node instead of only main document node
	TreeNode mainDocumentTreeNode = null;
	if(mainInputTable != null) {
		for(TreeNode tmpNode : mainInputTable.getNodes()){
			if("id_Document".equals(tmpNode.getType())) {
				hasDocumentInMainInputTable = true;
				mainDocumentTreeNode = tmpNode;
				//This boolean when there is a document in the main input table schema.
				break;
			}
		}
	}
	
	class FindNodeUtil{
		
		TreeNode findLoopPathNode(TreeNode node){
			if(node == null){
				return null;
			}
			if(node.isLoop()) {
				return node;
			}
			for(TreeNode tmpNode : node.getChildren()) {
				TreeNode resultNode = findLoopPathNode(tmpNode);
				if(resultNode!=null){
					return resultNode;
				}
			}
			
			return null;
		}
		
		void findXpathArray(TreeNode node, String loopPath, List<String> resultList) {
			if(node.getOutgoingConnections().size()>0){
				String xpath = node.getXpath();
				String result = null;
				if(xpath==null || ("").equals(xpath)){
				} else if(xpath.equals(loopPath)){ // get the value in the loop elment
					result = ".";
				} else if(xpath.contains(loopPath)){ // find the loop path
					result = xpath.substring(loopPath.length() + 1);
				} else {
					StringBuilder resultBuff = new StringBuilder();
					String tmp = loopPath;
					
					while(!xpath.contains(tmp)){
						int index = tmp.lastIndexOf("/");
						if(index<0){ break; }
						tmp = tmp.substring(0,index-1);
						resultBuff.append("../");
					}
					if(tmp.lastIndexOf("/") < 0 ){
						System.out.println("Loop Path is not set or loop Path is invalid");
					}else{
						resultBuff.append(xpath.substring(tmp.length() + 1));
					}
					result = resultBuff.toString();
				}
				resultList.add(result);
			} else {
    			for(TreeNode tmpNode : node.getChildren()) {
    				findXpathArray(tmpNode, loopPath, resultList);
    			}
			}
		}
	}
	GenerateMethodUtil generateMethodUtil = new GenerateMethodUtil();
	generateMethodUtil.cid = cid;
	if(mainInputTable != null) {
		String mainInputName = mainInputTable.getName();
		
		boolean hasDocumentInAnyTable = hasDocumentInAnyLookupTable || hasDocumentInMainInputTable;
		List<TreeNode> AllDocumentTreeNodes = new ArrayList<TreeNode>();
		if(lookupDocumentTreeNodes.size()!=0) {
			AllDocumentTreeNodes.addAll(lookupDocumentTreeNodes);
		}
		if(mainDocumentTreeNode!=null) {
			AllDocumentTreeNodes.add(mainDocumentTreeNode);
		}
		
		if(hasDocumentInAnyTable) {
			generateMethodUtil.generateCode(AllDocumentTreeNodes, cid); // begin part keep this part
%>
			TreeNode_API_<%=cid %> treeNodeAPI_<%=cid %> = new TreeNode_API_<%=cid %>();
			NameSpaceTool_<%=cid%> nsTool_<%=cid%> = new NameSpaceTool_<%=cid%>();
<%	
		}
%>
		int nb_line_<%=cid%> = 0; 
<%		
    }

%>
	
    XML_API_<%=cid%> xml_api_<%=cid%> = new XML_API_<%=cid%>();

<%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//=====================================================output xml init part=======================================================================
class GenerateToolByDom4j{
	String cid = null;
	boolean allowEmpty = false;
	GenerateMethodUtil generateMethodUtil = null;
	java.util.List<java.util.List<TreeNode>> groupList = new java.util.ArrayList<java.util.List<TreeNode>>();
	java.util.List<java.util.List<java.util.List<TreeNode>>> groupbyNodeList = new java.util.ArrayList(new java.util.ArrayList<java.util.List<TreeNode>>());
	
	void setAllMainNodes(TreeNode root) {
		TreeNode loop = getLoopNode(root);
		if(loop==null) return;
		loop.setMain(true);
		TreeNode parent = (TreeNode)loop.eContainer();
		while((parent != null) && (!("id_Document").equals(parent.getType())) ) {
			parent.setMain(true);
			parent = (TreeNode)parent.eContainer();
		}
	}
	
	public TreeNode getLoopNode(TreeNode root) {
		if(root == null) {
			return null;
		}
		if(root.isLoop()){
			return root;
		}
		
		for(TreeNode node : root.getChildren()){
			TreeNode tmpNode = getLoopNode(node);
			if(tmpNode!=null) {
				return tmpNode;
			}
		}
		return null;
	}
	
	public void generateCode(OutputTreeNode node, String currEleName, String parentName){
		if(node.getNodeType()==NodeType.ELEMENT){
			createElement(currEleName,node,parentName);
			setText(currEleName,node);
		
    		// add namespace support here in the future
    		for(TreeNode child: node.getChildren()) {
    			if(child.getNodeType()==NodeType.NAME_SPACE) { // namespaces
    				addNameSpace(currEleName, (OutputTreeNode)child);
    			}
    		}
    		
    		addAttribute(currEleName, node);
    		
			int index = 0;
			for(TreeNode child:node.getChildren()){
				if(!child.isGroup() && !child.isLoop()) {
					generateCode((OutputTreeNode)child,currEleName+"_"+index++,currEleName);
				}
			}
			
			createEmptyElement(node,currEleName,parentName);
		}
	}
	
	private void createEmptyElement(OutputTreeNode node,String currEleName,String parentName) {
		if(!node.isMain() && !node.isGroup() && !node.isLoop() && !allowEmpty) {
%>
		if (<%=currEleName%>.content().size() == 0 
			&& <%=currEleName%>.attributes().size() == 0 
			&& <%=currEleName%>.declaredNamespaces().size() == 0) {
            <%=parentName%>.remove(<%=currEleName%>);
        }
<%				
		}
	}

	private void addNameSpace(String currEleName, OutputTreeNode node) {
		if(node.getDefaultValue()==null || ("").equals(node.getDefaultValue())) {
%>
valueMap.put("<%=currEleName%>",<%generateMethodUtil.generateExprCode(node.getExpression() ); %>);
if(valueMap.get("<%=currEleName%>")!=null) {//open if 8080
<%=currEleName%>.addNamespace("<%=node.getName() %>", TalendString.replaceSpecialCharForXML( <%generateMethodUtil.generateExprCode(node.getExpression() ); %>));
<%
		} else {
%>
<%=currEleName%>.addNamespace("<%="(default)".equals(node.getName())?"":node.getName() %>", TalendString.replaceSpecialCharForXML("<%generateMethodUtil.generateExprCode(((OutputTreeNode)node).getDefaultValue()); %>"));
<%
		}
		OutputTreeNode parent = (OutputTreeNode)node.eContainer();
		if(parent.getName().indexOf(":") < 0) { // element without prefix
			if(node.getName()==null || ("").equals(node.getName().trim()) || "(default)".equals(node.getName().trim())) { // it is the default namespace
				if(node.getDefaultValue()==null || ("").equals(node.getDefaultValue())) { // get the expression
%>
        	<%=currEleName %>.setQName(org.dom4j.DocumentHelper.createQName(<%=currEleName %>.getName(),
        	org.dom4j.DocumentHelper.createNamespace("",TalendString.replaceSpecialCharForXML(<%generateMethodUtil.generateExprCode(node.getExpression() ); %>))));
}//close if 8080
<%
				} else { // get the static value as the url
%>
        	<%=currEleName %>.setQName(org.dom4j.DocumentHelper.createQName(<%=currEleName %>.getName(),
        	org.dom4j.DocumentHelper.createNamespace("",TalendString.replaceSpecialCharForXML("<%generateMethodUtil.generateExprCode(((OutputTreeNode)node).getDefaultValue()); %>"))));
<%
				}
			}
		} else {
			int index = parent.getName().indexOf(":");
			if(node.getName().equals(parent.getName().substring(0, index))) { // the prefix of element is the same with the namespace
				if(node.getDefaultValue()==null || ("").equals(node.getDefaultValue())) { // get the expression
%>
        	<%=currEleName %>.setQName(org.dom4j.DocumentHelper.createQName("<%=parent.getName().substring(index+1 ) %>",
        	org.dom4j.DocumentHelper.createNamespace("<%=node.getName() %>",TalendString.replaceSpecialCharForXML(<%generateMethodUtil.generateExprCode(node.getExpression() ); %>))));
}//close if 8080
<%
				} else {
%>
        	<%=currEleName %>.setQName(org.dom4j.DocumentHelper.createQName("<%=parent.getName().substring(index+1 ) %>",
        	org.dom4j.DocumentHelper.createNamespace("<%=node.getName() %>",TalendString.replaceSpecialCharForXML("<%generateMethodUtil.generateExprCode(((OutputTreeNode)node).getDefaultValue()); %>"))));
<%
				}
			}
		}
	}
	
	private void createElement(String currEleName, OutputTreeNode node, String parentName){
		int index = 0;
		index = node.getName().indexOf(":");
		if(index>0 && hasParent(node)){
%>
		org.dom4j.Element <%=currEleName%>;
		if (<%=parentName%>.getNamespaceForPrefix("<%=node.getName().substring(0,index)%>") == null) {
            <%=currEleName%> = <%=parentName%>.addElement("<%=node.getName().substring(index+1)%>");
        } else {
        	<%=currEleName%> = <%=parentName%>.addElement("<%=node.getName()%>");
        }
<%
		}else{
			if(node.isMain() && (node.isGroup() || node.isLoop())) {
%>
				org.dom4j.Element <%=currEleName%> = org.dom4j.DocumentHelper.createElement("<%=node.getName()%>");
				<%=parentName%>.elements().add(orderHelper.getInsertLocation(<%=XMLOrderUtil.getCurrPos(node) %>,<%=XMLOrderUtil.getCurrOrder(node) %>),<%=currEleName%>);
<%
			} else {
%>
				org.dom4j.Element <%=currEleName%> = <%=parentName%>.addElement("<%=node.getName()%>");
		
<%
			}
		}
%>
		
<%
		if(node.isGroup() || node.isMain()){
%>
		subTreeRootParent = <%=currEleName%>;
<%
		}
	}
	
	private void addAttribute(String currEleName, OutputTreeNode node){
		for(TreeNode tmpNode : node.getChildren()) {
			if(tmpNode.getNodeType()==NodeType.ATTRIBUT) {
				if(tmpNode.getExpression()!=null && !("").equals(tmpNode.getExpression()) ){
%>
//		if(<%//tool.getValue(node);%>!=null){
			valueMap.put("<%=currEleName%>",<%generateMethodUtil.generateExprCode(tmpNode.getExpression()); %>);
			if(valueMap.get("<%=currEleName%>")!=null) {
				<%=currEleName%>.addAttribute("<%=tmpNode.getName() %>",String.valueOf(<%generateMethodUtil.generateExprCode(tmpNode.getExpression()); %>));
			}<% if(allowEmpty) { %>else {
				<%=currEleName%>.addAttribute("<%=tmpNode.getName() %>","");
			}
			<% } %>
//		}
<%
				} else if(allowEmpty) {
%>
			<%=currEleName%>.addAttribute("<%=tmpNode.getName() %>","");
<%
				}
			}
		}
	}
	
	private void setText(String currEleName, OutputTreeNode node){
		if(node.getExpression()!=null && !("").equals(node.getExpression()) ){
%>
		valueMap.put("<%=currEleName%>",<%generateMethodUtil.generateExprCode(node.getExpression()); %>);
		if(valueMap.get("<%=currEleName%>")!=null) {
			nestXMLTool.setText(<%=currEleName%>, String.valueOf(<%generateMethodUtil.generateExprCode(node.getExpression()); %>));
		}
<%
		}
	}
	private boolean hasParent(OutputTreeNode node){
		if(node.eContainer()!=null){
			OutputTreeNode parent = (OutputTreeNode)node.eContainer();
			if(!("id_Document").equals(parent.getType()) && parent.isMain()){
				return true;
			}
		}
		return false;
	}
	// judge if the current main element has a group or loop element as his child node
	private boolean isRootEndMainNode(OutputTreeNode node){
//		System.out.println(node.getName() + ":main=" + node.isMain() + ":Loop=" + node.isLoop() + ":group=" + node.isGroup());
		if(!node.isMain() || node.isLoop() || node.isGroup()){
			return false;
		}
		for(TreeNode tmpNode: node.getChildren()){
			if(tmpNode.isMain() && (tmpNode.isLoop() || tmpNode.isGroup())){
				return true;
			}
		}
		return false;
	}
	// the root node which a group child or loop child
	private boolean isMediaMainNode(OutputTreeNode node) {
		if(node.isMain()) {
			for(TreeNode tmpNode : node.getChildren()) {
				if(tmpNode.isMain() && (tmpNode.isLoop() || tmpNode.isGroup())) {
					return true;
				}
			}
		}
		return false;
	}
	
	private void generateGroupCode(int index) {
		if(groupList.get(index).size()>0){
%>
			isNewElement = false;
<%
			for(int i=0;i<groupList.get(index).size();i++){
				TreeNode groupRootNode = groupList.get(index).get(i);
%>
					if(isNewElement || groupbyList.size()<=<%=i%> || groupbyList.get(<%=i%>)==null
<%
						for(int j=0;j<groupbyNodeList.get(index).get(i).size();j++){
							TreeNode attr = groupbyNodeList.get(index).get(i).get(j);
%>
					|| ( groupbyList.get(<%=i%>).get(<%=j%>)!=null ? !groupbyList.get(<%=i%>).get(<%=j%>).equals(<%generateMethodUtil.generateExprCode(attr.getExpression());%>) : <%generateMethodUtil.generateExprCode(attr.getExpression());%>!=null )
<% 
						}
			
%>
					){

<%
					generateCode((OutputTreeNode)groupList.get(index).get(i),"group"+i+"_","subTreeRootParent");						
%>	
					if(groupbyList.size()<=<%=i%>){
						groupbyList.add(new java.util.ArrayList<String>());
					}else{
						groupbyList.get(<%=i%>).clear();
					}
<% 
					for(int j=0;j<groupbyNodeList.get(index).get(i).size();j++){
						TreeNode attr = groupbyNodeList.get(index).get(i).get(j);
%>
						groupbyList.get(<%=i%>).add(<%generateMethodUtil.generateExprCode(attr.getExpression());%>);
<% 
					}
%>
					isNewElement=true;
					if(groupElementList.size()<=<%=i%>){
						groupElementList.add(group<%=i%>_);
					}else{
						groupElementList.set(<%=i%>,group<%=i%>_);
					}
			
				}else{
					subTreeRootParent=groupElementList.get(<%=i%>);
				}

			
<% 
		}
	}
}
	
	
	private void generateGroupCmpCode(OutputTreeNode node, int index) {
		for(TreeNode tmpNode : node.getChildren()) {
			if((tmpNode.isGroup()) && !tmpNode.isLoop()) {
				groupbyNodeList.get(index).add(generateMethodUtil.getGroupByNodeList(tmpNode));
				groupList.get(index).add(tmpNode);
				generateGroupCmpCode((OutputTreeNode)tmpNode, index);
			}
		}
	}
}
%>
class NestXMLTool_<%=cid%>{
	public void parseAndAdd(org.dom4j.Element nestRoot, String value){
		try {
            org.dom4j.Document doc4Str = org.dom4j.DocumentHelper.parseText("<root>"+ value + "</root>");
    		nestRoot.setContent(doc4Str.getRootElement().content());
    	} catch (Exception e) {
    		e.printStackTrace();
    		nestRoot.setText(value);
        }
	}
	
	public void setText(org.dom4j.Element element, String value){
		if (value.startsWith("<![CDATA[") && value.endsWith("]]>")) {
			String text = value.substring(9, value.length()-3);
			element.addCDATA(text);
		}else{
			element.setText(value);
		}
	}
	
	public void replaceDefaultNameSpace(org.dom4j.Element nestRoot,org.dom4j.Element declaredDefaultNamespaceElement) {
		if (nestRoot != null) {
			List<org.dom4j.Namespace> declaredNamespaces = nestRoot.declaredNamespaces();
			for(org.dom4j.Namespace namespace : declaredNamespaces) {
				if("".equals(namespace.getPrefix())
						&& !"".equals(namespace.getURI())) {//current element declare a default namespace 
					declaredDefaultNamespaceElement = nestRoot;
					break;
				}
			}
			
			for (org.dom4j.Element tmp : (java.util.List<org.dom4j.Element>) nestRoot
					.elements()) {
				if (declaredDefaultNamespaceElement != null && (tmp.getQName().getNamespace() == org.dom4j.Namespace.NO_NAMESPACE)) {
					tmp.setQName(org.dom4j.DocumentHelper
							.createQName(tmp.getName(),
									declaredDefaultNamespaceElement.getQName()
											.getNamespace()));
				}
				replaceDefaultNameSpace(tmp,declaredDefaultNamespaceElement);
			}
		}
	}
	
	public void removeEmptyElement(org.dom4j.Element root){
		if (root!=null) {
			for (org.dom4j.Element tmp: (java.util.List<org.dom4j.Element>) root.elements()) {
				removeEmptyElement(tmp);
			}
			if (root.content().size() == 0 
    			&& root.attributes().size() == 0 
    			&& root.declaredNamespaces().size() == 0) {
    			if(root.getParent()!=null){
                	root.getParent().remove(root);
                }
            }
		}
	}
}
//NestXMLTool_<%=cid%> nestXMLTool_<%=cid%> = new NestXMLTool_<%=cid%>();

<%
	//init the generate tool.
	GenerateToolByDom4j generateToolByDom4j = new GenerateToolByDom4j();
	generateToolByDom4j.cid = cid;
	generateToolByDom4j.generateMethodUtil = generateMethodUtil;
// define the generate the output document class
int index = -1;
%>
	//the map store the previous value of aggregate columns
	java.util.Map<String,Object> aggregateCacheMap_<%=cid%> = new java.util.HashMap<String,Object>();
<%
for(OutputXmlTree outputTable : outputTables) {
	boolean allowEmptyElement = outputTable.isEnableEmptyElement();
	generateToolByDom4j.allowEmpty = allowEmptyElement;
	
	String tableName = outputTable.getName();
	for(OutputTreeNode outputNode: outputTable.getNodes()) {
		if(("id_Document").equals(outputNode.getType())){
			
			//get the document aggregation columns
			TreeUtil treeUtil = new TreeUtil();
			List<TreeNode> allLeaf = new ArrayList<TreeNode>();
			treeUtil.getAllLeaf(outputNode,allLeaf);
			for(TreeNode leaf : allLeaf) {
				OutputTreeNode outputLeaf = (OutputTreeNode)leaf;
				if(outputLeaf.isAggregate()) {
					String xpath = outputLeaf.getXpath();
%>
					//init the map,the keys is aggregate columns xpath,the values is all null.
					aggregateCacheMap_<%=cid%>.put("<%=xpath%>",null);
<%					
				}
			}
			
			index+=1;
			
			//get the group and loop node count(TDI-18000)
			XMLOrderUtil xmlOrderUtil = new XMLOrderUtil();
			int groupCount = xmlOrderUtil.getGroupCount(outputNode);
			
%>

class GenerateDocumentHelper_<%=tableName%> {
	
	NestXMLTool_<%=cid%> nestXMLTool = new NestXMLTool_<%=cid%>();
	
	//do some work after document has been generated
	void generateOk(Document doc) {
		if(doc == null || doc.getDocument() == null) {
			return;
		}
		nestXMLTool.replaceDefaultNameSpace(doc.getDocument().getRootElement(),null);
<%
		//remove empty element
		if(!allowEmptyElement) {
%>
		nestXMLTool.removeEmptyElement(doc.getDocument().getRootElement());
<%		
		}
%>
	}
	
}

GenerateDocumentHelper_<%=tableName%> generateDocumentHelper_<%=tableName%> = new GenerateDocumentHelper_<%=tableName%>();

class GenerateDocument_<%=tableName %> {

<%
	if(hasDocumentInMainInputTable || hasDocumentInAnyLookupTable) {
		//We generate the TreeNode_API object only if there is a document in the schema.
%>
		TreeNode_API_<%=cid %> treeNodeAPI = null;
<%
	}
%>
	java.util.Map<String,Object> valueMap = null;
	
	DocumentGenerateOrderHelper orderHelper = new DocumentGenerateOrderHelper(<%=groupCount + 1%>);
	
	org.dom4j.Document doc = null;
	
	NestXMLTool_<%=cid%> nestXMLTool = null;
	
	org.dom4j.Element root4Group = null;
	
	org.dom4j.io.OutputFormat format = null;
	
	java.util.List<java.util.List<String>> groupbyList = null;
	java.util.List<org.dom4j.Element> groupElementList = null;
	int order = 0;
	
	boolean isFirst = true;
	
	boolean	needRoot = true;
<%
//Integer groupSize = new Integer(0);
//getGroupSize(outputNode, groupSize);

XMLMapUtil xmu = new XMLMapUtil();

%>
	
    public GenerateDocument_<%=tableName %>() {
//    	this.treeNodeAPI = treeNodeAPI;
    	
    	valueMap = new java.util.HashMap<String,Object>();
    	
    	nestXMLTool = new NestXMLTool_<%=cid%>();
    	
    	groupbyList =  new java.util.ArrayList<java.util.List<String>>();
		groupElementList = new java.util.ArrayList<org.dom4j.Element>();
    	
    	doc = org.dom4j.DocumentHelper.createDocument();
    	format = org.dom4j.io.OutputFormat.createPrettyPrint();
    	format.setTrimText(false);
    }
    
    public org.dom4j.Document getDocument(){
    	return this.doc;
    }
    
	//We generate the TreeNode_API object only if there is a document in the main input table.
    void generateElements(<%if(hasDocumentInMainInputTable || hasDocumentInAnyLookupTable){%>TreeNode_API_<%=cid %> treeNodeAPI,<%}%>boolean isInnerJoin<%
		%><%=xmu.createSignature(node, false) %><%
	
		for (VarTable var : varTables) {
			String tableName1 = var.getName();
	        String instanceVarName = tableName1 + "__" + cid;
	        String className = instanceVarName + "__Struct";
	%>, <%=className %> <%=var.getName()%>
	<%
	}
	%>) {
	
	
	/*if(this.treeNodeAPI==null) {
		this.treeNodeAPI = treeNodeAPI;
	}*/
	
	org.dom4j.Element subTreeRootParent = null;
// build root xml tree 
if (needRoot) {
	needRoot=false;
<%
	OutputTreeNode root = (OutputTreeNode)outputNode.getChildren().get(0); // get the root tree node
	generateToolByDom4j.setAllMainNodes(root);
	generateToolByDom4j.generateCode(root,"root","doc");
%>
		root4Group = subTreeRootParent;
	}else{
		subTreeRootParent=root4Group;
	}
	/* build group xml tree */
	boolean isNewElement = false;
<%
generateToolByDom4j.groupList.add(new java.util.ArrayList<TreeNode>());
generateToolByDom4j.groupbyNodeList.add(new java.util.ArrayList<java.util.List<TreeNode>>());
generateToolByDom4j.generateGroupCmpCode(root, index);
generateToolByDom4j.generateGroupCode(index);
%>
		isNewElement = false;
<%
			
			OutputTreeNode loop = (OutputTreeNode)generateToolByDom4j.getLoopNode(root);
			if(loop==null){
%>
				if(true){
					throw new Exception("Loop element is missing in the output Table:<%=outputTable.getName()%>!");
				}
<%
			} else {
				generateToolByDom4j.generateCode(loop,"loop","subTreeRootParent");
			}
%>
		}
    }

	GenerateDocument_<%=tableName %> gen_Doc_<%=tableName %>_<%=cid %> = new GenerateDocument_<%=tableName %>();
	boolean docAlreadyInstanciate_<%=tableName %> = false;
<%
		} // if(docuemnt)
	}// for(outputNode)
} // for (outputXMLTree)
%>

<%
	//==========================================the next code for Persistent Lookup==============================================
	HashMap<String, AbstractNode> hExternalInputTableEntries = new HashMap<String, AbstractNode>();
	
	String currentJoinedTableNames = "";
	
	int sizeInputTables = inputTables.size();
	        
	List<IConnection> cumulatedInputConnections = new ArrayList<IConnection>();
	
	String comma;
	for (int iInputTable = 0; iInputTable < sizeInputTables - 1; iInputTable++) { 
	        
			InputXmlTree currentInputTable = inputTables.get(iInputTable);
			InputXmlTree nextInputTable = null; 
			
			if(sizeInputTables > 1) {
				nextInputTable = inputTables.get(iInputTable + 1);
			}
			if(currentJoinedTableNames.length() > 0) {
				currentJoinedTableNames += "__";
			}
			currentJoinedTableNames += currentInputTable.getName();
		
			String currentTableName = currentInputTable.getName();
		    IConnection currentConection = hNameToConnection.get(currentTableName);
		    if (currentConection == null) {
		        continue;
		    }
		    cumulatedInputConnections.add(currentConection);
    
		if(nextInputTable != null && nextInputTable.isPersistent()) {
			
			List<IMetadataColumn> nextColumnsKeys = new ArrayList<IMetadataColumn>();
	
		        String nextTableName = nextInputTable.getName();
	            IConnection nextConection = hNameToConnection.get(nextTableName);
	            if (nextConection == null) {
	                continue;
	            }
	  %>
	            class SortableRow_<%= currentJoinedTableNames %> implements Comparable<SortableRow_<%= currentJoinedTableNames %>>, routines.system.IPersistableRow<SortableRow_<%= currentJoinedTableNames %>> { // G_TM_B_001 
	
					boolean is__rejectedInnerJoin;
					<%
			        IMetadataTable nextMetadataTable = nextConection.getMetadataTable();
			        if (nextInputTable != null) {
			            hExternalInputTableEntries.clear();
			            List<TreeNode> trees = nextInputTable.getNodes();
			            if (trees == null) {
			                continue;
			            }

			            
			            List<IMetadataColumn> listColumns = nextMetadataTable.getListColumns();
			            //for (IMetadataColumn column : listColumns) {
			            for(int i=0; i<listColumns.size(); i++){
			            	IMetadataColumn column = listColumns.get(i);
			                TreeNode currentNode = (TreeNode)trees.get(i);
			            	if (currentNode != null) {
			            		String expressionKey = currentNode.getExpression();
			                    if (expressionKey != null && !"".equals(expressionKey.trim())) {
			                    
			                    	nextColumnsKeys.add(column);
			                    
			                    	%><%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>;
			                    	<%
				                           
			                    }
			                }
			            }
					}
				// properties declarations 
				%>
				//<%= currentInputTable.getName() %>
				<%
			        IMetadataTable currentMetadataTable = currentConection.getMetadataTable();
			        if (currentInputTable != null) {
			
						for(IConnection connection : cumulatedInputConnections) {
			            	IMetadataTable joinedTable = connection.getMetadataTable();
			                List<IMetadataColumn> listColumns = joinedTable.getListColumns();
			            	for (IMetadataColumn column : listColumns) {
			                    String columnName = column.getLabel();
			                    
			                    %><%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> <%= connection.getName() %>__<%=column.getLabel() %>;
			                    <%
							}
			            }
			            hExternalInputTableEntries.clear();

			            List<TreeNode> trees = currentInputTable.getNodes();
			            if (trees == null) {
			                continue;
			            }
					}
			        %>
			        public void fillFrom(<%
				        comma = "";
			         	for(IConnection connection : cumulatedInputConnections) {
			         	
			         		IConnection realConnection = org.talend.core.model.utils.NodeUtil.getRealConnectionTypeBased(connection);
			         	
				        	%><%=comma%> <%= realConnection.getName() %>Struct <%= connection.getName() %><%
			         		comma = ", ";
			         	}
			            int sizeNextColumns = nextColumnsKeys.size();
			            for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { 
			            	IMetadataColumn column = nextColumnsKeys.get(iColumn);
			
			         		%><%=comma%> <%= JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable()) %> exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %><%
			            
			            } 
			            
			         %>) {
			
						<%
			        	for(IConnection connection : cumulatedInputConnections) {
			        	
			        		IMetadataTable table = connection.getMetadataTable();
							List<IMetadataColumn> listColumns = table.getListColumns();
			            	for (IMetadataColumn column : listColumns) {
								%>this.<%= connection.getName() %>__<%= column.getLabel() %> = <%= connection.getName() %>.<%= column.getLabel() %>;
			            		<%
			        		}
			        	}
			        	%>
			            <%
			            sizeNextColumns = nextColumnsKeys.size();
			            for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { 
			            	IMetadataColumn column = nextColumnsKeys.get(iColumn);
			
							%>this.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %> = exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>;
							<%
			            
			            } 
			            %>
			        }
			
			        public void copyDataTo(<%
			         
				         comma = "";
				         for(IConnection connection : cumulatedInputConnections) {
				
				            IConnection realConnection = org.talend.core.model.utils.NodeUtil.getRealConnectionTypeBased(connection);
				
					         %><%=comma%><%= realConnection.getName() %>Struct <%= connection.getName() %><%
				         	comma = ", ";
				         }
				         %>) {
				
							<%
				        	for(IConnection connection : cumulatedInputConnections) {
				        	
				        		IMetadataTable table = connection.getMetadataTable();
								List<IMetadataColumn> listColumns = table.getListColumns();
				            	for (IMetadataColumn column : listColumns) {
								%><%= connection.getName() %>.<%= column.getLabel() %> = this.<%= connection.getName() %>__<%= column.getLabel() %>;
				            	<%
				        		}
				        	}
				        	%>
			        }
					public String toString() {
					
						StringBuilder sb = new StringBuilder();
						sb.append(super.toString());
						sb.append("[");
						<%	
						comma = "";
							for(IConnection connection : cumulatedInputConnections) {
						        	
								IMetadataTable metadata = connection.getMetadataTable();
							if (metadata !=null) {
								for (IMetadataColumn column: metadata.getListColumns()) {
										if(comma.length() > 0) {
										%>
											sb.append("<%= comma %>");
										<%
										}
										%>
										sb.append("<%= connection.getName() %>__<%= column.getLabel() %>");
										sb.append("=");
										sb.append(String.valueOf(this.<%= connection.getName() %>__<%= column.getLabel() %>));
									<%
									comma = ", ";
								}
							}
						}
						%>
						sb.append("]");
						
						return sb.toString();
					}
			
			        public int compareTo(SortableRow_<%= currentJoinedTableNames %> other) {
			            int returnValue = 0;
			            <%
			            sizeNextColumns = nextColumnsKeys.size();
			            for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { 
			            	IMetadataColumn column = nextColumnsKeys.get(iColumn);
			            %>
			            	returnValue = checkNullsAndCompare(this.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>, other.exprKey_<%= nextInputTable.getName() %>__<%=column.getLabel() %>);
			            	if (returnValue != 0) {
			                    return returnValue;
			            	}
			            <%
			            } 
			            %>
			            return returnValue;
			        }
			
			        private int checkNullsAndCompare(Object object1, Object object2) {
			            int returnValue = 0;
			            if (object1 instanceof Comparable && object2 instanceof Comparable) {
			                returnValue = ((Comparable) object1).compareTo(object2);
			            } else if (object1 != null && object2 != null) {
			                returnValue = compareStrings(object1.toString(), object2
			                        .toString());
			            } else if (object1 == null && object2 != null) {
			                returnValue = 1;
			            } else if (object1 != null && object2 == null) {
			                returnValue = -1;
			            } else {
			                returnValue = 0;
			            }
			            return returnValue;
			        }
			
			        private int compareStrings(String string1, String string2) {
			            return string1.compareTo(string2);
			        }
			
					public void readData(ObjectInputStream dis) {
						synchronized(<%= currentTableName %>Struct.commonByteArrayLock) {
						    try {
								int length = 0;
								this.is__rejectedInnerJoin = dis.readBoolean();
						<%	
						boolean hasAtLeastOneRead = false;
						boolean hasAtLeastOneObjectType = false;
						if (currentMetadataTable !=null) {
						        for(IConnection connection : cumulatedInputConnections) {
				        		IMetadataTable table = connection.getMetadataTable();
								List<IMetadataColumn> listColumns = table.getListColumns();
				            	for (IMetadataColumn column : listColumns) {
							  	hasAtLeastOneRead = true;
								JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
							 	String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
							 	
						if (JavaTypesManager.isJavaPrimitiveType(column.getTalendType(), column.isNullable())) {
							typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
					    %>
				            this.<%= connection.getName() %>__<%= column.getLabel() %> = dis.read<%= typeToGenerate %>();
						<%
						} else if(("String").equals(typeToGenerate)) {
						%>
				            length = dis.readInt();
			   				if (length == -1) {
			   	    			this.<%= connection.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			   					if(length > <%= currentTableName %>Struct.commonByteArray.length) {
			   						if(length < 1024 && <%= currentTableName %>Struct.commonByteArray.length == 0) {
			           					<%= currentTableName %>Struct.commonByteArray = new byte[1024];
			   						} else {
			           					<%= currentTableName %>Struct.commonByteArray = new byte[2 * length];
			           				}
			   					}
			       				dis.readFully(<%= currentTableName %>Struct.commonByteArray, 0, length);
			       				this.<%= connection.getName() %>__<%= column.getLabel() %> = new String(<%= currentTableName %>Struct.commonByteArray, 0, length);
			   				}
						<%
						} else if(("java.util.Date").equals(typeToGenerate)) {
						%>
				            length = dis.readByte();
			   				if (length == -1) {
			   	    			this.<%= connection.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			   			    	this.<%= connection.getName() %>__<%= column.getLabel() %> = new Date(dis.readLong());
			   				}
						<%
						} else if(("byte[]").equals(typeToGenerate)) {
						%>
				            length = dis.readInt();
			   				if (length == -1) {
			   	    			this.<%= connection.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			       				byte[] byteArray = new byte[length];
			       				dis.readFully(byteArray);
			       				this.<%= connection.getName() %>__<%= column.getLabel() %> = byteArray;
			   				}
						<%
						} else if(("Object").equals(typeToGenerate) || ("BigDecimal").equals(typeToGenerate) || ("List").equals(typeToGenerate)) {
							hasAtLeastOneObjectType = true;
						%>
							this.<%= connection.getName() %>__<%= column.getLabel() %> = (<%= typeToGenerate %>) dis.readObject();
						
						<%
						} else {
							typeToGenerate =JavaTypesManager.getTypeToGenerate(column.getTalendType(), false);
							typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
				            length = dis.readByte();
			   				if (length == -1) {
			   	    			this.<%= connection.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			   					this.<%= connection.getName() %>__<%= column.getLabel() %> = dis.read<%= typeToGenerate %>();
			   				}
						<%
							}
			        	  }
			        	}
			        	%>
			            <%
			            sizeNextColumns = nextColumnsKeys.size();
			            for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { 
			            	IMetadataColumn column = nextColumnsKeys.get(iColumn);
			
						  	hasAtLeastOneRead = true;
							JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
						 	String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
			
						 	if (JavaTypesManager.isJavaPrimitiveType(column.getTalendType(), column.isNullable())) {
						 		typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
				            this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = dis.read<%= typeToGenerate %>();
						<%
						 	} else if(("java.util.Date").equals(typeToGenerate)) {
						%>
				            length = dis.readByte();
			   				if (length == -1) {
			   	    			this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			   			    	this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = new Date(dis.readLong());
			   				}
						<%
						 	} else if(("String").equals(typeToGenerate)) {
						%>
					            length = dis.readInt();
				   				if (length == -1) {
				   	    			this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = null;
				   				} else {
				   					if(length > <%= currentTableName %>Struct.commonByteArray.length) {
				   						if(length < 1024 && <%= currentTableName %>Struct.commonByteArray.length == 0) {
				           					<%= currentTableName %>Struct.commonByteArray = new byte[1024];
				   						} else {
				           					<%= currentTableName %>Struct.commonByteArray = new byte[2 * length];
				           				}
				   					}
				       				dis.readFully(<%= currentTableName %>Struct.commonByteArray, 0, length);
				       				this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = new String(<%= currentTableName %>Struct.commonByteArray, 0, length);
				   				}
						<%
						 	} else if(("byte[]").equals(typeToGenerate)) {
						%>
				            length = dis.readInt();
			   				if (length == -1) {
			   	    			this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			       				byte[] byteArray = new byte[length];
			       				dis.readFully(byteArray);
			       				this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = byteArray;
			   				}
						<%
						 	} else if(("Object").equals(typeToGenerate) || ("BigDecimal").equals(typeToGenerate) || ("List").equals(typeToGenerate)) {
				 		hasAtLeastOneObjectType = true;
						%>
			   				this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = (<%= typeToGenerate %>) dis.readObject();
						
						<%
						 	} else {
						typeToGenerate =JavaTypesManager.getTypeToGenerate(column.getTalendType(), false);
						typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
				            length = dis.readByte();
			   				if (length == -1) {
			   	    			this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = null;
			   				} else {
			   					this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> = dis.read<%= typeToGenerate %>();
			   				}
						<%
						 	}
			            } 
					}
					if(hasAtLeastOneRead) {
						%>
					} catch (IOException e) {
			        throw new RuntimeException(e);
				<%
				}
				%>
				<%
					if(hasAtLeastOneObjectType) {
				%>
					} catch(ClassNotFoundException eCNFE) {
							 throw new RuntimeException(eCNFE);
				<%
				}
				%>
					    	}
						} 
					}
				public void writeData(ObjectOutputStream dos) {
					try {
						   	dos.writeBoolean(this.is__rejectedInnerJoin);
					<%	
					boolean hasAtLeastOneWrite = false;
					if (currentMetadataTable !=null) {
			        	for(IConnection connection : cumulatedInputConnections) {
			        	
			        		IMetadataTable table = connection.getMetadataTable();
							List<IMetadataColumn> listColumns = table.getListColumns();
			            	for (IMetadataColumn column : listColumns) {
							JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
							hasAtLeastOneWrite = true;
						 	String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
							if (JavaTypesManager.isJavaPrimitiveType(column.getTalendType(), column.isNullable())) {
								typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
							%>
			            	dos.write<%= typeToGenerate %>(this.<%= connection.getName() %>__<%= column.getLabel() %>);
						<%
							} else if(("String").equals(typeToGenerate)) {
						%>
							if(this.<%= connection.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeInt(-1);
							} else {
				                byte[] byteArray = this.<%= connection.getName() %>__<%= column.getLabel() %>.getBytes();
			   			    	dos.writeInt(byteArray.length);
			       				dos.write(byteArray);
			            	}
						<%
							} else if(("java.util.Date").equals(typeToGenerate)) {
						%>
							if(this.<%= connection.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeByte(-1);
							} else {
			       				dos.writeByte(0);
			   			    	dos.writeLong(this.<%= connection.getName() %>__<%= column.getLabel() %>.getTime());
			            	}
						<%
							} else if(("byte[]").equals(typeToGenerate)) {
						%>
							if(this.<%= connection.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeInt(-1);
							} else {
			   			    	dos.writeInt(this.<%= connection.getName() %>__<%= column.getLabel() %>.length);
			       				dos.write(this.<%= connection.getName() %>__<%= column.getLabel() %>);
			            	}
						<%
							} else if(("Object").equals(typeToGenerate) || ("BigDecimal").equals(typeToGenerate) || ("List").equals(typeToGenerate)) {
						%>
						    	dos.writeObject(this.<%= connection.getName() %>__<%= column.getLabel() %>);
						<%
							} else {
								typeToGenerate =JavaTypesManager.getTypeToGenerate(column.getTalendType(), false);
								typeToGenerate = typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
							if(this.<%= connection.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeByte(-1);
							} else {
			       				dos.writeByte(0);
			   			    	dos.write<%= typeToGenerate %>(this.<%= connection.getName() %>__<%= column.getLabel() %>);
			            	}
						<%
								}
			        		}
			        	}
			        	%>
			            <%
			            sizeNextColumns = nextColumnsKeys.size();
			            for (int iColumn = 0; iColumn < sizeNextColumns; iColumn++) { 
			            	IMetadataColumn column = nextColumnsKeys.get(iColumn);
			
							JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
							hasAtLeastOneWrite = true;
						 	String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
							if (JavaTypesManager.isJavaPrimitiveType(column.getTalendType(), column.isNullable())) {
								typeToGenerate=typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
				            dos.write<%= typeToGenerate %>(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>);
						<%
						} else if(("String").equals(typeToGenerate)) {
						%>
							if(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeInt(-1);
							} else {
				                byte[] byteArray = this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>.getBytes();
			   			    	dos.writeInt(byteArray.length);
			       				dos.write(byteArray);
			            	}
						<%
						} else if(("java.util.Date").equals(typeToGenerate)) {
						%>
							if(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeByte(-1);
							} else {
			       				dos.writeByte(0);
			   			    	dos.writeLong(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>.getTime());
			            	}
						<%
						} else if(("byte[]").equals(typeToGenerate)) {
						%>
							if(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeInt(-1);
							} else {
			   			    	dos.writeInt(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>.length);
			       				dos.write(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>);
			            	}
						<%
						} else if(("Object").equals(typeToGenerate) || ("BigDecimal").equals(typeToGenerate) || ("List").equals(typeToGenerate)) {
						%>
						    	dos.writeObject(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>);
						<%
						} else {
								typeToGenerate =JavaTypesManager.getTypeToGenerate(column.getTalendType(), false);
								typeToGenerate = typeToGenerate.substring(0,1).toUpperCase()+typeToGenerate.substring(1);
						%>
							if(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %> == null) {
				                dos.writeByte(-1);
							} else {
			       				dos.writeByte(0);
			   			    	dos.write<%= typeToGenerate %>(this.exprKey_<%= nextInputTable.getName() %>__<%= column.getLabel() %>);
			            	}
						<%
							}
			            } 
					}
					if(hasAtLeastOneWrite) {
					%>
						} catch (IOException e) {
					        throw new RuntimeException(e);
					<%
					}
					%>
			    }
			}
	     }
	   <%}
	}
	%>
	            