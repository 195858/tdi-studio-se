/**
 * queued message exchange
 */
class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;
	private T faultDetails = null;
	private String faultMessage = null;

	public QueuedExchangeContextImpl(T inMsg) {
		this.input = inMsg;
	}

	/**
	 * Don't forget to call this method when you are done
	 *  with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInputMessage() {
		System.out.println(System.currentTimeMillis() + " -> getInputMessage");
		T request = input;
		System.out.println("Recieved message");
		System.out.println(System.currentTimeMillis() + " <- getInputMessage: ");
		return request;
	}

	public void serveOutputMessage(T response) {
		System.out.println(System.currentTimeMillis() + " -> serveOutputMessage");
		this.output = response;
		System.out.println(System.currentTimeMillis() + " <- serveOutputMessage");
	}

	public void serveOutputFault(String faultMessage, T faultDetails) {
		System.out.println(System.currentTimeMillis() + " -> serveOutputFault");
		this.faultMessage = faultMessage;
		this.faultDetails = faultDetails;
		System.out.println(System.currentTimeMillis() + " <- serveOutputFault");
	}

	public boolean isFault() {
		return (faultMessage != null);
	}

	public T getResponse() {
		return output;
	}

	public T getFaultDetails() {
		return faultDetails;
	}

	public String getFaultMessage() {
		return faultMessage;
	}
}

/**
 * message exchange controller
 */
class QueuedMessageHandlerImpl<T> {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			// throw new
			// Exception("Can't queue request, queue size of "
			// + MAX_QUEUE_SIZE + " is exceeded");
			context.serveOutputFault("job pool overflow exceed", null);
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				context.serveOutputFault("job execution timeout: " + ie.getMessage(), null);
			}
		}
		return context;
	}

	/**
	 * Blocking method to obtain the next message from the queue
	 *
	 * @return
	 * @throws InterruptedException
	 */
	@SuppressWarnings("unchecked")
	public QueuedExchangeContextImpl<T> next() throws InterruptedException {
		return (QueuedExchangeContextImpl<T>) queue.take();
	}

	public QueuedExchangeContextImpl<T> fetchNext() throws Exception {
		return next();
	}
}

/**
 * web service provider implementation
 */
@javax.jws.WebService(
		name = "TalendJobAsWebService",
		targetNamespace = "http://talend.org/esb/service/job"
	)
@javax.jws.soap.SOAPBinding(
		parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE
	)
@javax.xml.ws.ServiceMode(
		value = javax.xml.ws.Service.Mode.PAYLOAD
	)
//@javax.xml.ws.ServiceMode(value = javax.xml.ws.Service.Mode.MESSAGE)
@javax.xml.ws.WebServiceProvider()
class ESBProvider_<%=cid%> implements
		javax.xml.ws.Provider<javax.xml.transform.Source> {

	private javax.xml.transform.TransformerFactory factory =
		javax.xml.transform.TransformerFactory.newInstance();	
	private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	public ESBProvider_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
		this.messageHandler = messageHandler;
	}

	@javax.jws.WebMethod(
			operationName = "invoke",
			action = "http://talend.org/esb/service/job/invoke"
		)
	@javax.jws.WebResult(
			name = "jobOutput",
			targetNamespace = "http://talend.org/esb/service/job",
			// targetNamespace = "",
			partName = "response"
		)
	public javax.xml.transform.Source invoke(
			@javax.jws.WebParam(
					name = "jobInput",
					targetNamespace = "http://talend.org/esb/service/job",
					// targetNamespace = "",
					partName = "request"
				) javax.xml.transform.Source request) {

		System.out.println(System.currentTimeMillis() + " -> handleMessage");

		try {
			org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
			factory.newTransformer().transform(request, docResult);
			org.dom4j.Document requestDoc = docResult.getDocument();


			// print
			java.io.ByteArrayOutputStream baosRequest = new java.io.ByteArrayOutputStream();
			factory.newTransformer().transform(
					new org.dom4j.io.DocumentSource(requestDoc),
					new javax.xml.transform.stream.StreamResult(baosRequest)
				);
			System.out.println("request: " + baosRequest.toString());


			QueuedExchangeContextImpl<org.dom4j.Document> messageExchange =
				messageHandler.invoke(requestDoc);

			try {
				if (messageExchange.isFault()) {
					String faultString = messageExchange.getFaultMessage();
					System.out.println("fault: " + faultString);
					
					org.dom4j.Document faultDoc = messageExchange.getFaultDetails();

					javax.xml.soap.SOAPFactory soapFactory =
						javax.xml.soap.SOAPFactory.newInstance();
					javax.xml.soap.SOAPFault soapFault =
						soapFactory.createFault(faultString,
								new javax.xml.namespace.QName(TNS, "businessFault"));
					if (null != faultDoc) {
						org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter();
						org.w3c.dom.Document faultDetailDom = writer.write(faultDoc);
						soapFault.addDetail().appendChild(
								soapFault.getOwnerDocument().importNode(
										faultDetailDom.getDocumentElement(), true));
						
						// print
						java.io.ByteArrayOutputStream baosFault = new java.io.ByteArrayOutputStream();
						factory.newTransformer().transform(
								new org.dom4j.io.DocumentSource(faultDoc),
								new javax.xml.transform.stream.StreamResult(baosFault)
							);
						System.out.println("fault details: " + baosFault.toString());
					}
					throw new javax.xml.ws.soap.SOAPFaultException(soapFault);
				} else {
					org.dom4j.Document responseDoc = messageExchange.getResponse();

					// print
					java.io.ByteArrayOutputStream baosResponse = new java.io.ByteArrayOutputStream();
					factory.newTransformer().transform(
							new org.dom4j.io.DocumentSource(responseDoc),
							new javax.xml.transform.stream.StreamResult(baosResponse)
						);
					System.out.println("response: " + baosResponse.toString());

					return new org.dom4j.io.DocumentSource(responseDoc);
				}
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (Exception ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		} finally {
			System.out.println(System.currentTimeMillis() + " <- handleMessage");
		}
	}
}

class HandlerThread_<%=cid%> extends Thread {

	private final String TNS = ESBProvider_<%=cid%>.class.getAnnotation(
			javax.jws.WebService.class).targetNamespace();

	private final String serviceName;

	private javax.xml.ws.Endpoint endpoint;
	QueuedMessageHandlerImpl<org.dom4j.Document> handler;

	public HandlerThread_<%=cid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> handler,
			String serviceName) {
		this.handler = handler;
		this.serviceName = serviceName;
	}

	public void run() {
		ESBProvider_<%=cid%> esbProvider = new ESBProvider_<%=cid%>(handler);

		endpoint = javax.xml.ws.Endpoint.create(esbProvider);
		@SuppressWarnings("serial")
		java.util.Map<String, Object> map = new java.util.HashMap<String, Object>() {{
			put(javax.xml.ws.Endpoint.WSDL_SERVICE,
					new javax.xml.namespace.QName(TNS, serviceName));
			put(javax.xml.ws.Endpoint.WSDL_PORT,
					new javax.xml.namespace.QName(TNS, serviceName + "SoapBinding"));
		}};
		endpoint.setProperties(map);
		endpoint.publish(endpointUrl);

		System.out.println("web service [endpoint: " + endpointUrl + "] published");
	}

	public void stopEndpoint() {
		if (null != endpoint) {
			endpoint.stop();
			System.out.println("web service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}
