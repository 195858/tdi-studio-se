// ============================================================================
//
// Talend Community Edition
//
// Copyright (C) 2006-2007 Talend - www.talend.com
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// ============================================================================
package org.talend.repository.ui.wizards.genHTMLDoc;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.XMLWriter;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.emf.common.util.EList;
import org.eclipse.swt.graphics.ImageData;
import org.osgi.framework.Bundle;
import org.talend.commons.exception.ExceptionHandler;
import org.talend.core.CorePlugin;
import org.talend.core.model.general.Project;
import org.talend.core.model.metadata.IMetadataColumn;
import org.talend.core.model.metadata.IMetadataTable;
import org.talend.core.model.process.EComponentCategory;
import org.talend.core.model.process.ElementParameterParser;
import org.talend.core.model.process.IElementParameter;
import org.talend.core.model.process.INode;
import org.talend.core.model.process.IProcess;
import org.talend.core.model.properties.ProcessItem;
import org.talend.designer.core.model.utils.emf.talendfile.ConnectionType;
import org.talend.repository.RepositoryPlugin;
import org.talend.repository.constants.MapComponentsConstants;
import org.talend.repository.model.RepositoryConstants;
import org.talend.repository.ui.wizards.exportjob.ExportFileResource;
import org.talend.repository.utils.FileCopyUtils;
import org.talend.repository.utils.RepositoryPathProvider;

/**
 * This class is used for generating HTML file.
 * 
 * $Id: XMLGenerator.java 2007-3-8,下午01:09:34 ftang $
 * 
 */
public class HTMLDocGenerator {

    private static Map<String, List> targetConnectionMap = null;

    private static Map<String, List> sourceConnectionMap = null;

    private static final String PIC_FOLDER_NAME = "pictures";

    private static final String TEMP_FOLDER_NAME = "userHTMLDoc";

    private static Map<String, String> picFilePathMap;

    private static final String EMPTY_ELEMENT_VALUE = "none";

    private static final String TITLE = "Generated by Talend Open Studio. (www.talend.com)";

    private static final String JOB_PREVIEW_PIC_SUFFIX = ".jpg";

    private static final String PICTUREFOLDERPATH = "pictures/";

    private static final String TALEND_LOGO_FILE_NAME = "logo.jpg";

    private static final String XSL_FILE_PATH = "resources/Job.xsl";

    private static final String LOGO_FILE_PATH = "icons/logo.jpg";
    
    private static final String WEBSITE_LINK = "http://www.talend.com";

    /**
     * This method is used for generating HTML file base on an instance of <code>ExportFileResource</code>
     * 
     * @param resource
     */
    public static void generateHTMLFile(ExportFileResource resource) {
        try {
            String jobName = resource.getProcess().getProperty().getLabel();

            String tempFolderPath = checkTempDirIsExists(resource);

            generateXMLFile(resource, tempFolderPath);

            String picFolderPath = checkPicDirIsExists(resource, tempFolderPath);

            final Bundle b = Platform.getBundle(RepositoryPlugin.PLUGIN_ID);

            final URL xslFileUrl = FileLocator.toFileURL(FileLocator.find(b, new Path(XSL_FILE_PATH), null));
            final URL logoFileUrl = FileLocator.toFileURL(FileLocator.find(b, new Path(LOGO_FILE_PATH), null));

            String xslFilePath = xslFileUrl.getPath();
            String logoFilePath = logoFileUrl.getPath();

            FileCopyUtils.copy(logoFilePath, picFolderPath + File.separatorChar + TALEND_LOGO_FILE_NAME);

            Set keySet = picFilePathMap.keySet();
            for (Object key : keySet) {
                String value = (String) picFilePathMap.get(key);
                FileCopyUtils.copy(value, picFolderPath + File.separatorChar + key);
            }

            List<URL> resultFiles = parseXML2HTML(tempFolderPath, jobName, xslFilePath);

            addResources(resource, resultFiles);
        } catch (Exception e) {
            e.printStackTrace();
            ExceptionHandler.process(e);

        }

        targetConnectionMap = null;
        sourceConnectionMap = null;
    }

    /**
     * Checks if pictures directory is existing.
     * 
     * @param resource
     */
    private static String checkPicDirIsExists(ExportFileResource resource, String tempFolderPath) {
        String picFolderPath = tempFolderPath + File.separator + PIC_FOLDER_NAME;
        File file = new File(picFolderPath);
        if (!file.exists()) {
            file.mkdir();
        }
        return picFolderPath;

    }

    /**
     * Checks if temporary directory is existing.
     * 
     * @param resource
     * @return
     */
    private static String checkTempDirIsExists(ExportFileResource resource) {
        String tempDirPath = getTmpFolder() + File.separator + resource.getDirectoryName();
        File file = new File(tempDirPath);
        if (!file.exists()) {
            file.mkdirs();
        }
        return tempDirPath;
    }

    /**
     * Using xslt to parse the xml to html.
     * 
     * @param jobName
     * @param tempFolderPath
     * @param xslFileName
     * 
     * @return top folder path of this job.
     * @throws Exception
     */
    private static List<URL> parseXML2HTML(String tempFolderPath, String jobName, String xslFilePath) throws Exception {
        List<URL> list = new ArrayList<URL>(1);

        HTMLHandler.generate(tempFolderPath, jobName, xslFilePath);

        File tmpFolder = new File(tempFolderPath);

        File[] files = tmpFolder.listFiles();
        for (int i = 0; i < files.length; i++) {
            // Checks if current file is html file, xml file and Pictures folder which need be exported,
            // otherwise ignore it.
            if (!(files[i].isDirectory() && !files[i].toString().endsWith(PIC_FOLDER_NAME))) {
                list.add(files[i].toURL());
            }
        }

        return list;
    }

    /**
     * Generates the xml file base on an instance of <code>ExportFileResource</code> and the temporary folder path.
     * 
     * @param resource
     * @param tempFolderPath
     */
    private static void generateXMLFile(ExportFileResource resource, String tempFolderPath) throws Exception {
        ProcessItem processItem = resource.getProcess();
        targetConnectionMap = new HashMap<String, List>();
        sourceConnectionMap = new HashMap<String, List>();
        getSourceAndTargetConnection(processItem);

        Document document = DocumentHelper.createDocument();
        Element projectElement = generateProjectInfo(document);
        Element jobElement = generateJobInfo(processItem, projectElement);
        generateComponentsInfo(jobElement, processItem);

        generateExternalNodeInfo(jobElement);

        EList connectionList = processItem.getProcess().getConnection();
        if (connectionList != null || connectionList.size() != 0) {
            generateConnectionsInfo(jobElement, connectionList);
        }

        XMLWriter output = null;
        FileOutputStream out = null;
        Writer writer = null;

        try {
            // OutputFormat format = OutputFormat.createPrettyPrint();
            String filePath = tempFolderPath + File.separatorChar + processItem.getProperty().getLabel() + ".xml";
            out = new java.io.FileOutputStream(filePath);
            writer = new OutputStreamWriter(out, "UTF-8");
            document.write(writer);
            writer.close();
            out.close();
        } finally {

            if (writer != null) {
                try {

                } catch (Exception e) {
                    ExceptionHandler.process(e);
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (Exception e) {
                    ExceptionHandler.process(e);
                }
            }
            if (output != null)
                try {
                    output.close();
                } catch (Exception e) {
                    ExceptionHandler.process(e);
                }
        }
    }

    /**
     * Generates connections information base on <code>jobElement</code>,<code>connectionList</code>
     * 
     * @param jobElement
     * @param connectionList
     */
    private static void generateConnectionsInfo(Element jobElement, EList connectionList) {
        Element connectionsElement = jobElement.addElement("connections");
        for (int j = 0; j < connectionList.size(); j++) {
            ConnectionType type = (ConnectionType) connectionList.get(j);
            Element connectionElement = connectionsElement.addElement("connection");
            connectionElement.addAttribute("label", checkString(type.getLabel()));
            connectionElement.addAttribute("lineStyle", checkString(type.getLineStyle() + ""));
            connectionElement.addAttribute("metaname", checkString(type.getMetaname()));
            connectionElement.addAttribute("offsetLabelX", checkString(type.getOffsetLabelX() + ""));
            connectionElement.addAttribute("offsetLabelY", checkString(type.getOffsetLabelY() + ""));
            connectionElement.addAttribute("source", checkString(type.getSource()));
            connectionElement.addAttribute("target", checkString(type.getTarget()));
        }
    }

    /**
     * Generates external noode information base on job element.
     * 
     * @param jobElement <code>Element</code>
     */
    private static void generateExternalNodeInfo(Element jobElement) {
        // Element externalNodeElement = jobElement.addElement("externalNode");
        // externalNodeElement.addAttribute("name", "externalTestName");
        // externalNodeElement.addAttribute("link", "c:/textlinkfile.xml");
    }

    /**
     * Generates components information base on
     * <code>componentElement</code><code>jobElement</code><code>processItem</code>
     * 
     * @param componentElement
     * @param jobElement
     * @param processItem
     * @return an instance of <code>Element</code>
     */
    private static void generateComponentsInfo(Element jobElement, ProcessItem processItem) {
        IProcess process = CorePlugin.getDefault().getDesignerCoreService().getProcessFromProcessItem(processItem);
        List<INode> graphicalNodeList = (List<INode>) process.getGraphicalNodes();

        List<INode> componentList = new ArrayList<INode>();
        Map<String, String> componentNameTypeMap = new HashMap<String, String>();
        Element componentNameListElement = null;
        int x = 0, y = 0, width = 0, height = 0;
        for (INode node : graphicalNodeList) {

            // If component is not activate, do not need to get it's information
            if (!node.isActivate()) {
                continue;
            }

            componentList.add(node);

            if (node.getLocation() != null) {
                Point point = node.getLocation();
                x = point.x;
                y = point.y;
            }

            ImageData imageData = node.getComponent().getIcon32().getImageData();
            if (imageData != null) {
                width = imageData.width;
                height = imageData.height;
            }

            if (componentNameListElement == null) {
                componentNameListElement = jobElement.addElement("componentList");
            }
            Element componentItemElement = null;
            componentItemElement = componentNameListElement.addElement("componentItem");
            componentItemElement.addAttribute("name", node.getUniqueName());
            componentItemElement.addAttribute("link", node.getUniqueName());
            componentItemElement.addAttribute("type", node.getComponent().getName());
            componentItemElement.addAttribute("leftTopX", x + "");
            componentItemElement.addAttribute("leftTopY", y + "");
            componentItemElement.addAttribute("rightBottomX", x+width + "");
            componentItemElement.addAttribute("rightBottomY", y+height + "");
        }

        for (INode node : componentList) {
            Element componentElement = jobElement.addElement("component");
            String relativePath = getComponentIconPath(node);
            String componentIconFileName = relativePath.substring(relativePath.lastIndexOf("/") + 1);

            String uniqueName = node.getUniqueName();
            componentElement.addAttribute("icon", PICTUREFOLDERPATH + componentIconFileName);
            componentElement.addAttribute("uniqueName", uniqueName);

            // Stores the path of component icon.
            picFilePathMap.put(componentIconFileName, relativePath);
            componentElement.addAttribute("label", uniqueName);

            String componentName = node.getComponent().getName();
            boolean isMapComponent = componentName.equals(MapComponentsConstants.TMAP)
                    || componentName.equals(MapComponentsConstants.TELTMYSQLMAP)
                    || componentName.equals(MapComponentsConstants.TELTORACLEMAP);
            boolean istRunJob = node.getComponent().getName().equals("tRunJob");
            String previewImagePath, storedPreviewImagePath = "";

            // If component is tMap, gets its preview picture.
            if (isMapComponent) {
                previewImagePath = getPreviewImagePath(node.getElementParameters());
                if (!previewImagePath.equals("")) {
                    IPath filePath = RepositoryPathProvider.getPathFileName(RepositoryConstants.IMG_DIRECTORY,
                            previewImagePath);
                    File file = new File(filePath.toOSString());
                    if (file.exists()) {
                        storedPreviewImagePath = filePath.toOSString();
                        picFilePathMap.put(previewImagePath, storedPreviewImagePath);
                        componentElement.addAttribute("preview", PICTUREFOLDERPATH + previewImagePath);
                    }
                }
            }

            List<String> sourceList = sourceConnectionMap.get(uniqueName);

            // Gets the input of current component.
            if (sourceList != null && sourceList.size() > 0) {
                for (String string : sourceList) {
                    Element inputElement = componentElement.addElement("input");
                    inputElement.addAttribute("link", string);
                    inputElement.setText(checkString(string));
                }
            } else {// Sets the value of input to 'none'.
                Element inputElement = componentElement.addElement("input");
                inputElement.setText(EMPTY_ELEMENT_VALUE);
            }

            List<String> targetList = targetConnectionMap.get(uniqueName);
            // Gets the output of current component.
            if (targetList != null && targetList.size() > 0) {
                for (String string : targetList) {
                    Element outputElement = componentElement.addElement("output");
                    outputElement.addAttribute("link", string);
                    outputElement.setText(string);
                }
            } else {// Sets the value of output to 'none'.
                Element inputElement = componentElement.addElement("output");
                inputElement.setText(EMPTY_ELEMENT_VALUE);
            }

            Element componentTypeElement = componentElement.addElement("componentType");
            componentTypeElement.setText(checkString(node.getComponent().getName()));

            Element parametersElement = componentElement.addElement("parameters");

            List elementParameterList = node.getElementParameters();

            generateComponentElementParamInfo(isMapComponent, istRunJob, parametersElement, elementParameterList);

            List metaDataList = node.getMetadataList();

            if (metaDataList != null && metaDataList.size() != 0) {
                Element schemasElement = componentElement.addElement("schemas");

                for (int j = 0; j < metaDataList.size(); j++) {
                    IMetadataTable table = (IMetadataTable) metaDataList.get(j);
                    List columnTypeList = table.getListColumns();
                    Element schemaElement = schemasElement.addElement("schema");

                    String metaName = table.getLabel();
                    if (metaName == null) {
                        metaName = table.getTableName();
                    }
                    schemaElement.addAttribute("name", checkString(metaName));

                    for (int k = 0; k < columnTypeList.size(); k++) {
                        IMetadataColumn columnType = (IMetadataColumn) columnTypeList.get(k);
                        Element columnElement = schemaElement.addElement("column");

                        columnElement.addAttribute("name", checkString(columnType.getLabel()));

                        columnElement.addAttribute("key", checkString(columnType.isKey() + ""));
                        columnElement.addAttribute("type", checkString(columnType.getType()));
                        columnElement.addAttribute("length", checkString(columnType.getLength() + ""));
                        columnElement.addAttribute("precision", checkString(columnType.getPrecision() + ""));
                        columnElement.addAttribute("nullable", checkString(columnType.isNullable() + ""));
                        columnElement.addAttribute("comment", checkString(ElementParameterParser.parse(node, columnType
                                .getComment())));
                    }
                }
            }
        }
    }

    /**
     * Generates the element parameters information of component.
     * 
     * @param istMap
     * @param istRunJob
     * @param parametersElement
     * @param elementParameterList
     */
    private static void generateComponentElementParamInfo(boolean istMap, boolean istRunJob, Element parametersElement,
            List elementParameterList) {
        if (elementParameterList != null && elementParameterList.size() != 0) {
            if (istMap) {
                generateElementInfoOnlyFortMap(parametersElement, elementParameterList);
            } else {
                int numRow = 1;
                boolean isNewParam = true;

                for (int j = 0; j < elementParameterList.size(); j++) {
                    IElementParameter type = (IElementParameter) elementParameterList.get(j);

                    if (type.isShow(elementParameterList)
                            && ((type.getCategory().equals(EComponentCategory.PROPERTY) || (type.getCategory()
                                    .equals(EComponentCategory.DOC))))
                            && (!type.getName().equals("SCHEMA"))
                            && (!type.getName().equals("PROPERTY_TYPE"))
                            && (!type.getName().equals("QUERYSTORE_TYPE"))
                            && (!type.getName().equals("PROPERTY") 
                            && (!(istRunJob && type.getName().equals("PROCESS"))))) {

                        // Gets the display name of a selected combo item.
                        String value = "";
                        if (type.getName().equals("TYPE")) {

                            int index = type.getIndexOfItemFromList(type.getDisplayName());
                            value = checkString(type.getListItemsDisplayName()[index]);
                        } else {
                            value = checkString(type.getValue().toString());
                        }
                        // parameterElement = parametersElement.addElement("parameter");
                        Element columnElement = parametersElement.addElement("column");
                        columnElement.addAttribute("name", checkString(type.getDisplayName()));
                        columnElement.setText(value);
                    }
                }
            }
        }
    }

    /**
     * Generates parameter element information only for component 'tMap'.
     * 
     * @param parametersElement
     * @param elementParameterList
     */
    private static void generateElementInfoOnlyFortMap(Element parametersElement, List elementParameterList) {
        if (elementParameterList != null && elementParameterList.size() != 0) {
            Element parameterElement = null;
            for (int j = 0; j < elementParameterList.size(); j++) {
                IElementParameter type = (IElementParameter) elementParameterList.get(j);
                if (type.isShow(elementParameterList)
                        && ((type.getCategory().equals(EComponentCategory.PROPERTY) || (type.getCategory()
                                .equals(EComponentCategory.DOC))))) {
                    if (type.getName().equals("COMMENT")) {
                        parameterElement = parametersElement.addElement("parameter");
                        Element columnElement = parameterElement.addElement("column");
                        columnElement.addAttribute("name", checkString(type.getName()));
                        columnElement.setText(type.getValue().toString());
                        return;
                    }
                }
            }
        }
    }

    /**
     * Gets tMap's preview image path base on a list of <code>IElementParameter</code>
     * 
     * @param elementParameters
     * @return
     */
    private static String getPreviewImagePath(List<? extends IElementParameter> elementParameters) {

        for (IElementParameter parameter : elementParameters) {
            IElementParameter type = parameter;
            if (type.getName().equals("PREVIEW")) {
                return type.getValue().toString();
            }
        }

        return "";
    }

    /**
     * Generates job(process) information in XML base on <code>ProcessItem</code> and project element.
     * 
     * @param processItem <code>ProcessItem</code>
     * @param projectElement <code>Element</code>
     * @return an instance of <code>Element</code>
     */
    private static Element generateJobInfo(ProcessItem processItem, Element projectElement) {

        picFilePathMap = new HashMap<String, String>();
        IProcess process = CorePlugin.getDefault().getDesignerCoreService().getProcessFromProcessItem(processItem);
        String jobName = process.getLabel();
        Element jobElement = projectElement.addElement("job");
        jobElement.addAttribute("name", checkString(jobName));

        jobElement.addAttribute("author", checkString(process.getAuthor().toString()));
        jobElement.addAttribute("version", checkString(process.getVersion()));
        jobElement.addAttribute("purpose", checkString(process.getPurpose()));
        jobElement.addAttribute("status", checkString(process.getStatusCode()));
        jobElement.addAttribute("description", checkString(process.getDescription()));

        jobElement.addAttribute("creation", checkDate(processItem.getProperty().getCreationDate()));
        jobElement.addAttribute("modification", checkDate(processItem.getProperty().getModificationDate()));

        String picName = jobName + JOB_PREVIEW_PIC_SUFFIX;
        IPath filePath = RepositoryPathProvider.getPathFileName(RepositoryConstants.IMG_DIRECTORY_OF_JOB_OUTLINE,
                picName);
        String filePathStr = filePath.toOSString();
        File file = new File(filePathStr);
        if (file.exists()) {
            Element previewElement = jobElement.addElement("preview");
            previewElement.addAttribute("picture", PICTUREFOLDERPATH + picName);
            picFilePathMap.put(picName, filePathStr);
        }
        return jobElement;
    }

    /**
     * Generates project element information in XML file.
     * 
     * @param document <code>Document</code>
     * @return an instance of <code>Element</code>
     */
    private static Element generateProjectInfo(Document document) {
        Element projectElement = document.addElement("project");
        projectElement.addAttribute("name", getProject().getLabel());
        projectElement.addAttribute("logo", PICTUREFOLDERPATH + TALEND_LOGO_FILE_NAME);
        projectElement.addAttribute("title", TITLE);
        projectElement.addAttribute("link", WEBSITE_LINK);
        projectElement.addAttribute("language", getProject().getLanguage().getName());
        projectElement.addAttribute("description", getProject().getDescription());
        projectElement.addAttribute("generatedDate", DateFormat.getDateTimeInstance().format(new Date()));
        projectElement.addAttribute("version", getCurrentTOSVersion());
        return projectElement;
    }

    /**
     * Add resources.
     * 
     * @param resource <code>ExportFileResource</code>
     * @param resultFiles a <code>List</code> of <code>URL</code>
     */
    private static void addResources(ExportFileResource resource, List<URL> resultFiles) {
        resource.addResources(resultFiles);
    }

    /**
     * Get the current project.
     * 
     * @return an instance of <code>Project</code>
     */
    private static Project getProject() {
        return ((org.talend.core.context.RepositoryContext) CorePlugin.getContext().getProperty(
                org.talend.core.context.Context.REPOSITORY_CONTEXT_KEY)).getProject();
    }

    /**
     * Strings handler.
     * 
     * @param str <code>String</code>
     * @return string
     */
    private static String checkString(String str) {
        if (str == null) {
            return "";
        }
        return str;
    }

    private static String checkDate(Date date) {
        if (date == null) {
            return "";
        }
        DateFormat formatter = DateFormat.getDateTimeInstance();
        return formatter.format(date);
    }

    /**
     * Get source connections and target connections base on given <code>ProcessItem</code>.
     * 
     * @param processItem ProcessItem
     */
    private static void getSourceAndTargetConnection(ProcessItem processItem) {
        EList connectionList = processItem.getProcess().getConnection();

        List<String> targetList = new ArrayList<String>();
        List<String> sourceList = new ArrayList<String>();

        if (connectionList != null || connectionList.size() != 0) {
            for (int j = 0; j < connectionList.size(); j++) {
                ConnectionType type = (ConnectionType) connectionList.get(j);
                if (!targetConnectionMap.containsKey(type.getSource())) {
                    targetList = new ArrayList<String>();
                }
                if (!targetList.contains(type.getTarget())) {
                    targetList.add(type.getTarget());
                }

                targetConnectionMap.put(type.getSource(), targetList);

                if (!sourceConnectionMap.containsKey(type.getTarget())) {
                    sourceList = new ArrayList<String>();
                }
                sourceList.add(type.getSource());
                sourceConnectionMap.put(type.getTarget(), sourceList);
            }
        }
    }

    /**
     * Gets the temporary folder.
     * 
     * @return a string representing temporary folder
     */
    protected static String getTmpFolder() {
        String tmpFold = System.getProperty("user.dir") + File.separatorChar + TEMP_FOLDER_NAME; //$NON-NLS-1$
        // String tmpFold = System.getProperty("osgi.instance.area") +
        return tmpFold;
    }

    /**
     * Gets the file path of component icon base on node.
     * 
     * @return a string reprenenting component icon's path
     */
    private static String getComponentIconPath(INode node) {
        String string = node.getComponent().getIcon32().toString();
        String path = string.substring("URLImageDescriptor(".length(), string.length() - 1); //$NON-NLS-1$
        try {
            return new URL(path).getPath();
        } catch (MalformedURLException e) {
            ExceptionHandler.process(e);
        }
        return null;
    }

    /**
     * This method is used for generating current T.O.S version.
     * 
     * @return
     */
    private static String getCurrentTOSVersion() {
        String currentVersion = "UNKNOWN";
        currentVersion = (String) RepositoryPlugin.getDefault().getBundle().getHeaders().get(
                org.osgi.framework.Constants.BUNDLE_VERSION);
        return currentVersion;
    }
}
